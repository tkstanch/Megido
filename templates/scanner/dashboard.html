{% extends 'base.html' %}

{% block title %}Vulnerability Scanner - Megido Security{% endblock %}

{% block breadcrumb %}
<li class="text-gray-500 dark:text-gray-400">Megido Security</li>
<li class="text-gray-400 dark:text-gray-500 mx-2">/</li>
<li class="text-gray-900 dark:text-white font-medium">Scanner</li>
{% endblock %}

{% block extra_style %}{% endblock %}

{% block content %}
<div class="max-w-7xl mx-auto space-y-6">
    <!-- Ultra Extreme Hero Section with Cinema Effects -->
    <div class="relative overflow-hidden rounded-3xl mb-8 shadow-ultra-deep grain light-ray">
        <!-- Animated Aurora Background -->
        <div class="absolute inset-0 bg-aurora opacity-95"></div>
        
        <!-- Liquid Glow Blobs -->
        <div class="absolute top-10 left-10 w-64 h-64 liquid-glow blur-3xl"></div>
        <div class="absolute bottom-10 right-10 w-80 h-80 bg-secondary-400/30 liquid blob blur-3xl"></div>
        
        <!-- Vignette Overlay -->
        <div class="absolute inset-0 vignette"></div>
        
        <!-- Content with Multi-Layered Glassmorphism -->
        <div class="relative glass-frosted-film p-8 lg:p-12 text-center backdrop-blur-sm">
            <!-- Hyper-Glow Icon with Diamond Sparkle -->
            <div class="inline-flex items-center justify-center w-20 h-20 lg:w-24 lg:h-24 mb-6 rounded-2xl glass-multi-glow icon-hyper-glow diamond-sparkle float-element breathe">
                <svg class="w-12 h-12 lg:w-14 lg:h-14 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <circle cx="11" cy="11" r="8"></circle>
                    <line x1="21" y1="21" x2="16.65" y2="16.65"></line>
                </svg>
            </div>
            
            <!-- Title with 3D Text and Reveal Animation -->
            <h2 class="text-3xl lg:text-5xl font-bold text-white text-3d mb-3">
                <span class="text-shimmer text-reveal">Vulnerability Scanner</span>
            </h2>
            
            <!-- Subtitle with Underline Burst -->
            <p class="text-lg lg:text-xl text-white/90 font-light underline-burst">
                Automatically scan web applications for common security vulnerabilities.
            </p>
            
            <!-- Ultra Feature Badges with Living Borders -->
            <div class="mt-6 flex flex-wrap gap-3 justify-center">
                <span class="px-5 py-2.5 rounded-full glass-layered border-aurora-glow text-white text-sm font-bold hover-premium ultra-smooth">
                    üîç Advanced Detection
                </span>
                <span class="px-5 py-2.5 rounded-full glass-multi-glow prism text-white text-sm font-bold hover-premium ultra-smooth">
                    ‚ö° Real-time Results
                </span>
                <span class="px-5 py-2.5 rounded-full glass-refract holographic text-white text-sm font-bold hover-premium ultra-smooth">
                    üõ°Ô∏è Deep Analysis
                </span>
            </div>
        </div>
    </div>

    <!-- Scan Form Card with Kinetic 3D Effects -->
    <div class="card-kinetic border-living ripple-container scroll-reveal">
        <div class="card-header glass-split-depth">
            <h3 class="card-title flex items-center gap-3">
                <div class="p-2 rounded-lg icon-holographic-shift">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6v6m0 0v6m0-6h6m-6 0H6"></path>
                    </svg>
                </div>
                Start New Scan
            </h3>
        </div>
        <div class="card-body">
            <div class="form-group">
                <label class="form-label flex items-center gap-2">
                    <svg class="w-4 h-4 text-primary-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 12a9 9 0 01-9 9m9-9a9 9 0 00-9-9m9 9H3m9 9a9 9 0 01-9-9m9 9c1.657 0 3-4.03 3-9s-1.343-9-3-9m0 18c-1.657 0-3-4.03-3-9s1.343-9 3-9m-9 9a9 9 0 019-9"></path>
                    </svg>
                    Target URL:
                </label>
                <input type="url" id="target-url" class="form-input glass-refract focus:border-living" placeholder="https://example.com or https://your-app.ngrok-free.app" required>
                <p class="text-sm text-gray-500 dark:text-gray-400 mt-1">
                    üí° <strong>Tip:</strong> You can scan ngrok URLs! If scanning a locally exposed server via ngrok, enter your public ngrok URL here 
                    (e.g., <code>https://abc123.ngrok-free.app</code>). 
                    See the <a href="https://github.com/tkstanch/Megido/blob/main/docs/NGROK_SCANNING_GUIDE.md" class="text-primary-600 dark:text-primary-400 hover:underline" target="_blank">ngrok scanning guide</a> for details.
                </p>
            </div>
            <div class="form-group">
                <label class="form-label flex items-center gap-2">
                    <svg class="w-4 h-4 text-primary-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 7h.01M7 3h5c.512 0 1.024.195 1.414.586l7 7a2 2 0 010 2.828l-7 7a2 2 0 01-2.828 0l-7-7A1.994 1.994 0 013 12V7a4 4 0 014-4z"></path>
                    </svg>
                    Scan Name (optional):
                </label>
                <input type="text" id="scan-name" class="form-input glass-refract focus:border-living" placeholder="My Security Scan">
            </div>
            <button class="btn btn-primary btn-ultra-premium ripple-container" id="start-scan-btn">
                <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 10V3L4 14h7v7l9-11h-7z"></path>
                </svg>
                Start Scan
            </button>
        </div>
    </div>

    <div id="scan-status"></div>

    <div id="exploit-actions-container"></div>

    <div id="scan-results">
    </div>
</div>
{% endblock %}

{% block extra_script %}
<script src="/static/js/scanner-dashboard.js"></script>
<script>
(function() {
    'use strict';
    
let currentScanId = null;
let currentVulnerabilities = [];
let currentTaskId = null;
let ws = null;
let wsConnected = false;
let pollingInterval = null;
let pollingRetries = 0;
let unknownStateRetries = 0;
const MAX_POLLING_RETRIES = 30; // Stop after 30 failed attempts (60 seconds)
const MAX_UNKNOWN_STATE_RETRIES = 5; // Stop after 5 consecutive unknown states
let useWebSocket = true;

// Attach event listener securely
document.addEventListener('DOMContentLoaded', function() {
    const startBtn = document.getElementById('start-scan-btn');
    if (startBtn) {
        startBtn.addEventListener('click', startScan);
    }
});

// Helper function to safely display error messages
function displayError(message) {
    const statusDiv = document.getElementById('scan-status');
    if (!statusDiv) return;
    
    // Use MegidoToast for better UX
    if (window.MegidoToast) {
        window.MegidoToast.error(message);
    }
    
    statusDiv.textContent = '';
    const errorCard = document.createElement('div');
    errorCard.className = 'card border-l-4 border-danger';
    
    const cardBody = document.createElement('div');
    cardBody.className = 'card-body';
    
    const errorText = document.createElement('p');
    errorText.className = 'text-danger';
    errorText.textContent = 'Error: ' + message;
    
    cardBody.appendChild(errorText);
    errorCard.appendChild(cardBody);
    statusDiv.appendChild(errorCard);
}

// Helper function to escape HTML to prevent XSS
function escapeHtml(text) {
    if (window.MegidoUtils && window.MegidoUtils.Security) {
        return window.MegidoUtils.Security.escapeHtml(text);
    }
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
}

// Helper function to validate severity values (only allow known values)
function sanitizeSeverity(severity) {
    if (window.MegidoUtils && window.MegidoUtils.Security) {
        return window.MegidoUtils.Security.validateSeverity(severity);
    }
    const validSeverities = ['low', 'medium', 'high', 'critical'];
    return validSeverities.includes(severity) ? severity : 'low';
}

// Extract CSRF token from browser cookies for API requests
function getCsrfToken() {
    if (window.MegidoUtils && window.MegidoUtils.Security) {
        return window.MegidoUtils.Security.getCsrfToken();
    }
    return getCsrfTokenFromCookies('csrftoken');
}

// Extract CSRF token from browser cookies for API requests
function getCsrfTokenFromCookies(tokenName) {
    const allCookies = document.cookie;
    if (!allCookies || allCookies.length === 0) {
        return null;
    }
    
    const cookiePairs = allCookies.split(';');
    for (let i = 0; i < cookiePairs.length; i++) {
        const cookiePair = cookiePairs[i].trim();
        const separatorIndex = cookiePair.indexOf('=');
        if (separatorIndex > 0) {
            const key = cookiePair.substring(0, separatorIndex);
            if (key === tokenName) {
                const encodedValue = cookiePair.substring(separatorIndex + 1);
                return decodeURIComponent(encodedValue);
            }
        }
    }
    return null;
}

async function startScan() {
    const urlInput = document.getElementById('target-url');
    const nameInput = document.getElementById('scan-name');
    
    if (!urlInput) return;
    
    const url = urlInput.value.trim();
    const name = nameInput ? nameInput.value.trim() : '';
    
    if (!url) {
        if (window.MegidoToast) {
            window.MegidoToast.warning('Please enter a target URL');
        } else {
            alert('Please enter a target URL');
        }
        return;
    }
    
    const csrfToken = getCsrfToken();
    
    try {
        // Show loading status
        if (window.MegidoToast) {
            window.MegidoToast.info('Starting scan...', { duration: 3000 });
        }
        
        // Create target with authentication
        const targetResponse = await fetch('/scanner/api/targets/', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': csrfToken
            },
            credentials: 'same-origin',
            body: JSON.stringify({url, name})
        });
        
        // Check response status before parsing JSON
        if (!targetResponse.ok) {
            const errorText = await targetResponse.text();
            throw new Error(`Failed to create target: ${targetResponse.status} - ${errorText}`);
        }
        
        const target = await targetResponse.json();
        
        // Display starting message safely
        const statusDiv = document.getElementById('scan-status');
        if (statusDiv) {
            statusDiv.textContent = '';
            const statusCard = document.createElement('div');
            statusCard.className = 'card border-l-4 border-info';
            
            const cardBody = document.createElement('div');
            cardBody.className = 'card-body';
            
            const statusText = document.createElement('p');
            statusText.className = 'text-info';
            statusText.textContent = 'Starting scan...';
            
            cardBody.appendChild(statusText);
            statusCard.appendChild(cardBody);
            statusDiv.appendChild(statusCard);
        }
        
        // Start scan with authentication
        const scanResponse = await fetch(`/scanner/api/targets/${target.id}/scan/`, {
            method: 'POST',
            headers: {
                'X-CSRFToken': csrfToken
            },
            credentials: 'same-origin'
        });
        
        // Check response status before parsing JSON
        if (!scanResponse.ok) {
            const errorText = await scanResponse.text();
            throw new Error(`Failed to start scan: ${scanResponse.status} - ${errorText}`);
        }
        
        const scan = await scanResponse.json();
        currentScanId = scan.id;
        
        // Start polling for scan results using the ScannerDashboard API
        if (window.ScannerDashboard) {
            window.ScannerDashboard.startPolling(
                scan.id,
                handleScanProgress,
                handleScanComplete,
                handleScanError
            );
        } else {
            // Fallback if polling API not loaded
            setTimeout(() => loadResults(scan.id), 2000);
        }
        
    } catch (error) {
        displayError(error.message);
    }
}

// Handle scan progress updates
function handleScanProgress(data) {
    const statusDiv = document.getElementById('scan-status');
    if (!statusDiv) return;
    
    const vulnCount = data.vulnerabilities ? data.vulnerabilities.length : 0;
    statusDiv.innerHTML = `
        <div class="card border-l-4 border-info">
            <div class="card-body">
                <div class="flex items-center gap-3">
                    <div class="animate-spin rounded-full h-6 w-6 border-b-2 border-info"></div>
                    <div>
                        <strong>Scan Status:</strong> ${escapeHtml(data.status)} | 
                        <strong>Vulnerabilities Found:</strong> ${escapeHtml(String(vulnCount))}
                    </div>
                </div>
            </div>
        </div>
    `;
}

// Handle scan completion
function handleScanComplete(data) {
    currentVulnerabilities = data.vulnerabilities;
    
    const statusDiv = document.getElementById('scan-status');
    const vulnCount = data.vulnerabilities ? data.vulnerabilities.length : 0;
    
    if (statusDiv) {
        statusDiv.innerHTML = `
            <div class="card border-l-4 border-success">
                <div class="card-body">
                    <strong>‚úì Scan Completed!</strong> | 
                    <strong>Vulnerabilities Found:</strong> ${escapeHtml(String(vulnCount))}
                </div>
            </div>
        `;
    }
    
    // Show success toast
    if (window.MegidoToast) {
        window.MegidoToast.success(`Scan completed! Found ${escapeHtml(String(vulnCount))} vulnerabilities.`);
    }
    
    // Show exploit actions if vulnerabilities found
    if (vulnCount > 0) {
        showExploitActions();
    }
    
    displayVulnerabilities(data.vulnerabilities);
}

// Handle scan errors
function handleScanError(message) {
    displayError(message);
}

// Fallback function for backward compatibility
async function loadResults(scanId) {
    try {
        const response = await fetch(`/scanner/api/scans/${scanId}/results/`);
        
        // Check response status before parsing JSON
        if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`Failed to load results: ${response.status} - ${errorText}`);
        }
        
        const data = await response.json();
        
        // Check if scan is complete
        if (data.status === 'completed') {
            handleScanComplete(data);
        } else if (data.status === 'failed') {
            handleScanError('Scan failed. Please try again.');
        } else {
            // Still running, poll again
            setTimeout(() => loadResults(scanId), 2000);
            handleScanProgress(data);
        }
        
    } catch (error) {
        displayError(error.message);
        console.error('Error loading results:', error);
    }
}

function showExploitActions() {
    const container = document.getElementById('exploit-actions-container');
    if (!container) return;
    
    container.innerHTML = '';
    
    const actionsCard = document.createElement('div');
    actionsCard.className = 'card';
    
    const cardHeader = document.createElement('div');
    cardHeader.className = 'card-header';
    const headerTitle = document.createElement('h3');
    headerTitle.className = 'card-title';
    headerTitle.textContent = 'Exploit Actions';
    cardHeader.appendChild(headerTitle);
    
    const cardBody = document.createElement('div');
    cardBody.className = 'card-body';
    
    const description = document.createElement('p');
    description.className = 'mb-4';
    description.textContent = 'Choose how to proceed with discovered vulnerabilities:';
    cardBody.appendChild(description);
    
    const buttonContainer = document.createElement('div');
    buttonContainer.className = 'flex flex-wrap gap-3';
    
    const exploitAllBtn = document.createElement('button');
    exploitAllBtn.className = 'btn btn-primary';
    exploitAllBtn.textContent = 'Exploit All Compatible Vulnerabilities';
    exploitAllBtn.addEventListener('click', exploitAll);
    
    const selectBtn = document.createElement('button');
    selectBtn.className = 'btn btn-secondary';
    selectBtn.textContent = 'Select Vulnerabilities to Exploit';
    selectBtn.addEventListener('click', showSelectMode);
    
    const skipBtn = document.createElement('button');
    skipBtn.className = 'btn btn-danger';
    skipBtn.textContent = 'Skip Exploitation';
    skipBtn.addEventListener('click', skipExploitation);
    
    buttonContainer.appendChild(exploitAllBtn);
    buttonContainer.appendChild(selectBtn);
    buttonContainer.appendChild(skipBtn);
    cardBody.appendChild(buttonContainer);
    
    actionsCard.appendChild(cardHeader);
    actionsCard.appendChild(cardBody);
    container.appendChild(actionsCard);
}

function displayVulnerabilities(vulnerabilities) {
    const resultsDiv = document.getElementById('scan-results');
    
    if (vulnerabilities.length === 0) {
        resultsDiv.innerHTML = '<div class="card border-l-4 border-info"><div class="card-body"><p>No vulnerabilities found.</p></div></div>';
        return;
    }
    
    resultsDiv.innerHTML = '<h3 class="text-xl font-semibold text-gray-900 dark:text-white mb-4">Vulnerabilities Detected:</h3>' + vulnerabilities.map(vuln => `
        <div class="card border-l-4 border-severity-${sanitizeSeverity(vuln.severity)} mb-4 hover:shadow-card-hover transition-shadow" id="vuln-${vuln.id}">
            <div class="card-body">
                <div class="flex items-start gap-3">
                    <input type="checkbox" class="vuln-checkbox mt-1" id="checkbox-${vuln.id}" value="${vuln.id}" style="display:none;">
                    <div class="flex-1">
                        <div class="flex items-center gap-2 mb-2 flex-wrap">
                            <strong class="text-gray-900 dark:text-white">${escapeHtml(vuln.type)}</strong>
                            <span class="badge badge-${sanitizeSeverity(vuln.severity)}">${escapeHtml(vuln.severity.toUpperCase())}</span>
                            ${vuln.verified ? 
                                `<span class="badge badge-success" title="Verified through exploitation">
                                    <svg class="w-3 h-3 inline mr-1" fill="currentColor" viewBox="0 0 20 20">
                                        <path fill-rule="evenodd" d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z" clip-rule="evenodd"></path>
                                    </svg>VERIFIED
                                </span>` : ''}
                            ${vuln.risk_score ? 
                                `<span class="badge ${getRiskBadgeClass(vuln.risk_score)}" title="Risk Score: ${vuln.risk_score.toFixed(1)}/100">
                                    Risk: ${vuln.risk_level ? vuln.risk_level.toUpperCase() : 'N/A'}
                                </span>` : ''}
                            ${vuln.exploit_status !== 'not_attempted' ? 
                                `<span class="badge ${getExploitStatusClass(vuln.exploit_status)}">${formatExploitStatus(vuln.exploit_status)}</span>` : ''}
                            ${vuln.confidence_score ? 
                                `<span class="badge badge-gray" title="Confidence in finding">
                                    Confidence: ${Math.round(vuln.confidence_score * 100)}%
                                </span>` : ''}
                        </div>
                        <div class="space-y-2 text-sm">
                            <div><strong class="text-gray-700 dark:text-gray-300">URL:</strong> <span class="text-gray-600 dark:text-gray-400">${escapeHtml(vuln.url)}</span></div>
                            <div><strong class="text-gray-700 dark:text-gray-300">Description:</strong> <span class="text-gray-600 dark:text-gray-400">${escapeHtml(vuln.description)}</span></div>
                            ${vuln.evidence ? `<div><strong class="text-gray-700 dark:text-gray-300">Evidence:</strong> <span class="text-gray-600 dark:text-gray-400">${escapeHtml(vuln.evidence)}</span></div>` : ''}
                            ${vuln.verified && vuln.proof_of_impact ? `
                                <div class="mt-3 p-4 bg-green-50 dark:bg-green-900/20 border-l-4 border-green-500 rounded">
                                    <div class="flex items-start gap-2">
                                        <svg class="w-5 h-5 text-green-600 dark:text-green-400 mt-0.5" fill="currentColor" viewBox="0 0 20 20">
                                            <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clip-rule="evenodd"></path>
                                        </svg>
                                        <div class="flex-1">
                                            <strong class="text-green-800 dark:text-green-300">‚úì Proof of Impact (Verified Vulnerability)</strong>
                                            <pre class="mt-2 text-xs text-green-700 dark:text-green-400 whitespace-pre-wrap">${escapeHtml(vuln.proof_of_impact)}</pre>
                                        </div>
                                    </div>
                                </div>
                            ` : ''}
                            ${vuln.visual_proof_path ? `
                                <div class="mt-3 p-4 bg-purple-50 dark:bg-purple-900/20 border-l-4 border-purple-500 rounded">
                                    <div class="flex items-start gap-2">
                                        <svg class="w-5 h-5 text-purple-600 dark:text-purple-400 mt-0.5" fill="currentColor" viewBox="0 0 20 20">
                                            <path fill-rule="evenodd" d="M4 3a2 2 0 00-2 2v10a2 2 0 002 2h12a2 2 0 002-2V5a2 2 0 00-2-2H4zm12 12H4l4-8 3 6 2-4 3 6z" clip-rule="evenodd"></path>
                                        </svg>
                                        <div class="flex-1">
                                            <strong class="text-purple-800 dark:text-purple-300">üì∏ Visual Proof of Exploitation</strong>
                                            <div class="mt-2 text-xs text-purple-700 dark:text-purple-400">
                                                Type: <span class="font-semibold">${vuln.visual_proof_type || 'screenshot'}</span> ‚Ä¢ 
                                                Size: <span class="font-semibold">${formatFileSize(vuln.visual_proof_size)}</span>
                                            </div>
                                            <div class="mt-3 cursor-pointer" onclick="showVisualProof('/${vuln.visual_proof_path}', '${vuln.visual_proof_type}', ${vuln.id})">
                                                ${vuln.visual_proof_type === 'gif' ? `
                                                    <img src="/${vuln.visual_proof_path}" 
                                                         alt="Exploitation proof GIF" 
                                                         class="rounded border-2 border-purple-300 dark:border-purple-600 hover:border-purple-500 transition-all max-w-full h-auto shadow-lg"
                                                         style="max-height: 400px;">
                                                    <div class="text-xs text-purple-600 dark:text-purple-400 mt-2 text-center">
                                                        üé¨ Click to view in fullscreen
                                                    </div>
                                                ` : `
                                                    <img src="/${vuln.visual_proof_path}" 
                                                         alt="Exploitation proof screenshot" 
                                                         class="rounded border-2 border-purple-300 dark:border-purple-600 hover:border-purple-500 transition-all max-w-full h-auto shadow-lg"
                                                         style="max-height: 400px;">
                                                    <div class="text-xs text-purple-600 dark:text-purple-400 mt-2 text-center">
                                                        üîç Click to view in fullscreen
                                                    </div>
                                                `}
                                            </div>
                                            <div class="mt-2">
                                                <a href="/${vuln.visual_proof_path}" 
                                                   download 
                                                   class="inline-flex items-center px-3 py-1 text-xs font-medium rounded-md text-purple-700 bg-purple-100 hover:bg-purple-200 dark:bg-purple-800 dark:text-purple-200 dark:hover:bg-purple-700 transition-colors">
                                                    <svg class="w-4 h-4 mr-1" fill="currentColor" viewBox="0 0 20 20">
                                                        <path fill-rule="evenodd" d="M3 17a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zm3.293-7.707a1 1 0 011.414 0L9 10.586V3a1 1 0 112 0v7.586l1.293-1.293a1 1 0 111.414 1.414l-3 3a1 1 0 01-1.414 0l-3-3a1 1 0 010-1.414z" clip-rule="evenodd"></path>
                                                    </svg>
                                                    Download Proof
                                                </a>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            ` : ''}
                            ${vuln.exploit_result ? `<div class="mt-3 p-4 bg-gray-100 dark:bg-gray-700 rounded-lg">
                                <strong class="text-gray-900 dark:text-white">Exploit Results:</strong>
                                <pre class="mt-2 text-xs text-gray-700 dark:text-gray-300 whitespace-pre-wrap">${escapeHtml(vuln.exploit_result)}</pre>
                            </div>` : ''}
                            ${vuln.remediation ? `<div class="mt-3"><strong class="text-gray-700 dark:text-gray-300">Remediation:</strong> <span class="text-gray-600 dark:text-gray-400">${escapeHtml(vuln.remediation)}</span></div>` : ''}
                            ${vuln.compliance_violations && Object.keys(vuln.compliance_violations).length > 0 ? `
                                <div class="mt-3 p-3 bg-blue-50 dark:bg-blue-900/20 border-l-4 border-blue-500 rounded">
                                    <strong class="text-blue-800 dark:text-blue-300">Compliance Violations:</strong>
                                    <div class="mt-1 flex flex-wrap gap-1">
                                        ${Object.keys(vuln.compliance_violations).map(framework => 
                                            `<span class="badge badge-info text-xs">${escapeHtml(framework.toUpperCase())}</span>`
                                        ).join('')}
                                    </div>
                                </div>
                            ` : ''}
                        </div>
                    </div>
                </div>
            </div>
        </div>
    `).join('');
}

function getExploitStatusClass(status) {
    const statusClasses = {
        'success': 'badge-success',
        'failed': 'badge-danger',
        'no_plugin': 'badge-gray',
        'not_attempted': 'badge-gray',
        'in_progress': 'badge-warning'
    };
    return statusClasses[status] || 'badge-gray';
}

function getRiskBadgeClass(riskScore) {
    if (riskScore >= 80) return 'badge-danger';
    if (riskScore >= 60) return 'badge-warning';
    if (riskScore >= 40) return 'badge-info';
    return 'badge-success';
}

function formatExploitStatus(status) {
    const statusMap = {
        'not_attempted': 'Not Attempted',
        'in_progress': 'In Progress',
        'success': 'Successfully Exploited',
        'failed': 'Exploitation Failed',
        'no_plugin': 'No Plugin Available'
    };
    return statusMap[status] || status;
}

// ============================================================================
// WebSocket Connection Management
// ============================================================================

function connectWebSocket(taskId) {
    if (!useWebSocket) {
        console.log('WebSocket disabled, using polling fallback');
        return;
    }
    
    // Close existing connection if any
    closeWebSocket();
    
    // Determine WebSocket protocol based on page protocol
    const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
    const wsUrl = `${protocol}//${window.location.host}/ws/scanner/task/${taskId}/`;
    
    console.log(`Attempting WebSocket connection to: ${wsUrl}`);
    
    try {
        ws = new WebSocket(wsUrl);
        
        ws.onopen = function(event) {
            console.log('WebSocket connected successfully');
            wsConnected = true;
            
            // Stop polling if it was running
            if (pollingInterval) {
                clearInterval(pollingInterval);
                pollingInterval = null;
            }
        };
        
        ws.onmessage = function(event) {
            try {
                const data = JSON.parse(event.data);
                console.log('WebSocket message received:', data);
                handleWebSocketUpdate(data);
            } catch (error) {
                console.error('Error parsing WebSocket message:', error);
            }
        };
        
        ws.onerror = function(error) {
            console.error('WebSocket error:', error);
            fallbackToPolling(taskId);
        };
        
        ws.onclose = function(event) {
            console.log('WebSocket closed:', event.code, event.reason);
            wsConnected = false;
            ws = null;
            
            // If task is still in progress, fallback to polling
            if (currentTaskId) {
                fallbackToPolling(taskId);
            }
        };
        
    } catch (error) {
        console.error('WebSocket connection failed:', error);
        fallbackToPolling(taskId);
    }
}

function closeWebSocket() {
    if (ws) {
        try {
            ws.close();
        } catch (error) {
            console.error('Error closing WebSocket:', error);
        }
        ws = null;
        wsConnected = false;
    }
}

function handleWebSocketUpdate(data) {
    const updateType = data.update_type;
    
    if (updateType === 'connection') {
        console.log('WebSocket connection confirmed');
        return;
    }
    
    if (updateType === 'progress') {
        updateProgressDisplay(data);
    } else if (updateType === 'success') {
        handleExploitationComplete(data.result);
        closeWebSocket();
    } else if (updateType === 'failure') {
        displayError(data.error || 'Exploitation failed');
        enableExploitButtons();
        closeWebSocket();
    }
}

function updateProgressDisplay(data) {
    const statusDiv = document.getElementById('scan-status');
    statusDiv.innerHTML = `
        <div class="card border-l-4 border-info">
            <div class="card-body">
                <strong class="text-info">Exploitation in progress...</strong><br>
                Processing vulnerability ${data.current}/${data.total} (${data.percent}%)
                ${data.status ? '<br>' + escapeHtml(data.status) : ''}
            </div>
        </div>
    `;
}

function fallbackToPolling(taskId) {
    if (!useWebSocket) return;  // Already using polling
    
    console.log('Falling back to polling for task status');
    useWebSocket = false;
    
    // Start polling if not already running
    if (!pollingInterval && taskId) {
        startPolling(taskId);
    }
}

function startPolling(taskId) {
    console.log('Starting polling for task:', taskId);
    
    // Reset retry counters when starting a new polling session
    pollingRetries = 0;
    unknownStateRetries = 0;
    
    // Clear any existing interval
    if (pollingInterval) {
        clearInterval(pollingInterval);
    }
    
    // Poll every 2 seconds
    pollingInterval = setInterval(async () => {
        try {
            await pollTaskStatus(taskId);
        } catch (error) {
            console.error('Polling error:', error);
        }
    }, 2000);
    
    // Do an immediate poll
    pollTaskStatus(taskId);
}

async function pollTaskStatus(taskId) {
    try {
        const csrfToken = getCsrfTokenFromCookies('csrftoken');
        const response = await fetch(`/scanner/api/exploit_status/${taskId}/`, {
            headers: {
                'X-CSRFToken': csrfToken
            },
            credentials: 'same-origin'
        });
        
        if (!response.ok) {
            throw new Error(`Failed to fetch status: ${response.status}`);
        }
        
        const data = await response.json();
        
        // Reset network error counter on successful response
        pollingRetries = 0;
        
        if (data.state === 'PROGRESS') {
            // Reset unknown state counter on valid state
            unknownStateRetries = 0;
            updateProgressDisplay({
                current: data.current || 0,
                total: data.total || 0,
                percent: data.total > 0 ? Math.floor((data.current / data.total) * 100) : 0,
                status: data.status
            });
        } else if (data.state === 'SUCCESS') {
            // Reset unknown state counter on valid state
            unknownStateRetries = 0;
            if (pollingInterval) {
                clearInterval(pollingInterval);
                pollingInterval = null;
            }
            handleExploitationComplete(data.result);
        } else if (data.state === 'FAILURE') {
            // Reset unknown state counter on valid state
            unknownStateRetries = 0;
            if (pollingInterval) {
                clearInterval(pollingInterval);
                pollingInterval = null;
            }
            displayError(data.error || 'Exploitation failed');
            enableExploitButtons();
        } else if (data.state === 'PENDING') {
            // Reset unknown state counter on valid state
            unknownStateRetries = 0;
            console.log('Task is pending...');
        } else {
            // Unknown state - stop polling after consecutive unknown states
            console.warn('Unknown task state:', data.state);
            unknownStateRetries++;
            if (unknownStateRetries >= MAX_UNKNOWN_STATE_RETRIES) {
                if (pollingInterval) {
                    clearInterval(pollingInterval);
                    pollingInterval = null;
                }
                displayError('Task entered unknown state. Please check the results manually.');
                enableExploitButtons();
            }
        }
    } catch (error) {
        console.error('Error polling task status:', error);
        pollingRetries++;
        
        // Stop polling after max retries to prevent infinite requests
        if (pollingRetries >= MAX_POLLING_RETRIES) {
            if (pollingInterval) {
                clearInterval(pollingInterval);
                pollingInterval = null;
            }
            displayError('Unable to fetch task status after multiple attempts. Please refresh the page to check if the task completed.');
            enableExploitButtons();
        }
    }
}

function handleExploitationComplete(results) {
    currentTaskId = null;
    showExploitResults(results);
    
    // Reload vulnerabilities to show updated status
    if (currentScanId) {
        loadResults(currentScanId);
    }
}

// ============================================================================
// End WebSocket Code
// ============================================================================

async function exploitAll() {
    if (!currentScanId) {
        alert('No scan selected');
        return;
    }
    
    if (!confirm('This will attempt to exploit ALL discovered vulnerabilities. Continue?')) {
        return;
    }
    
    const csrfToken = getCsrfTokenFromCookies('csrftoken');
    
    try {
        // Disable buttons during exploitation
        disableExploitButtons();
        
        document.getElementById('scan-status').innerHTML = `
            <div class="card border-l-4 border-info">
                <div class="card-body">
                    <strong class="text-info">Starting exploitation...</strong> Please wait.
                </div>
            </div>
        `;
        
        const response = await fetch(`/scanner/api/scans/${currentScanId}/exploit/`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': csrfToken
            },
            credentials: 'same-origin',
            body: JSON.stringify({action: 'all'})
        });
        
        if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`Exploitation failed: ${response.status} - ${errorText}`);
        }
        
        const data = await response.json();
        currentTaskId = data.task_id;
        
        // Connect to WebSocket for real-time updates
        connectWebSocket(currentTaskId);
        
        // If WebSocket connection fails, fallback to polling after 1 second
        setTimeout(() => {
            if (!wsConnected) {
                fallbackToPolling(currentTaskId);
            }
        }, 1000);
        
    } catch (error) {
        displayError(error.message);
        enableExploitButtons();
    }
}

function showSelectMode() {
    // Show checkboxes for all vulnerabilities
    document.querySelectorAll('.vuln-checkbox').forEach(checkbox => {
        checkbox.style.display = 'inline-block';
    });
    
    // Update exploit actions to show selection buttons
    const container = document.getElementById('exploit-actions-container');
    if (!container) return;
    
    container.innerHTML = '';
    
    const actionsCard = document.createElement('div');
    actionsCard.className = 'card';
    
    const cardHeader = document.createElement('div');
    cardHeader.className = 'card-header';
    const headerTitle = document.createElement('h3');
    headerTitle.className = 'card-title';
    headerTitle.textContent = 'Select Vulnerabilities to Exploit';
    cardHeader.appendChild(headerTitle);
    
    const cardBody = document.createElement('div');
    cardBody.className = 'card-body';
    
    const description = document.createElement('p');
    description.className = 'mb-4';
    description.textContent = 'Check the vulnerabilities you want to exploit:';
    cardBody.appendChild(description);
    
    const buttonContainer = document.createElement('div');
    buttonContainer.className = 'flex flex-wrap gap-3';
    
    const exploitBtn = document.createElement('button');
    exploitBtn.className = 'btn btn-primary';
    exploitBtn.textContent = 'Exploit Selected';
    exploitBtn.addEventListener('click', exploitSelected);
    
    const cancelBtn = document.createElement('button');
    cancelBtn.className = 'btn btn-secondary';
    cancelBtn.textContent = 'Cancel Selection';
    cancelBtn.addEventListener('click', cancelSelection);
    
    buttonContainer.appendChild(exploitBtn);
    buttonContainer.appendChild(cancelBtn);
    cardBody.appendChild(buttonContainer);
    
    actionsCard.appendChild(cardHeader);
    actionsCard.appendChild(cardBody);
    container.appendChild(actionsCard);
}

async function exploitSelected() {
    const selectedIds = Array.from(document.querySelectorAll('.vuln-checkbox:checked'))
        .map(cb => parseInt(cb.value));
    
    if (selectedIds.length === 0) {
        alert('Please select at least one vulnerability to exploit');
        return;
    }
    
    if (!confirm(`This will attempt to exploit ${selectedIds.length} selected vulnerability(ies). Continue?`)) {
        return;
    }
    
    const csrfToken = getCsrfTokenFromCookies('csrftoken');
    
    try {
        disableExploitButtons();
        
        document.getElementById('scan-status').innerHTML = `
            <div class="card border-l-4 border-info">
                <div class="card-body">
                    <strong class="text-info">Starting exploitation...</strong> Processing ${selectedIds.length} vulnerability(ies).
                </div>
            </div>
        `;
        
        const response = await fetch(`/scanner/api/scans/${currentScanId}/exploit/`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': csrfToken
            },
            credentials: 'same-origin',
            body: JSON.stringify({
                action: 'selected',
                vulnerability_ids: selectedIds
            })
        });
        
        if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`Exploitation failed: ${response.status} - ${errorText}`);
        }
        
        const data = await response.json();
        currentTaskId = data.task_id;
        
        // Connect to WebSocket for real-time updates
        connectWebSocket(currentTaskId);
        
        // If WebSocket connection fails, fallback to polling after 1 second
        setTimeout(() => {
            if (!wsConnected) {
                fallbackToPolling(currentTaskId);
            }
        }, 1000);
        
    } catch (error) {
        displayError(error.message);
        enableExploitButtons();
    }
}

function cancelSelection() {
    // Hide checkboxes
    document.querySelectorAll('.vuln-checkbox').forEach(checkbox => {
        checkbox.style.display = 'none';
        checkbox.checked = false;
    });
    
    // Restore original exploit actions
    showExploitActions();
}

function skipExploitation() {
    const container = document.getElementById('exploit-actions-container');
    if (!container) return;
    
    container.innerHTML = '';
    
    const infoCard = document.createElement('div');
    infoCard.className = 'card border-l-4 border-info';
    
    const cardBody = document.createElement('div');
    cardBody.className = 'card-body';
    
    const infoText = document.createElement('p');
    infoText.textContent = 'Exploitation skipped. Showing scan results only.';
    
    cardBody.appendChild(infoText);
    infoCard.appendChild(cardBody);
    container.appendChild(infoCard);
    
    if (window.MegidoToast) {
        window.MegidoToast.info('Exploitation skipped');
    }
}

function showExploitResults(results) {
    const statusDiv = document.getElementById('scan-status');
    statusDiv.innerHTML = `
        <div class="card">
            <div class="card-header">
                <h3 class="card-title">Exploitation Results</h3>
            </div>
            <div class="card-body">
                <div class="space-y-2">
                    <p><strong>Total vulnerabilities:</strong> ${results.total}</p>
                    <p><strong>Successfully exploited:</strong> <span class="text-success">${results.exploited}</span></p>
                    <p><strong>Failed:</strong> <span class="text-danger">${results.failed}</span></p>
                    <p><strong>No plugin available:</strong> <span class="text-gray-600 dark:text-gray-400">${results.no_plugin}</span></p>
                </div>
            </div>
        </div>
    `;
}

function disableExploitButtons() {
    document.querySelectorAll('#exploit-actions-container button').forEach(btn => {
        btn.disabled = true;
    });
}

function enableExploitButtons() {
    document.querySelectorAll('#exploit-actions-container button').forEach(btn => {
        btn.disabled = false;
    });
}

// Helper function to format file size
function formatFileSize(bytes) {
    if (!bytes || bytes === 0) return 'N/A';
    if (bytes < 1024) return bytes + ' B';
    if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
    return (bytes / (1024 * 1024)).toFixed(1) + ' MB';
}

// Visual proof viewer functions
function showVisualProof(path, type, vulnId) {
    // Create modal overlay
    const modal = document.createElement('div');
    modal.id = 'visual-proof-modal';
    modal.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.9);
        z-index: 9999;
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 20px;
    `;
    
    // Create content container
    const content = document.createElement('div');
    content.style.cssText = `
        max-width: 90vw;
        max-height: 90vh;
        position: relative;
        display: flex;
        flex-direction: column;
        align-items: center;
    `;
    
    // Create close button
    const closeBtn = document.createElement('button');
    closeBtn.innerHTML = '‚úï';
    closeBtn.style.cssText = `
        position: absolute;
        top: -40px;
        right: 0;
        background: #fff;
        border: none;
        border-radius: 50%;
        width: 32px;
        height: 32px;
        font-size: 20px;
        cursor: pointer;
        z-index: 10000;
        box-shadow: 0 2px 8px rgba(0,0,0,0.3);
    `;
    closeBtn.onclick = () => document.body.removeChild(modal);
    
    // Create image element
    const img = document.createElement('img');
    img.src = path;
    img.alt = `Visual proof for vulnerability ${vulnId}`;
    img.style.cssText = `
        max-width: 100%;
        max-height: 90vh;
        border-radius: 8px;
        box-shadow: 0 4px 20px rgba(0,0,0,0.5);
    `;
    
    // Add download link
    const downloadLink = document.createElement('a');
    downloadLink.href = path;
    downloadLink.download = `proof_vuln_${vulnId}.${type === 'gif' ? 'gif' : 'png'}`;
    downloadLink.style.cssText = `
        margin-top: 15px;
        padding: 8px 16px;
        background: #8b5cf6;
        color: white;
        text-decoration: none;
        border-radius: 6px;
        font-size: 14px;
        display: inline-flex;
        align-items: center;
        gap: 6px;
    `;
    downloadLink.innerHTML = `
        <svg class="w-4 h-4" fill="currentColor" viewBox="0 0 20 20">
            <path fill-rule="evenodd" d="M3 17a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zm3.293-7.707a1 1 0 011.414 0L9 10.586V3a1 1 0 112 0v7.586l1.293-1.293a1 1 0 111.414 1.414l-3 3a1 1 0 01-1.414 0l-3-3a1 1 0 010-1.414z" clip-rule="evenodd"></path>
        </svg>
        Download ${type === 'gif' ? 'GIF' : 'Screenshot'}
    `;
    
    content.appendChild(closeBtn);
    content.appendChild(img);
    content.appendChild(downloadLink);
    modal.appendChild(content);
    
    // Close on background click
    modal.onclick = (e) => {
        if (e.target === modal) {
            document.body.removeChild(modal);
        }
    };
    
    // Close on ESC key
    const handleEsc = (e) => {
        if (e.key === 'Escape') {
            document.body.removeChild(modal);
            document.removeEventListener('keydown', handleEsc);
        }
    };
    document.addEventListener('keydown', handleEsc);
    
    document.body.appendChild(modal);
}

})(); // End IIFE
</script>
{% endblock %}
