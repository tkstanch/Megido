{% extends 'base.html' %}

{% block title %}Vulnerability Scanner - Megido Security{% endblock %}

{% block breadcrumb %}
<span class="breadcrumb-item">Megido Security</span>
<span class="breadcrumb-separator">â€º</span>
<span class="breadcrumb-item active">Scanner</span>
{% endblock %}

{% block extra_style %}
.page-header {
    margin-bottom: 2rem;
}

.page-title {
    font-size: 1.875rem;
    font-weight: 700;
    margin-bottom: 0.5rem;
}

.page-description {
    font-size: 1.0625rem;
    color: var(--text-secondary);
}

.scan-form {
    background: var(--surface);
    padding: 1.5rem;
    border-radius: var(--border-radius-lg);
    border: 1px solid var(--border-light);
    margin-bottom: 1.5rem;
}
.scan-results {
    margin-top: 1.5rem;
}

.vulnerability {
    background: var(--surface);
    border: 1px solid var(--border-light);
    border-radius: var(--border-radius-lg);
    padding: 1.25rem;
    margin-bottom: 1rem;
    transition: all var(--transition-fast);
}

.vulnerability:hover {
    box-shadow: var(--shadow-md);
}

.severity-critical { 
    border-left: 4px solid var(--severity-critical); 
}

.severity-high { 
    border-left: 4px solid var(--severity-high); 
}

.severity-medium { 
    border-left: 4px solid var(--severity-medium); 
}

.severity-low { 
    border-left: 4px solid var(--severity-low); 
}
.exploit-actions {
    background: var(--bg-tertiary);
    padding: 1.25rem;
    border-radius: var(--border-radius-lg);
    margin-bottom: 1.5rem;
}

.exploit-results {
    background: var(--bg-tertiary);
    padding: 1.25rem;
    border-radius: var(--border-radius-lg);
    margin-top: 1rem;
}

.exploit-status {
    display: inline-flex;
    align-items: center;
    padding: 0.25rem 0.625rem;
    border-radius: 9999px;
    font-size: 0.75rem;
    font-weight: 600;
}

.exploit-status-success { 
    background: var(--success); 
    color: var(--text-inverse); 
}

.exploit-status-failed { 
    background: var(--danger); 
    color: var(--text-inverse); 
}

.exploit-status-no_plugin { 
    background: var(--gray-500); 
    color: var(--text-inverse); 
}

.exploit-status-not_attempted { 
    background: var(--gray-200); 
    color: var(--text-primary); 
}

.exploit-status-in_progress { 
    background: var(--warning); 
    color: var(--text-primary); 
}
input[type="text"],
input[type="url"] {
    width: 100%;
    padding: 0.625rem 0.875rem;
    border: 1px solid var(--border-medium);
    border-radius: var(--border-radius-md);
    margin-bottom: 0.75rem;
    font-size: 0.9375rem;
    color: var(--text-primary);
    background-color: var(--surface);
    transition: all var(--transition-fast);
}

input[type="text"]:focus,
input[type="url"]:focus {
    outline: none;
    border-color: var(--primary-500);
    box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
}

button {
    padding: 0.625rem 1.25rem;
    font-size: 0.9375rem;
    font-weight: 500;
    border: none;
    border-radius: var(--border-radius-md);
    cursor: pointer;
    transition: all var(--transition-fast);
    display: inline-flex;
    align-items: center;
    justify-content: center;
    gap: 0.5rem;
}

button:not(.btn-secondary):not(.btn-danger) {
    background: var(--gradient-primary);
    color: var(--text-inverse);
}

button:hover:not(:disabled) {
    transform: translateY(-2px);
    box-shadow: var(--shadow-lg);
}

button:disabled {
    opacity: 0.6;
    cursor: not-allowed;
}

.btn-secondary {
    background: var(--gray-200);
    color: var(--text-primary);
}

.btn-secondary:hover:not(:disabled) {
    background: var(--gray-300);
}

.btn-danger {
    background: var(--gradient-danger);
    color: var(--text-inverse);
}
.vuln-checkbox {
    margin-right: 0.625rem;
    cursor: pointer;
}
{% endblock %}

{% block content %}
<div class="page-header">
    <h2 class="page-title">Vulnerability Scanner</h2>
    <p class="page-description">Automatically scan web applications for common security vulnerabilities.</p>
</div>

<div class="card">
    <div class="card-header">
        <h3 class="card-title">Start New Scan</h3>
    </div>
    <div class="card-body">
        <div class="form-group">
            <label class="form-label">Target URL:</label>
            <input type="url" id="target-url" class="form-input" placeholder="https://example.com" required>
        </div>
        <div class="form-group">
            <label class="form-label">Scan Name (optional):</label>
            <input type="text" id="scan-name" class="form-input" placeholder="My Security Scan">
        </div>
        <button class="btn btn-primary" id="start-scan-btn">
            ðŸš€ Start Scan
        </button>
    </div>
</div>

<div id="scan-status" class="mt-4"></div>

<div id="exploit-actions-container"></div>

<div class="scan-results" id="scan-results">
</div>
{% endblock %}

{% block extra_script %}
<script>
(function() {
    'use strict';
    
let currentScanId = null;
let currentVulnerabilities = [];
let currentTaskId = null;
let ws = null;
let wsConnected = false;
let pollingInterval = null;
let useWebSocket = true;

// Attach event listener securely
document.addEventListener('DOMContentLoaded', function() {
    const startBtn = document.getElementById('start-scan-btn');
    if (startBtn) {
        startBtn.addEventListener('click', startScan);
    }
});

// Helper function to safely display error messages
function displayError(message) {
    const statusDiv = document.getElementById('scan-status');
    if (!statusDiv) return;
    
    // Use MegidoToast for better UX
    if (window.MegidoToast) {
        window.MegidoToast.error(message);
    }
    
    statusDiv.textContent = '';
    const errorCard = document.createElement('div');
    errorCard.className = 'card';
    errorCard.style.borderLeft = '4px solid var(--danger)';
    
    const cardBody = document.createElement('div');
    cardBody.className = 'card-body';
    
    const errorText = document.createElement('p');
    errorText.style.color = 'var(--danger)';
    errorText.textContent = 'Error: ' + message;
    
    cardBody.appendChild(errorText);
    errorCard.appendChild(cardBody);
    statusDiv.appendChild(errorCard);
}

// Helper function to escape HTML to prevent XSS
function escapeHtml(text) {
    if (window.MegidoUtils && window.MegidoUtils.Security) {
        return window.MegidoUtils.Security.escapeHtml(text);
    }
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
}

// Helper function to validate severity values (only allow known values)
function sanitizeSeverity(severity) {
    if (window.MegidoUtils && window.MegidoUtils.Security) {
        return window.MegidoUtils.Security.validateSeverity(severity);
    }
    const validSeverities = ['low', 'medium', 'high', 'critical'];
    return validSeverities.includes(severity) ? severity : 'low';
}

// Extract CSRF token from browser cookies for API requests
function getCsrfToken() {
    if (window.MegidoUtils && window.MegidoUtils.Security) {
        return window.MegidoUtils.Security.getCsrfToken();
    }
    return getCsrfTokenFromCookies('csrftoken');
}

// Extract CSRF token from browser cookies for API requests
function getCsrfTokenFromCookies(tokenName) {
    const allCookies = document.cookie;
    if (!allCookies || allCookies.length === 0) {
        return null;
    }
    
    const cookiePairs = allCookies.split(';');
    for (let i = 0; i < cookiePairs.length; i++) {
        const cookiePair = cookiePairs[i].trim();
        const separatorIndex = cookiePair.indexOf('=');
        if (separatorIndex > 0) {
            const key = cookiePair.substring(0, separatorIndex);
            if (key === tokenName) {
                const encodedValue = cookiePair.substring(separatorIndex + 1);
                return decodeURIComponent(encodedValue);
            }
        }
    }
    return null;
}

async function startScan() {
    const urlInput = document.getElementById('target-url');
    const nameInput = document.getElementById('scan-name');
    
    if (!urlInput) return;
    
    const url = urlInput.value.trim();
    const name = nameInput ? nameInput.value.trim() : '';
    
    if (!url) {
        if (window.MegidoToast) {
            window.MegidoToast.warning('Please enter a target URL');
        } else {
            alert('Please enter a target URL');
        }
        return;
    }
    
    const csrfToken = getCsrfToken();
    
    try {
        // Show loading status
        if (window.MegidoToast) {
            window.MegidoToast.info('Starting scan...', { duration: 3000 });
        }
        
        // Create target with authentication
        const targetResponse = await fetch('/scanner/api/targets/', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': csrfToken
            },
            credentials: 'same-origin',
            body: JSON.stringify({url, name})
        });
        
        // Check response status before parsing JSON
        if (!targetResponse.ok) {
            const errorText = await targetResponse.text();
            throw new Error(`Failed to create target: ${targetResponse.status} - ${errorText}`);
        }
        
        const target = await targetResponse.json();
        
        // Display starting message safely
        const statusDiv = document.getElementById('scan-status');
        if (statusDiv) {
            statusDiv.textContent = '';
            const statusCard = document.createElement('div');
            statusCard.className = 'card';
            statusCard.style.borderLeft = '4px solid var(--info)';
            
            const cardBody = document.createElement('div');
            cardBody.className = 'card-body';
            
            const statusText = document.createElement('p');
            statusText.style.color = 'var(--info)';
            statusText.textContent = 'Starting scan...';
            
            cardBody.appendChild(statusText);
            statusCard.appendChild(cardBody);
            statusDiv.appendChild(statusCard);
        }
        
        // Start scan with authentication
        const scanResponse = await fetch(`/scanner/api/targets/${target.id}/scan/`, {
            method: 'POST',
            headers: {
                'X-CSRFToken': csrfToken
            },
            credentials: 'same-origin'
        });
        
        // Check response status before parsing JSON
        if (!scanResponse.ok) {
            const errorText = await scanResponse.text();
            throw new Error(`Failed to start scan: ${scanResponse.status} - ${errorText}`);
        }
        
        const scan = await scanResponse.json();
        currentScanId = scan.id;
        
        // Wait a moment then load results
        setTimeout(() => loadResults(scan.id), 2000);
        
    } catch (error) {
        displayError(error.message);
    }
}

async function loadResults(scanId) {
    try {
        const response = await fetch(`/scanner/api/scans/${scanId}/results/`);
        
        // Check response status before parsing JSON
        if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`Failed to load results: ${response.status} - ${errorText}`);
        }
        
        const data = await response.json();
        currentVulnerabilities = data.vulnerabilities;
        
        document.getElementById('scan-status').innerHTML = `
            <div class="info">
                <strong>Scan Status:</strong> ${data.status} | 
                <strong>Vulnerabilities Found:</strong> ${data.vulnerabilities.length}
            </div>
        `;
        
        // Show exploit actions if vulnerabilities found
        if (data.vulnerabilities.length > 0) {
            showExploitActions();
        }
        
        displayVulnerabilities(data.vulnerabilities);
        
    } catch (error) {
        displayError(error.message);
        console.error('Error loading results:', error);
    }
}

function showExploitActions() {
    const container = document.getElementById('exploit-actions-container');
    if (!container) return;
    
    container.innerHTML = '';
    
    const actionsCard = document.createElement('div');
    actionsCard.className = 'card';
    
    const cardHeader = document.createElement('div');
    cardHeader.className = 'card-header';
    const headerTitle = document.createElement('h3');
    headerTitle.className = 'card-title';
    headerTitle.textContent = 'Exploit Actions';
    cardHeader.appendChild(headerTitle);
    
    const cardBody = document.createElement('div');
    cardBody.className = 'card-body';
    
    const description = document.createElement('p');
    description.textContent = 'Choose how to proceed with discovered vulnerabilities:';
    cardBody.appendChild(description);
    
    const buttonContainer = document.createElement('div');
    buttonContainer.style.cssText = 'display: flex; gap: 0.75rem; flex-wrap: wrap;';
    
    const exploitAllBtn = document.createElement('button');
    exploitAllBtn.className = 'btn btn-primary';
    exploitAllBtn.textContent = 'Exploit All Compatible Vulnerabilities';
    exploitAllBtn.addEventListener('click', exploitAll);
    
    const selectBtn = document.createElement('button');
    selectBtn.className = 'btn btn-secondary';
    selectBtn.textContent = 'Select Vulnerabilities to Exploit';
    selectBtn.addEventListener('click', showSelectMode);
    
    const skipBtn = document.createElement('button');
    skipBtn.className = 'btn btn-danger';
    skipBtn.textContent = 'Skip Exploitation';
    skipBtn.addEventListener('click', skipExploitation);
    
    buttonContainer.appendChild(exploitAllBtn);
    buttonContainer.appendChild(selectBtn);
    buttonContainer.appendChild(skipBtn);
    cardBody.appendChild(buttonContainer);
    
    actionsCard.appendChild(cardHeader);
    actionsCard.appendChild(cardBody);
    container.appendChild(actionsCard);
}

function displayVulnerabilities(vulnerabilities) {
    const resultsDiv = document.getElementById('scan-results');
    
    if (vulnerabilities.length === 0) {
        resultsDiv.innerHTML = '<div class="info"><p>No vulnerabilities found.</p></div>';
        return;
    }
    
    resultsDiv.innerHTML = '<h3>Vulnerabilities Detected:</h3>' + vulnerabilities.map(vuln => `
        <div class="vulnerability severity-${sanitizeSeverity(vuln.severity)}" id="vuln-${vuln.id}">
            <div>
                <input type="checkbox" class="vuln-checkbox" id="checkbox-${vuln.id}" value="${vuln.id}" style="display:none;">
                <strong>${escapeHtml(vuln.type)}</strong> - 
                <span style="color: ${getSeverityColor(vuln.severity)};">${escapeHtml(vuln.severity.toUpperCase())}</span>
                ${vuln.exploit_status !== 'not_attempted' ? 
                    `<span class="exploit-status exploit-status-${vuln.exploit_status}">${formatExploitStatus(vuln.exploit_status)}</span>` : ''}
            </div>
            <div style="margin-top: 10px;"><strong>URL:</strong> ${escapeHtml(vuln.url)}</div>
            <div style="margin-top: 5px;"><strong>Description:</strong> ${escapeHtml(vuln.description)}</div>
            ${vuln.evidence ? `<div style="margin-top: 5px;"><strong>Evidence:</strong> ${escapeHtml(vuln.evidence)}</div>` : ''}
            ${vuln.remediation ? `<div style="margin-top: 5px;"><strong>Remediation:</strong> ${escapeHtml(vuln.remediation)}</div>` : ''}
            ${vuln.exploit_result ? `<div class="exploit-results" style="margin-top: 10px;">
                <strong>Exploit Results:</strong><br>
                <pre style="white-space: pre-wrap; margin-top: 5px;">${escapeHtml(vuln.exploit_result)}</pre>
            </div>` : ''}
        </div>
    `).join('');
}

function formatExploitStatus(status) {
    const statusMap = {
        'not_attempted': 'Not Attempted',
        'in_progress': 'In Progress',
        'success': 'Successfully Exploited',
        'failed': 'Exploitation Failed',
        'no_plugin': 'No Plugin Available'
    };
    return statusMap[status] || status;
}

// ============================================================================
// WebSocket Connection Management
// ============================================================================

function connectWebSocket(taskId) {
    if (!useWebSocket) {
        console.log('WebSocket disabled, using polling fallback');
        return;
    }
    
    // Close existing connection if any
    closeWebSocket();
    
    // Determine WebSocket protocol based on page protocol
    const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
    const wsUrl = `${protocol}//${window.location.host}/ws/scanner/task/${taskId}/`;
    
    console.log(`Attempting WebSocket connection to: ${wsUrl}`);
    
    try {
        ws = new WebSocket(wsUrl);
        
        ws.onopen = function(event) {
            console.log('WebSocket connected successfully');
            wsConnected = true;
            
            // Stop polling if it was running
            if (pollingInterval) {
                clearInterval(pollingInterval);
                pollingInterval = null;
            }
        };
        
        ws.onmessage = function(event) {
            try {
                const data = JSON.parse(event.data);
                console.log('WebSocket message received:', data);
                handleWebSocketUpdate(data);
            } catch (error) {
                console.error('Error parsing WebSocket message:', error);
            }
        };
        
        ws.onerror = function(error) {
            console.error('WebSocket error:', error);
            fallbackToPolling(taskId);
        };
        
        ws.onclose = function(event) {
            console.log('WebSocket closed:', event.code, event.reason);
            wsConnected = false;
            ws = null;
            
            // If task is still in progress, fallback to polling
            if (currentTaskId) {
                fallbackToPolling(taskId);
            }
        };
        
    } catch (error) {
        console.error('WebSocket connection failed:', error);
        fallbackToPolling(taskId);
    }
}

function closeWebSocket() {
    if (ws) {
        try {
            ws.close();
        } catch (error) {
            console.error('Error closing WebSocket:', error);
        }
        ws = null;
        wsConnected = false;
    }
}

function handleWebSocketUpdate(data) {
    const updateType = data.update_type;
    
    if (updateType === 'connection') {
        console.log('WebSocket connection confirmed');
        return;
    }
    
    if (updateType === 'progress') {
        updateProgressDisplay(data);
    } else if (updateType === 'success') {
        handleExploitationComplete(data.result);
        closeWebSocket();
    } else if (updateType === 'failure') {
        displayError(data.error || 'Exploitation failed');
        enableExploitButtons();
        closeWebSocket();
    }
}

function updateProgressDisplay(data) {
    const statusDiv = document.getElementById('scan-status');
    statusDiv.innerHTML = `
        <div class="info" style="color: #007bff;">
            <strong>Exploitation in progress...</strong><br>
            Processing vulnerability ${data.current}/${data.total} (${data.percent}%)
            ${data.status ? '<br>' + escapeHtml(data.status) : ''}
        </div>
    `;
}

function fallbackToPolling(taskId) {
    if (!useWebSocket) return;  // Already using polling
    
    console.log('Falling back to polling for task status');
    useWebSocket = false;
    
    // Start polling if not already running
    if (!pollingInterval && taskId) {
        startPolling(taskId);
    }
}

function startPolling(taskId) {
    console.log('Starting polling for task:', taskId);
    
    // Clear any existing interval
    if (pollingInterval) {
        clearInterval(pollingInterval);
    }
    
    // Poll every 2 seconds
    pollingInterval = setInterval(async () => {
        try {
            await pollTaskStatus(taskId);
        } catch (error) {
            console.error('Polling error:', error);
        }
    }, 2000);
    
    // Do an immediate poll
    pollTaskStatus(taskId);
}

async function pollTaskStatus(taskId) {
    try {
        const csrfToken = getCsrfTokenFromCookies('csrftoken');
        const response = await fetch(`/scanner/api/exploit_status/${taskId}/`, {
            headers: {
                'X-CSRFToken': csrfToken
            },
            credentials: 'same-origin'
        });
        
        if (!response.ok) {
            throw new Error(`Failed to fetch status: ${response.status}`);
        }
        
        const data = await response.json();
        
        if (data.state === 'PROGRESS') {
            updateProgressDisplay({
                current: data.current || 0,
                total: data.total || 0,
                percent: data.total > 0 ? Math.floor((data.current / data.total) * 100) : 0,
                status: data.status
            });
        } else if (data.state === 'SUCCESS') {
            if (pollingInterval) {
                clearInterval(pollingInterval);
                pollingInterval = null;
            }
            handleExploitationComplete(data.result);
        } else if (data.state === 'FAILURE') {
            if (pollingInterval) {
                clearInterval(pollingInterval);
                pollingInterval = null;
            }
            displayError(data.error || 'Exploitation failed');
            enableExploitButtons();
        }
    } catch (error) {
        console.error('Error polling task status:', error);
    }
}

function handleExploitationComplete(results) {
    currentTaskId = null;
    showExploitResults(results);
    
    // Reload vulnerabilities to show updated status
    if (currentScanId) {
        loadResults(currentScanId);
    }
}

// ============================================================================
// End WebSocket Code
// ============================================================================

async function exploitAll() {
    if (!currentScanId) {
        alert('No scan selected');
        return;
    }
    
    if (!confirm('This will attempt to exploit ALL discovered vulnerabilities. Continue?')) {
        return;
    }
    
    const csrfToken = getCsrfTokenFromCookies('csrftoken');
    
    try {
        // Disable buttons during exploitation
        disableExploitButtons();
        
        document.getElementById('scan-status').innerHTML = `
            <div class="info" style="color: #007bff;">
                <strong>Starting exploitation...</strong> Please wait.
            </div>
        `;
        
        const response = await fetch(`/scanner/api/scans/${currentScanId}/exploit/`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': csrfToken
            },
            credentials: 'same-origin',
            body: JSON.stringify({action: 'all'})
        });
        
        if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`Exploitation failed: ${response.status} - ${errorText}`);
        }
        
        const data = await response.json();
        currentTaskId = data.task_id;
        
        // Connect to WebSocket for real-time updates
        connectWebSocket(currentTaskId);
        
        // If WebSocket connection fails, fallback to polling after 1 second
        setTimeout(() => {
            if (!wsConnected) {
                fallbackToPolling(currentTaskId);
            }
        }, 1000);
        
    } catch (error) {
        displayError(error.message);
        enableExploitButtons();
    }
}

function showSelectMode() {
    // Show checkboxes for all vulnerabilities
    document.querySelectorAll('.vuln-checkbox').forEach(checkbox => {
        checkbox.style.display = 'inline-block';
    });
    
    // Update exploit actions to show selection buttons
    const container = document.getElementById('exploit-actions-container');
    if (!container) return;
    
    container.innerHTML = '';
    
    const actionsCard = document.createElement('div');
    actionsCard.className = 'card';
    
    const cardHeader = document.createElement('div');
    cardHeader.className = 'card-header';
    const headerTitle = document.createElement('h3');
    headerTitle.className = 'card-title';
    headerTitle.textContent = 'Select Vulnerabilities to Exploit';
    cardHeader.appendChild(headerTitle);
    
    const cardBody = document.createElement('div');
    cardBody.className = 'card-body';
    
    const description = document.createElement('p');
    description.textContent = 'Check the vulnerabilities you want to exploit:';
    cardBody.appendChild(description);
    
    const buttonContainer = document.createElement('div');
    buttonContainer.style.cssText = 'display: flex; gap: 0.75rem; flex-wrap: wrap;';
    
    const exploitBtn = document.createElement('button');
    exploitBtn.className = 'btn btn-primary';
    exploitBtn.textContent = 'Exploit Selected';
    exploitBtn.addEventListener('click', exploitSelected);
    
    const cancelBtn = document.createElement('button');
    cancelBtn.className = 'btn btn-secondary';
    cancelBtn.textContent = 'Cancel Selection';
    cancelBtn.addEventListener('click', cancelSelection);
    
    buttonContainer.appendChild(exploitBtn);
    buttonContainer.appendChild(cancelBtn);
    cardBody.appendChild(buttonContainer);
    
    actionsCard.appendChild(cardHeader);
    actionsCard.appendChild(cardBody);
    container.appendChild(actionsCard);
}

async function exploitSelected() {
    const selectedIds = Array.from(document.querySelectorAll('.vuln-checkbox:checked'))
        .map(cb => parseInt(cb.value));
    
    if (selectedIds.length === 0) {
        alert('Please select at least one vulnerability to exploit');
        return;
    }
    
    if (!confirm(`This will attempt to exploit ${selectedIds.length} selected vulnerability(ies). Continue?`)) {
        return;
    }
    
    const csrfToken = getCsrfTokenFromCookies('csrftoken');
    
    try {
        disableExploitButtons();
        
        document.getElementById('scan-status').innerHTML = `
            <div class="info" style="color: #007bff;">
                <strong>Starting exploitation...</strong> Processing ${selectedIds.length} vulnerability(ies).
            </div>
        `;
        
        const response = await fetch(`/scanner/api/scans/${currentScanId}/exploit/`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': csrfToken
            },
            credentials: 'same-origin',
            body: JSON.stringify({
                action: 'selected',
                vulnerability_ids: selectedIds
            })
        });
        
        if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`Exploitation failed: ${response.status} - ${errorText}`);
        }
        
        const data = await response.json();
        currentTaskId = data.task_id;
        
        // Connect to WebSocket for real-time updates
        connectWebSocket(currentTaskId);
        
        // If WebSocket connection fails, fallback to polling after 1 second
        setTimeout(() => {
            if (!wsConnected) {
                fallbackToPolling(currentTaskId);
            }
        }, 1000);
        
    } catch (error) {
        displayError(error.message);
        enableExploitButtons();
    }
}

function cancelSelection() {
    // Hide checkboxes
    document.querySelectorAll('.vuln-checkbox').forEach(checkbox => {
        checkbox.style.display = 'none';
        checkbox.checked = false;
    });
    
    // Restore original exploit actions
    showExploitActions();
}

function skipExploitation() {
    const container = document.getElementById('exploit-actions-container');
    if (!container) return;
    
    container.innerHTML = '';
    
    const infoCard = document.createElement('div');
    infoCard.className = 'card';
    infoCard.style.borderLeft = '4px solid var(--info)';
    
    const cardBody = document.createElement('div');
    cardBody.className = 'card-body';
    
    const infoText = document.createElement('p');
    infoText.textContent = 'Exploitation skipped. Showing scan results only.';
    
    cardBody.appendChild(infoText);
    infoCard.appendChild(cardBody);
    container.appendChild(infoCard);
    
    if (window.MegidoToast) {
        window.MegidoToast.info('Exploitation skipped');
    }
}

function showExploitResults(results) {
    const statusDiv = document.getElementById('scan-status');
    statusDiv.innerHTML = `
        <div class="exploit-results">
            <h3>Exploitation Results</h3>
            <p><strong>Total vulnerabilities:</strong> ${results.total}</p>
            <p><strong>Successfully exploited:</strong> <span style="color: #28a745;">${results.exploited}</span></p>
            <p><strong>Failed:</strong> <span style="color: #dc3545;">${results.failed}</span></p>
            <p><strong>No plugin available:</strong> <span style="color: #6c757d;">${results.no_plugin}</span></p>
        </div>
    `;
}

function disableExploitButtons() {
    document.querySelectorAll('#exploit-actions-container button').forEach(btn => {
        btn.disabled = true;
    });
}

function enableExploitButtons() {
    document.querySelectorAll('#exploit-actions-container button').forEach(btn => {
        btn.disabled = false;
    });
}

function getSeverityColor(severity) {
    const colors = {
        'critical': 'var(--severity-critical)',
        'high': 'var(--severity-high)',
        'medium': 'var(--severity-medium)',
        'low': 'var(--severity-low)'
    };
    return colors[severity] || 'var(--text-secondary)';
}

})(); // End IIFE
</script>
{% endblock %}
