# Megido Exploit Plugins Guide

## Overview

The Megido Exploit Plugin System provides a modular, extensible framework for implementing and managing exploit modules. The system enables automated vulnerability exploitation, payload generation, and attack execution through a plugin-based architecture.

## Architecture

The plugin system consists of three main components:

### 1. ExploitPlugin Interface (`exploit_plugin.py`)

The base interface that all exploit plugins must implement. It defines the contract for:
- Vulnerability type identification
- Payload generation
- Attack execution
- Remediation advice
- Configuration validation

### 2. PluginRegistry (`plugin_registry.py`)

The registry system that handles:
- Automatic plugin discovery in the `plugins/exploits/` directory
- Plugin registration and lifecycle management
- Plugin retrieval by vulnerability type
- Plugin metadata management

### 3. PayloadGenerator (`payload_generator.py`)

A centralized payload library that provides:
- Pre-defined payloads for common vulnerability types
- Payload customization and templating
- Encoding and obfuscation utilities
- Integration with exploit plugins

## Quick Start

### Using the Plugin System

```python
from scanner.plugins import get_registry, get_payload_generator

# Get the global plugin registry
registry = get_registry()

# List all available plugins
plugins = registry.list_plugins()
for plugin_info in plugins:
    print(f"{plugin_info['name']} - {plugin_info['description']}")

# Get a specific plugin
sqli_plugin = registry.get_plugin('sqli')
if sqli_plugin:
    # Generate payloads
    payloads = sqli_plugin.generate_payloads({'database_type': 'mysql'})
    
    # Execute an attack
    result = sqli_plugin.execute_attack(
        target_url='http://example.com/login',
        vulnerability_data={
            'parameter': 'username',
            'method': 'POST',
            'data': {'username': 'test', 'password': 'test'}
        },
        config={'verify_ssl': False}
    )
    
    if result['success']:
        print(f"Vulnerability found: {result['evidence']}")
```

### Using the Payload Generator

```python
from scanner.plugins import get_payload_generator

# Get the global payload generator
generator = get_payload_generator()

# Get SQL injection payloads for MySQL
sqli_payloads = generator.get_payloads('sqli', {'database_type': 'mysql'})
print(f"Found {len(sqli_payloads)} SQL injection payloads")

# Get XSS payloads
xss_payloads = generator.get_payloads('xss')
print(f"Found {len(xss_payloads)} XSS payloads")

# Get all supported vulnerability types
vuln_types = generator.get_all_vulnerability_types()
print(f"Supported vulnerability types: {vuln_types}")

# Encode a payload
encoded = generator.encode_payload('<script>alert(1)</script>', 'url')
print(f"URL-encoded payload: {encoded}")
```

## Creating a New Plugin

To add a new exploit plugin, follow these steps:

### Step 1: Create the Plugin File

Create a new Python file in `scanner/plugins/exploits/` (e.g., `xss_plugin.py`):

```python
"""
XSS Exploit Plugin

This plugin provides exploit capabilities for Cross-Site Scripting vulnerabilities.
"""

from typing import Dict, List, Any, Optional
from scanner.plugins.exploit_plugin import ExploitPlugin
from scanner.plugins.payload_generator import get_payload_generator

class XSSPlugin(ExploitPlugin):
    """XSS exploit plugin implementation."""
    
    @property
    def vulnerability_type(self) -> str:
        """Return the vulnerability type identifier."""
        return 'xss'
    
    @property
    def name(self) -> str:
        """Return the plugin name."""
        return 'Cross-Site Scripting Exploit'
    
    @property
    def description(self) -> str:
        """Return the plugin description."""
        return 'XSS exploit plugin supporting reflected, stored, and DOM-based XSS.'
    
    def generate_payloads(self, context: Optional[Dict[str, Any]] = None) -> List[str]:
        """Generate XSS payloads."""
        generator = get_payload_generator()
        return generator.get_payloads('xss', context)
    
    def execute_attack(self, target_url: str, vulnerability_data: Dict[str, Any],
                      config: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
        """Execute XSS attack."""
        # Implement your attack logic here
        result = {
            'success': False,
            'findings': [],
            'data': {},
            'evidence': '',
            'error': None,
        }
        
        try:
            # Your attack implementation
            pass
        except Exception as e:
            result['error'] = str(e)
        
        return result
    
    def get_remediation_advice(self) -> str:
        """Return remediation advice."""
        return "Implement proper input validation and output encoding."
    
    def get_severity_level(self) -> str:
        """Return severity level."""
        return 'high'
```

### Step 2: Test the Plugin

The plugin will be automatically discovered and loaded. Test it:

```python
from scanner.plugins import get_registry

registry = get_registry()
xss_plugin = registry.get_plugin('xss')

if xss_plugin:
    print(f"Plugin loaded: {xss_plugin.name}")
    payloads = xss_plugin.generate_payloads()
    print(f"Generated {len(payloads)} payloads")
```

### Step 3: Add Custom Payloads (Optional)

If you need custom payloads, add them to the PayloadGenerator:

```python
from scanner.plugins import get_payload_generator

generator = get_payload_generator()
custom_payloads = [
    '<custom_payload_1>',
    '<custom_payload_2>',
]
generator.add_custom_payloads('xss', custom_payloads)
```

## Plugin Interface Reference

### Required Methods

All plugins must implement these abstract methods:

#### `vulnerability_type` (property)
Returns the vulnerability type identifier (e.g., 'sqli', 'xss', 'rce').

#### `name` (property)
Returns the human-readable plugin name.

#### `description` (property)
Returns a brief description of the plugin.

#### `generate_payloads(context)`
Generates exploit payloads based on optional context.
- **Args**: `context` - Optional dictionary with context information
- **Returns**: List of payload strings

#### `execute_attack(target_url, vulnerability_data, config)`
Executes the exploit attack against a target.
- **Args**:
  - `target_url` - Target URL
  - `vulnerability_data` - Dictionary with vulnerability info
  - `config` - Optional configuration dictionary
- **Returns**: Dictionary with attack results

### Optional Methods

These methods have default implementations but can be overridden:

#### `version` (property)
Returns the plugin version (default: '1.0.0').

#### `get_remediation_advice()`
Returns remediation advice for the vulnerability type.

#### `get_severity_level()`
Returns the typical severity level ('low', 'medium', 'high', 'critical').

#### `validate_config(config)`
Validates the plugin configuration.

#### `get_required_config_keys()`
Returns list of required configuration keys.

#### `verify(result, target_url, vulnerability_data)`
**NEW**: Verifies exploit results with concrete proof of impact.
- **Args**:
  - `result` - Dictionary returned from `execute_attack()`
  - `target_url` - The target URL that was attacked
  - `vulnerability_data` - The vulnerability data used in the attack
- **Returns**: Tuple `(is_verified: bool, proof: str or None)`
  - `is_verified`: True if concrete proof of impact was demonstrated
  - `proof`: Evidence string describing the proof, or None if not verified

The `verify()` method is called automatically after a successful exploit to confirm
that real-world impact was demonstrated, not just a potential vulnerability. This
follows security industry best practices by only marking vulnerabilities as "verified"
when concrete evidence exists.

**Default Implementation**: Checks for evidence or extracted data in the result.
Plugins should override this method to implement custom verification logic.

**Example Verification Logic**:
- **Information Disclosure**: Verify sensitive content (passwords, API keys, secrets) was extracted
- **RCE**: Verify command execution with captured output (e.g., `whoami` result)
- **LFI**: Verify actual file content was successfully read
- **SQLi**: Verify database data was extracted (version, tables, records)
- **XSS**: Verify JavaScript execution via callback, DOM interaction, or visual proof
- **XXE**: Verify file extraction or out-of-band callback received

**Example Implementation**:

```python
def verify(self, result: Dict[str, Any], 
           target_url: str,
           vulnerability_data: Dict[str, Any]) -> Tuple[bool, Optional[str]]:
    """Verify RCE with proof of command execution."""
    if not result.get('success'):
        return False, None
    
    command_output = result.get('command_output', '')
    
    # Check for concrete command output
    if command_output and len(command_output) > 10:
        proof = f"✓ VERIFIED - Remote Code Execution\n\n"
        proof += f"Command Output:\n{command_output[:200]}\n\n"
        proof += "Impact: Arbitrary command execution confirmed"
        return True, proof
    
    # No concrete proof
    return False, None
```

## Post-Exploitation Verification System

The verification system ensures that only exploits with concrete proof of impact are marked as "verified". This reduces false positives and provides security teams with high-confidence results.

### How Verification Works

1. **Exploit Execution**: Plugin's `execute_attack()` method runs and returns results
2. **Verification Check**: If exploit succeeds, framework calls plugin's `verify()` method
3. **Proof Analysis**: Plugin examines results for concrete proof of impact
4. **Status Update**: Vulnerability's `verified` field is set based on verification result
5. **Proof Storage**: Concrete evidence is stored in `proof_of_impact` field

### Verification Criteria by Vulnerability Type

| Vulnerability Type | Verification Criteria | Proof Required |
|--------------------|----------------------|----------------|
| **Information Disclosure** | Sensitive data extracted (passwords, API keys, tokens, secrets) | Actual sensitive content |
| **RCE** | Command executed with output captured | Command output (e.g., `whoami`, `id`, `uname`) |
| **LFI** | File content successfully read | Actual file content |
| **SQLi** | Database data extracted | Database version, tables, or records |
| **XSS** | JavaScript executed in browser | Callback received, DOM manipulation, or visual proof |
| **XXE** | External entity processed | File content or callback received |
| **SSRF** | Internal resource accessed | Internal URL accessed or callback received |
| **CSRF** | CSRF protection bypassed | Token bypass or missing protection confirmed |
| **Open Redirect** | Redirect successfully triggered | Redirect to external URL confirmed |

### Backward Compatibility

The verification system maintains backward compatibility:
- Plugins without `verify()` method continue to work
- Default verification logic in base class provides sensible defaults
- Existing exploits are not affected
- Only new/updated plugins benefit from enhanced verification

### Example: Implementing Verification

Here's a complete example for an Information Disclosure plugin:

```python
def verify(self, result: Dict[str, Any], 
           target_url: str,
           vulnerability_data: Dict[str, Any]) -> Tuple[bool, Optional[str]]:
    """Verify information disclosure with proof of sensitive data."""
    if not result.get('success'):
        return False, None
    
    disclosed_info = result.get('disclosed_info', {})
    
    # Check for sensitive patterns
    sensitive_patterns = [
        r'password\s*[=:]\s*[\'"]?[\w\-!@#$%^&*()+=]{3,}',
        r'api[_-]?key\s*[=:]\s*[\'"]?[\w\-]{10,}',
        r'-----BEGIN (?:RSA |DSA |EC )?PRIVATE KEY-----',
    ]
    
    sensitive_findings = []
    for path, content in disclosed_info.items():
        for pattern in sensitive_patterns:
            if re.search(pattern, content, re.IGNORECASE):
                sensitive_findings.append(path)
                break
    
    if sensitive_findings:
        proof = f"✓ VERIFIED - Sensitive Information Disclosed\n\n"
        proof += f"Found sensitive data in {len(sensitive_findings)} file(s):\n"
        for path in sensitive_findings[:5]:
            proof += f"  - {path}\n"
        proof += "\nImpact: Sensitive credentials/secrets exposed"
        return True, proof
    
    return False, None
```

## Available Plugins

### SQL Injection Plugin

**File**: `scanner/plugins/exploits/sqli_plugin.py`  
**Vulnerability Type**: `sqli`  
**Supported Databases**: MySQL, PostgreSQL, MSSQL, Oracle, SQLite

**Features**:
- Error-based SQL injection detection
- Time-based blind SQL injection detection
- Union-based SQL injection
- Database fingerprinting
- Data extraction and exploitation
- Integration with Megido's SQLInjectionEngine

**Usage**:
```python
from scanner.plugins import get_registry

registry = get_registry()
sqli_plugin = registry.get_plugin('sqli')

# Generate MySQL-specific payloads
payloads = sqli_plugin.generate_payloads({
    'database_type': 'mysql',
    'injection_type': 'error'
})

# Execute attack
result = sqli_plugin.execute_attack(
    target_url='http://example.com/user?id=1',
    vulnerability_data={
        'parameter': 'id',
        'method': 'GET',
        'params': {'id': '1'}
    },
    config={
        'verify_ssl': False,
        'enable_error_based': True,
        'enable_time_based': True,
        'enable_exploitation': True
    }
)
```

### Advanced XSS Plugin

**File**: `scanner/plugins/exploits/xss_plugin.py`  
**Vulnerability Type**: `xss`  
**Supported Types**: Reflected, Stored, DOM-based XSS

**Features**:
- Smart crawling with configurable depth
- Network throttling for stealth operations
- Session management (cookies, headers, proxy)
- Selenium-powered DOM simulation
- Browser fingerprint randomization
- Evidence collection (screenshots, DOM, logs, HTML)
- JavaScript injection context analysis
- JSON and HTML report output
- Configurable scan parameters
- Highly extensible architecture

**Usage**:
```python
from scanner.plugins import get_registry

registry = get_registry()
xss_plugin = registry.get_plugin('xss')

# Generate XSS payloads
payloads = xss_plugin.generate_payloads({
    'payload_type': 'all',  # or 'basic', 'attribute', 'javascript', 'dom', 'advanced'
})

# Execute comprehensive attack
result = xss_plugin.execute_attack(
    target_url='http://example.com/search',
    vulnerability_data={
        'parameter': 'q',
        'method': 'GET',
    },
    config={
        'crawl_depth': 2,
        'max_pages': 50,
        'enable_crawler': True,
        'enable_dom_testing': True,
        'browser_type': 'chrome',
        'headless': True,
        'randomize_fingerprint': True,
        'collect_evidence': True,
        'output_format': 'both',  # 'json', 'html', or 'both'
        'output_dir': './xss_reports',
    }
)

# Check results
if result['success']:
    print(f"Found {len(result['findings'])} vulnerabilities")
    print(f"Report saved to: {result['report_path']}")
```

**Advanced Configuration**:
```python
# Authenticated testing with custom headers and cookies
result = xss_plugin.execute_attack(
    target_url='http://example.com',
    vulnerability_data={},
    config={
        'custom_headers': {
            'Authorization': 'Bearer token123',
        },
        'custom_cookies': {
            'session': 'abc123',
        },
        'proxy': {
            'http': 'http://proxy.example.com:8080',
            'https': 'https://proxy.example.com:8080',
        },
        'network_throttle': 1.0,  # 1 second delay between requests
        'timeout': 60,
    }
)
```

**Documentation**: See `XSS_PLUGIN_GUIDE.md` for comprehensive documentation.

**Demo**: Run `python3 demo_xss_plugin.py` for interactive demonstration.


### Advanced Clickjacking Plugin

**File**: `scanner/plugins/exploits/clickjacking_plugin.py`  
**Vulnerability Type**: `clickjacking`  
**Supported Techniques**: Transparent overlay, opaque overlay, button hijacking

**Features**:
- HTML proof-of-concept generation with interactive overlays
- Automated frameability detection using headless browser (Selenium)
- Security header analysis (X-Frame-Options, CSP frame-ancestors)
- Evidence collection with annotated screenshots
- Configurable overlay appearance and test parameters
- Comprehensive error handling and resource management
- Detailed severity classification based on action context
- Production-quality code with type annotations and docstrings

**Usage**:
```python
from scanner.plugins import get_registry

registry = get_registry()
clickjacking_plugin = registry.get_plugin('clickjacking')

# Test a target for clickjacking vulnerability
result = clickjacking_plugin.execute_attack(
    target_url='http://example.com/admin',
    vulnerability_data={'action_description': 'admin panel access'},
    config={
        'test_mode': False,
        'browser_type': 'chrome',
        'headless': True,
        'collect_evidence': True,
        'output_dir': './clickjacking_reports',
    }
)

# Check results
if result['vulnerable']:
    print(f"Vulnerability found! Severity: {result['severity']}")
    print(f"PoC saved to: {result['data']['poc_path']}")
else:
    print("Target has adequate clickjacking protection")

# Generate custom PoC payloads
payloads = clickjacking_plugin.generate_payloads({
    'target_url': 'http://example.com/payment',
    'overlay_style': 'transparent',  # or 'opaque', 'partial'
    'overlay_text': 'Claim Your Prize',
    'overlay_opacity': 0.3,
    'action_description': 'payment processing'
})
```

**Advanced Configuration**:
```python
# Quick assessment using only header analysis
result = clickjacking_plugin.execute_attack(
    target_url='http://example.com',
    vulnerability_data={},
    config={
        'test_mode': True,  # Skip browser test for speed
        'verify_ssl': False,  # Accept self-signed certificates
    }
)

# Full browser test with custom overlay
result = clickjacking_plugin.execute_attack(
    target_url='http://example.com/transfer',
    vulnerability_data={'action_description': 'money transfer'},
    config={
        'overlay_style': 'opaque',
        'overlay_text': 'Win $1000!',
        'overlay_opacity': 0.01,  # Nearly invisible
        'browser_type': 'firefox',
        'timeout': 60,
        'enable_annotations': True,
    }
)
```

**Documentation**: See `CLICKJACKING_PLUGIN_GUIDE.md` for comprehensive documentation and examples.


## Payload Library

The PayloadGenerator provides pre-defined payloads for:

- **SQL Injection** (`sqli`): Basic, MySQL, PostgreSQL, MSSQL, Oracle, SQLite
- **Cross-Site Scripting** (`xss`): Various XSS vectors
- **Remote Code Execution** (`rce`): Command injection payloads
- **Local File Inclusion** (`lfi`): Path traversal payloads
- **Remote File Inclusion** (`rfi`): Remote file payloads
- **XXE** (`xxe`): XML External Entity payloads
- **SSRF** (`ssrf`): Server-Side Request Forgery payloads
- **Open Redirect** (`open_redirect`): Redirect payloads
- **CSRF** (`csrf`): CSRF token bypass payloads
- **Clickjacking** (`clickjacking`): HTML iframe embedding payloads

### Payload Encoding

The PayloadGenerator supports multiple encoding methods:

```python
from scanner.plugins import get_payload_generator

generator = get_payload_generator()

payload = '<script>alert(1)</script>'

# URL encoding
url_encoded = generator.encode_payload(payload, 'url')

# Base64 encoding
base64_encoded = generator.encode_payload(payload, 'base64')

# HTML encoding
html_encoded = generator.encode_payload(payload, 'html')

# Unicode encoding
unicode_encoded = generator.encode_payload(payload, 'unicode')
```

## Integration with Scanner

The plugin system can be integrated with the Megido scanner:

```python
from scanner.plugins import get_registry
from scanner.models import Vulnerability, Scan

def exploit_vulnerability(vulnerability: Vulnerability) -> dict:
    """Exploit a discovered vulnerability using the appropriate plugin."""
    registry = get_registry()
    
    # Get the plugin for this vulnerability type
    plugin = registry.get_plugin(vulnerability.vulnerability_type)
    
    if not plugin:
        return {'error': f'No plugin available for {vulnerability.vulnerability_type}'}
    
    # Execute the attack
    result = plugin.execute_attack(
        target_url=vulnerability.url,
        vulnerability_data={
            'parameter': vulnerability.parameter,
            'method': 'GET',  # or determine from vulnerability data
        },
        config={'verify_ssl': False}
    )
    
    return result
```

## Testing

The plugin system includes comprehensive tests. To run tests:

```bash
python manage.py test scanner.tests.test_exploit_plugins
```

## Security Considerations

1. **Ethical Use**: Only use exploit plugins against systems you have explicit permission to test.

2. **SSL Verification**: By default, SSL verification is disabled for testing environments. Enable it in production.

3. **Rate Limiting**: Use the `use_random_delays` configuration to avoid triggering rate limits or IDS/IPS systems.

4. **Logging**: All plugin operations are logged for audit purposes.

5. **Configuration Validation**: Always validate plugin configuration before execution.

## Best Practices

1. **Modular Design**: Keep plugins focused on a single vulnerability type.

2. **Error Handling**: Implement robust error handling in your plugins.

3. **Documentation**: Document all plugin methods, parameters, and return values.

4. **Testing**: Write unit tests for your plugins.

5. **Remediation**: Always provide clear remediation advice.

6. **Versioning**: Use semantic versioning for your plugins.

7. **Configuration**: Make plugins configurable with sensible defaults.

## Troubleshooting

### Plugin Not Discovered

If your plugin is not being discovered:

1. Ensure the file is in `scanner/plugins/exploits/` directory
2. Check that the class inherits from `ExploitPlugin`
3. Verify all abstract methods are implemented
4. Check for syntax errors in the plugin file
5. Review logs for import errors

### Import Errors

If you encounter import errors:

```python
# Use absolute imports
from scanner.plugins.exploit_plugin import ExploitPlugin

# Or add path manipulation at the top of your plugin
import sys
import os
sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__)))))
```

### Testing Plugin Discovery

```python
from scanner.plugins import get_registry, reset_registry

# Reset and reload plugins
reset_registry()
registry = get_registry()

# Check if your plugin is loaded
plugins = registry.list_plugins()
print(f"Loaded {len(plugins)} plugins:")
for plugin in plugins:
    print(f"  - {plugin['name']} ({plugin['vulnerability_type']})")
```

## Contributing

To contribute a new plugin:

1. Create the plugin following the guidelines above
2. Add comprehensive docstrings
3. Include unit tests
4. Update this documentation
5. Submit a pull request

## License

The Megido Exploit Plugin System is part of the Megido Security Testing Platform.

## Support

For issues, questions, or contributions, please refer to the main Megido repository.
