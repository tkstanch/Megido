# Megido Exploit Plugins Guide

## Overview

The Megido Exploit Plugin System provides a modular, extensible framework for implementing and managing exploit modules. The system enables automated vulnerability exploitation, payload generation, and attack execution through a plugin-based architecture.

## Architecture

The plugin system consists of three main components:

### 1. ExploitPlugin Interface (`exploit_plugin.py`)

The base interface that all exploit plugins must implement. It defines the contract for:
- Vulnerability type identification
- Payload generation
- Attack execution
- Remediation advice
- Configuration validation

### 2. PluginRegistry (`plugin_registry.py`)

The registry system that handles:
- Automatic plugin discovery in the `plugins/exploits/` directory
- Plugin registration and lifecycle management
- Plugin retrieval by vulnerability type
- Plugin metadata management

### 3. PayloadGenerator (`payload_generator.py`)

A centralized payload library that provides:
- Pre-defined payloads for common vulnerability types
- Payload customization and templating
- Encoding and obfuscation utilities
- Integration with exploit plugins

## Quick Start

### Using the Plugin System

```python
from scanner.plugins import get_registry, get_payload_generator

# Get the global plugin registry
registry = get_registry()

# List all available plugins
plugins = registry.list_plugins()
for plugin_info in plugins:
    print(f"{plugin_info['name']} - {plugin_info['description']}")

# Get a specific plugin
sqli_plugin = registry.get_plugin('sqli')
if sqli_plugin:
    # Generate payloads
    payloads = sqli_plugin.generate_payloads({'database_type': 'mysql'})
    
    # Execute an attack
    result = sqli_plugin.execute_attack(
        target_url='http://example.com/login',
        vulnerability_data={
            'parameter': 'username',
            'method': 'POST',
            'data': {'username': 'test', 'password': 'test'}
        },
        config={'verify_ssl': False}
    )
    
    if result['success']:
        print(f"Vulnerability found: {result['evidence']}")
```

### Using the Payload Generator

```python
from scanner.plugins import get_payload_generator

# Get the global payload generator
generator = get_payload_generator()

# Get SQL injection payloads for MySQL
sqli_payloads = generator.get_payloads('sqli', {'database_type': 'mysql'})
print(f"Found {len(sqli_payloads)} SQL injection payloads")

# Get XSS payloads
xss_payloads = generator.get_payloads('xss')
print(f"Found {len(xss_payloads)} XSS payloads")

# Get all supported vulnerability types
vuln_types = generator.get_all_vulnerability_types()
print(f"Supported vulnerability types: {vuln_types}")

# Encode a payload
encoded = generator.encode_payload('<script>alert(1)</script>', 'url')
print(f"URL-encoded payload: {encoded}")
```

## Creating a New Plugin

To add a new exploit plugin, follow these steps:

### Step 1: Create the Plugin File

Create a new Python file in `scanner/plugins/exploits/` (e.g., `xss_plugin.py`):

```python
"""
XSS Exploit Plugin

This plugin provides exploit capabilities for Cross-Site Scripting vulnerabilities.
"""

from typing import Dict, List, Any, Optional
from scanner.plugins.exploit_plugin import ExploitPlugin
from scanner.plugins.payload_generator import get_payload_generator

class XSSPlugin(ExploitPlugin):
    """XSS exploit plugin implementation."""
    
    @property
    def vulnerability_type(self) -> str:
        """Return the vulnerability type identifier."""
        return 'xss'
    
    @property
    def name(self) -> str:
        """Return the plugin name."""
        return 'Cross-Site Scripting Exploit'
    
    @property
    def description(self) -> str:
        """Return the plugin description."""
        return 'XSS exploit plugin supporting reflected, stored, and DOM-based XSS.'
    
    def generate_payloads(self, context: Optional[Dict[str, Any]] = None) -> List[str]:
        """Generate XSS payloads."""
        generator = get_payload_generator()
        return generator.get_payloads('xss', context)
    
    def execute_attack(self, target_url: str, vulnerability_data: Dict[str, Any],
                      config: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
        """Execute XSS attack."""
        # Implement your attack logic here
        result = {
            'success': False,
            'findings': [],
            'data': {},
            'evidence': '',
            'error': None,
        }
        
        try:
            # Your attack implementation
            pass
        except Exception as e:
            result['error'] = str(e)
        
        return result
    
    def get_remediation_advice(self) -> str:
        """Return remediation advice."""
        return "Implement proper input validation and output encoding."
    
    def get_severity_level(self) -> str:
        """Return severity level."""
        return 'high'
```

### Step 2: Test the Plugin

The plugin will be automatically discovered and loaded. Test it:

```python
from scanner.plugins import get_registry

registry = get_registry()
xss_plugin = registry.get_plugin('xss')

if xss_plugin:
    print(f"Plugin loaded: {xss_plugin.name}")
    payloads = xss_plugin.generate_payloads()
    print(f"Generated {len(payloads)} payloads")
```

### Step 3: Add Custom Payloads (Optional)

If you need custom payloads, add them to the PayloadGenerator:

```python
from scanner.plugins import get_payload_generator

generator = get_payload_generator()
custom_payloads = [
    '<custom_payload_1>',
    '<custom_payload_2>',
]
generator.add_custom_payloads('xss', custom_payloads)
```

## Plugin Interface Reference

### Required Methods

All plugins must implement these abstract methods:

#### `vulnerability_type` (property)
Returns the vulnerability type identifier (e.g., 'sqli', 'xss', 'rce').

#### `name` (property)
Returns the human-readable plugin name.

#### `description` (property)
Returns a brief description of the plugin.

#### `generate_payloads(context)`
Generates exploit payloads based on optional context.
- **Args**: `context` - Optional dictionary with context information
- **Returns**: List of payload strings

#### `execute_attack(target_url, vulnerability_data, config)`
Executes the exploit attack against a target.
- **Args**:
  - `target_url` - Target URL
  - `vulnerability_data` - Dictionary with vulnerability info
  - `config` - Optional configuration dictionary
- **Returns**: Dictionary with attack results

### Optional Methods

These methods have default implementations but can be overridden:

#### `version` (property)
Returns the plugin version (default: '1.0.0').

#### `get_remediation_advice()`
Returns remediation advice for the vulnerability type.

#### `get_severity_level()`
Returns the typical severity level ('low', 'medium', 'high', 'critical').

#### `validate_config(config)`
Validates the plugin configuration.

#### `get_required_config_keys()`
Returns list of required configuration keys.

## Available Plugins

### SQL Injection Plugin

**File**: `scanner/plugins/exploits/sqli_plugin.py`  
**Vulnerability Type**: `sqli`  
**Supported Databases**: MySQL, PostgreSQL, MSSQL, Oracle, SQLite

**Features**:
- Error-based SQL injection detection
- Time-based blind SQL injection detection
- Union-based SQL injection
- Database fingerprinting
- Data extraction and exploitation
- Integration with Megido's SQLInjectionEngine

**Usage**:
```python
from scanner.plugins import get_registry

registry = get_registry()
sqli_plugin = registry.get_plugin('sqli')

# Generate MySQL-specific payloads
payloads = sqli_plugin.generate_payloads({
    'database_type': 'mysql',
    'injection_type': 'error'
})

# Execute attack
result = sqli_plugin.execute_attack(
    target_url='http://example.com/user?id=1',
    vulnerability_data={
        'parameter': 'id',
        'method': 'GET',
        'params': {'id': '1'}
    },
    config={
        'verify_ssl': False,
        'enable_error_based': True,
        'enable_time_based': True,
        'enable_exploitation': True
    }
)
```

### Advanced XSS Plugin

**File**: `scanner/plugins/exploits/xss_plugin.py`  
**Vulnerability Type**: `xss`  
**Supported Types**: Reflected, Stored, DOM-based XSS

**Features**:
- Smart crawling with configurable depth
- Network throttling for stealth operations
- Session management (cookies, headers, proxy)
- Selenium-powered DOM simulation
- Browser fingerprint randomization
- Evidence collection (screenshots, DOM, logs, HTML)
- JavaScript injection context analysis
- JSON and HTML report output
- Configurable scan parameters
- Highly extensible architecture

**Usage**:
```python
from scanner.plugins import get_registry

registry = get_registry()
xss_plugin = registry.get_plugin('xss')

# Generate XSS payloads
payloads = xss_plugin.generate_payloads({
    'payload_type': 'all',  # or 'basic', 'attribute', 'javascript', 'dom', 'advanced'
})

# Execute comprehensive attack
result = xss_plugin.execute_attack(
    target_url='http://example.com/search',
    vulnerability_data={
        'parameter': 'q',
        'method': 'GET',
    },
    config={
        'crawl_depth': 2,
        'max_pages': 50,
        'enable_crawler': True,
        'enable_dom_testing': True,
        'browser_type': 'chrome',
        'headless': True,
        'randomize_fingerprint': True,
        'collect_evidence': True,
        'output_format': 'both',  # 'json', 'html', or 'both'
        'output_dir': './xss_reports',
    }
)

# Check results
if result['success']:
    print(f"Found {len(result['findings'])} vulnerabilities")
    print(f"Report saved to: {result['report_path']}")
```

**Advanced Configuration**:
```python
# Authenticated testing with custom headers and cookies
result = xss_plugin.execute_attack(
    target_url='http://example.com',
    vulnerability_data={},
    config={
        'custom_headers': {
            'Authorization': 'Bearer token123',
        },
        'custom_cookies': {
            'session': 'abc123',
        },
        'proxy': {
            'http': 'http://proxy.example.com:8080',
            'https': 'https://proxy.example.com:8080',
        },
        'network_throttle': 1.0,  # 1 second delay between requests
        'timeout': 60,
    }
)
```

**Documentation**: See `XSS_PLUGIN_GUIDE.md` for comprehensive documentation.

**Demo**: Run `python3 demo_xss_plugin.py` for interactive demonstration.


## Payload Library

The PayloadGenerator provides pre-defined payloads for:

- **SQL Injection** (`sqli`): Basic, MySQL, PostgreSQL, MSSQL, Oracle, SQLite
- **Cross-Site Scripting** (`xss`): Various XSS vectors
- **Remote Code Execution** (`rce`): Command injection payloads
- **Local File Inclusion** (`lfi`): Path traversal payloads
- **Remote File Inclusion** (`rfi`): Remote file payloads
- **XXE** (`xxe`): XML External Entity payloads
- **SSRF** (`ssrf`): Server-Side Request Forgery payloads
- **Open Redirect** (`open_redirect`): Redirect payloads
- **CSRF** (`csrf`): CSRF token bypass payloads

### Payload Encoding

The PayloadGenerator supports multiple encoding methods:

```python
from scanner.plugins import get_payload_generator

generator = get_payload_generator()

payload = '<script>alert(1)</script>'

# URL encoding
url_encoded = generator.encode_payload(payload, 'url')

# Base64 encoding
base64_encoded = generator.encode_payload(payload, 'base64')

# HTML encoding
html_encoded = generator.encode_payload(payload, 'html')

# Unicode encoding
unicode_encoded = generator.encode_payload(payload, 'unicode')
```

## Integration with Scanner

The plugin system can be integrated with the Megido scanner:

```python
from scanner.plugins import get_registry
from scanner.models import Vulnerability, Scan

def exploit_vulnerability(vulnerability: Vulnerability) -> dict:
    """Exploit a discovered vulnerability using the appropriate plugin."""
    registry = get_registry()
    
    # Get the plugin for this vulnerability type
    plugin = registry.get_plugin(vulnerability.vulnerability_type)
    
    if not plugin:
        return {'error': f'No plugin available for {vulnerability.vulnerability_type}'}
    
    # Execute the attack
    result = plugin.execute_attack(
        target_url=vulnerability.url,
        vulnerability_data={
            'parameter': vulnerability.parameter,
            'method': 'GET',  # or determine from vulnerability data
        },
        config={'verify_ssl': False}
    )
    
    return result
```

## Testing

The plugin system includes comprehensive tests. To run tests:

```bash
python manage.py test scanner.tests.test_exploit_plugins
```

## Security Considerations

1. **Ethical Use**: Only use exploit plugins against systems you have explicit permission to test.

2. **SSL Verification**: By default, SSL verification is disabled for testing environments. Enable it in production.

3. **Rate Limiting**: Use the `use_random_delays` configuration to avoid triggering rate limits or IDS/IPS systems.

4. **Logging**: All plugin operations are logged for audit purposes.

5. **Configuration Validation**: Always validate plugin configuration before execution.

## Best Practices

1. **Modular Design**: Keep plugins focused on a single vulnerability type.

2. **Error Handling**: Implement robust error handling in your plugins.

3. **Documentation**: Document all plugin methods, parameters, and return values.

4. **Testing**: Write unit tests for your plugins.

5. **Remediation**: Always provide clear remediation advice.

6. **Versioning**: Use semantic versioning for your plugins.

7. **Configuration**: Make plugins configurable with sensible defaults.

## Troubleshooting

### Plugin Not Discovered

If your plugin is not being discovered:

1. Ensure the file is in `scanner/plugins/exploits/` directory
2. Check that the class inherits from `ExploitPlugin`
3. Verify all abstract methods are implemented
4. Check for syntax errors in the plugin file
5. Review logs for import errors

### Import Errors

If you encounter import errors:

```python
# Use absolute imports
from scanner.plugins.exploit_plugin import ExploitPlugin

# Or add path manipulation at the top of your plugin
import sys
import os
sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__)))))
```

### Testing Plugin Discovery

```python
from scanner.plugins import get_registry, reset_registry

# Reset and reload plugins
reset_registry()
registry = get_registry()

# Check if your plugin is loaded
plugins = registry.list_plugins()
print(f"Loaded {len(plugins)} plugins:")
for plugin in plugins:
    print(f"  - {plugin['name']} ({plugin['vulnerability_type']})")
```

## Contributing

To contribute a new plugin:

1. Create the plugin following the guidelines above
2. Add comprehensive docstrings
3. Include unit tests
4. Update this documentation
5. Submit a pull request

## License

The Megido Exploit Plugin System is part of the Megido Security Testing Platform.

## Support

For issues, questions, or contributions, please refer to the main Megido repository.
