"""
Adaptive WAF Detection and Bypass Engine

Intelligent system for detecting WAF presence and automatically selecting
appropriate bypass techniques based on WAF behavior and fingerprints.
"""

import re
import logging
from typing import Dict, List, Optional, Tuple
from dataclasses import dataclass
import hashlib

logger = logging.getLogger(__name__)


@dataclass
class WAFSignature:
    """WAF signature for detection"""
    name: str
    patterns: List[str]  # Regex patterns for detection
    headers: List[str]  # Header indicators
    cookies: List[str]  # Cookie indicators
    status_codes: List[int]  # Common response codes
    confidence: float = 0.0  # Detection confidence


class WAFDetector:
    """Detects WAF presence and type from responses"""
    
    # Comprehensive WAF signatures database
    WAF_SIGNATURES = {
        'cloudflare': WAFSignature(
            name='Cloudflare',
            patterns=[
                r'cloudflare',
                r'cf-ray',
                r'attention required.*cloudflare',
                r'checking your browser',
                r'why have i been blocked',
            ],
            headers=['cf-ray', 'cf-cache-status', 'cf-request-id', 'server: cloudflare'],
            cookies=['__cfduid', '__cflb', 'cf_clearance'],
            status_codes=[403, 429, 503],
        ),
        'imperva': WAFSignature(
            name='Imperva Incapsula',
            patterns=[
                r'incapsula',
                r'imperva',
                r'/_Incapsula_Resource',
                r'visid_incap',
            ],
            headers=['x-iinfo', 'x-cdn'],
            cookies=['visid_incap', 'incap_ses'],
            status_codes=[403],
        ),
        'akamai': WAFSignature(
            name='Akamai',
            patterns=[
                r'akamai',
                r'akamaighost',
                r'reference.*\d+\.\w+\.\d+',
            ],
            headers=['server: akamaighost', 'x-akamai'],
            cookies=['ak_bmsc'],
            status_codes=[403],
        ),
        'modsecurity': WAFSignature(
            name='ModSecurity',
            patterns=[
                r'mod_security',
                r'modsecurity',
                r'this error was generated by mod_security',
                r'not acceptable.*mod_security',
            ],
            headers=['server: mod_security'],
            cookies=[],
            status_codes=[403, 406, 501],
        ),
        'f5_asm': WAFSignature(
            name='F5 ASM',
            patterns=[
                r'the requested url was rejected',
                r'support id',
                r'f5',
            ],
            headers=['x-cnection', 'x-wa-info'],
            cookies=['TS', 'F5_'],
            status_codes=[403],
        ),
        'aws_waf': WAFSignature(
            name='AWS WAF',
            patterns=[
                r'aws',
                r'x-amzn',
                r'forbidden.*request.*blocked',
            ],
            headers=['x-amzn-requestid', 'x-amzn-trace-id', 'x-amz'],
            cookies=[],
            status_codes=[403],
        ),
        'barracuda': WAFSignature(
            name='Barracuda',
            patterns=[
                r'barracuda',
                r'barra_counter_session',
            ],
            headers=['x-barracuda'],
            cookies=['barra_counter_session'],
            status_codes=[403],
        ),
        'sucuri': WAFSignature(
            name='Sucuri',
            patterns=[
                r'sucuri',
                r'questions\?.*cloudproxy',
                r'access denied.*sucuri',
            ],
            headers=['x-sucuri-id', 'x-sucuri-cache', 'server: sucuri'],
            cookies=['sucuri-'],
            status_codes=[403],
        ),
        'wordfence': WAFSignature(
            name='Wordfence',
            patterns=[
                r'wordfence',
                r'generated by wordfence',
                r'your access.*blocked',
            ],
            headers=[],
            cookies=['wfvt_', 'wordfence_verifiedHuman'],
            status_codes=[403, 503],
        ),
        'fortiweb': WAFSignature(
            name='FortiWeb',
            patterns=[
                r'fortinet',
                r'fortiweb',
                r'fortigate',
            ],
            headers=['server: fortiweb'],
            cookies=['FORTIWAFSID'],
            status_codes=[403],
        ),
        'wallarm': WAFSignature(
            name='Wallarm',
            patterns=[
                r'wallarm',
                r'nginx-wallarm',
            ],
            headers=['server: nginx-wallarm'],
            cookies=[],
            status_codes=[403],
        ),
        'reblaze': WAFSignature(
            name='Reblaze',
            patterns=[
                r'reblaze',
                r'rbzid',
            ],
            headers=['server: reblaze'],
            cookies=['rbzid'],
            status_codes=[403],
        ),
    }
    
    def __init__(self):
        self.detection_cache = {}  # Cache WAF detections
    
    def detect_waf(self, response, baseline_response=None) -> Tuple[Optional[str], float]:
        """
        Detect WAF from response
        
        Returns:
            Tuple of (WAF name, confidence score)
        """
        if not response:
            return None, 0.0
        
        # Generate cache key
        cache_key = self._generate_cache_key(response)
        if cache_key in self.detection_cache:
            return self.detection_cache[cache_key]
        
        detected_wafs = []
        
        for waf_name, signature in self.WAF_SIGNATURES.items():
            confidence = self._calculate_waf_confidence(response, signature)
            if confidence > 0.3:  # Threshold for detection
                detected_wafs.append((waf_name, confidence))
                logger.info(f"Potential WAF detected: {waf_name} (confidence: {confidence:.2f})")
        
        if detected_wafs:
            # Sort by confidence and return highest
            detected_wafs.sort(key=lambda x: x[1], reverse=True)
            result = detected_wafs[0]
        else:
            result = (None, 0.0)
        
        # Cache result
        self.detection_cache[cache_key] = result
        return result
    
    def _calculate_waf_confidence(self, response, signature: WAFSignature) -> float:
        """Calculate confidence score for WAF signature match"""
        confidence = 0.0
        checks = 0
        
        response_text = response.text.lower() if hasattr(response, 'text') else ''
        response_headers = {k.lower(): v.lower() for k, v in response.headers.items()} if hasattr(response, 'headers') else {}
        response_cookies = {}
        if hasattr(response, 'cookies'):
            response_cookies = {k.lower(): v for k, v in response.cookies.items()}
        
        # Check patterns in response body
        checks += 1
        pattern_matches = sum(1 for pattern in signature.patterns if re.search(pattern, response_text, re.IGNORECASE))
        if pattern_matches > 0:
            confidence += (pattern_matches / len(signature.patterns)) * 0.4  # 40% weight
        
        # Check headers
        checks += 1
        header_matches = sum(1 for header in signature.headers if any(header.lower() in h for h in response_headers))
        if header_matches > 0 and signature.headers:
            confidence += (header_matches / len(signature.headers)) * 0.3  # 30% weight
        
        # Check cookies
        if signature.cookies:
            checks += 1
            cookie_matches = sum(1 for cookie in signature.cookies if any(cookie.lower() in c for c in response_cookies))
            if cookie_matches > 0:
                confidence += (cookie_matches / len(signature.cookies)) * 0.2  # 20% weight
        
        # Check status codes
        checks += 1
        if hasattr(response, 'status_code') and response.status_code in signature.status_codes:
            confidence += 0.1  # 10% weight
        
        return min(confidence, 1.0)
    
    def _generate_cache_key(self, response) -> str:
        """Generate cache key for response"""
        key_data = f"{response.status_code if hasattr(response, 'status_code') else 0}"
        if hasattr(response, 'headers'):
            key_data += str(sorted(response.headers.items()))
        if hasattr(response, 'text'):
            key_data += response.text[:500]  # First 500 chars
        return hashlib.md5(key_data.encode()).hexdigest()
    
    def is_waf_response(self, response, baseline_response=None) -> bool:
        """Check if response indicates WAF blocking"""
        if not response:
            return False
        
        # Check for WAF detection
        waf_name, confidence = self.detect_waf(response, baseline_response)
        if waf_name and confidence > 0.5:
            return True
        
        # Generic WAF indicators
        waf_keywords = [
            'blocked', 'forbidden', 'not acceptable', 'security',
            'firewall', 'waf', 'access denied', 'rejected',
            'suspicious', 'malicious', 'attack', 'invalid request',
            'rate limit', 'too many requests'
        ]
        
        response_text_lower = response.text.lower() if hasattr(response, 'text') else ''
        for keyword in waf_keywords:
            if keyword in response_text_lower:
                return True
        
        # Check for significant response changes from baseline
        if baseline_response and hasattr(response, 'text') and hasattr(baseline_response, 'text'):
            if len(response.text) < len(baseline_response.text) * 0.3:  # Less than 30% of original
                return True
        
        return False


class AdaptiveBypassEngine:
    """Adaptive engine for bypassing WAF using intelligent technique selection"""
    
    def __init__(self, tamper_engine, polyglot_engine):
        """
        Initialize adaptive bypass engine
        
        Args:
            tamper_engine: TamperEngine instance
            polyglot_engine: PolyglotEngine instance
        """
        self.tamper_engine = tamper_engine
        self.polyglot_engine = polyglot_engine
        self.waf_detector = WAFDetector()
        self.success_history = {}  # Track successful bypasses
        self.failed_techniques = {}  # Track failed techniques per WAF
    
    def get_bypass_payloads(self, original_payload: str, detected_waf: Optional[str] = None,
                           max_variations: int = 20) -> List[str]:
        """
        Get adaptive bypass payloads based on detected WAF
        
        Args:
            original_payload: Original SQL injection payload
            detected_waf: Detected WAF name (if any)
            max_variations: Maximum number of variations to generate
        
        Returns:
            List of bypass payload variations
        """
        bypass_payloads = [original_payload]  # Include original
        
        if detected_waf:
            # Use WAF-specific bypass techniques
            logger.info(f"Generating bypass payloads for detected WAF: {detected_waf}")
            bypass_payloads.extend(self._get_waf_specific_bypasses(original_payload, detected_waf))
        else:
            # Use general bypass techniques
            logger.info("No WAF detected, using general bypass techniques")
            bypass_payloads.extend(self._get_general_bypasses(original_payload))
        
        # Add tamper script variations
        tamper_variations = self.tamper_engine.get_all_variations(original_payload, max_variations // 2)
        bypass_payloads.extend(tamper_variations)
        
        # Add polyglot variations
        polyglot_payloads = self._blend_with_polyglots(original_payload)
        bypass_payloads.extend(polyglot_payloads[:max_variations // 4])
        
        # Remove duplicates while preserving order
        seen = set()
        unique_payloads = []
        for payload in bypass_payloads:
            if payload not in seen:
                seen.add(payload)
                unique_payloads.append(payload)
        
        return unique_payloads[:max_variations]
    
    def _get_waf_specific_bypasses(self, payload: str, waf_name: str) -> List[str]:
        """Get WAF-specific bypass payloads"""
        bypasses = []
        
        # Get recommended tamper scripts for this WAF
        recommended_tampers = self.tamper_engine.get_recommended_tampers_for_waf(waf_name)
        
        # Apply recommended tampers
        for tamper in recommended_tampers:
            bypasses.append(self.tamper_engine.apply_tamper(payload, tamper))
        
        # Apply combinations of tampers
        if len(recommended_tampers) >= 2:
            bypasses.append(self.tamper_engine.apply_multiple_tampers(payload, recommended_tampers[:2]))
        
        # WAF-specific special techniques
        if waf_name.lower() in ['cloudflare', 'imperva', 'akamai']:
            # Use advanced encoding for cloud WAFs
            bypasses.append(self.tamper_engine.apply_tamper(payload, 'chardoubleencode'))
            bypasses.append(self.tamper_engine.apply_tamper(payload, 'overlongutf8'))
        
        if waf_name.lower() in ['modsecurity', 'mod_security']:
            # Use version-specific comments for ModSecurity
            bypasses.append(self.tamper_engine.apply_tamper(payload, 'modsecurityversioned'))
            bypasses.append(self.tamper_engine.apply_tamper(payload, 'versionedmorekeywords'))
        
        return bypasses
    
    def _get_general_bypasses(self, payload: str) -> List[str]:
        """Get general bypass payloads when WAF is unknown"""
        bypasses = []
        
        # Common effective techniques
        common_techniques = [
            'space2comment',
            'randomcase',
            'versionedkeywords',
            'appendnullbyte',
            'randomcomments',
        ]
        
        for technique in common_techniques:
            bypasses.append(self.tamper_engine.apply_tamper(payload, technique))
        
        return bypasses
    
    def _blend_with_polyglots(self, payload: str) -> List[str]:
        """Blend original payload with polyglot techniques"""
        blended = []
        
        # Get some universal polyglots
        polyglots = self.polyglot_engine.get_universal_polyglots()[:5]
        
        for polyglot in polyglots:
            # Try to intelligently merge payload with polyglot
            # This is a simple append for now, can be more sophisticated
            blended.append(f"{payload} {polyglot}")
        
        return blended
    
    def record_success(self, waf_name: str, technique: str, payload: str):
        """Record successful bypass for future adaptive learning"""
        if waf_name not in self.success_history:
            self.success_history[waf_name] = []
        
        self.success_history[waf_name].append({
            'technique': technique,
            'payload': payload[:100],  # Store first 100 chars
        })
        
        logger.info(f"Recorded successful bypass for {waf_name} using {technique}")
    
    def record_failure(self, waf_name: str, technique: str):
        """Record failed bypass attempt"""
        if waf_name not in self.failed_techniques:
            self.failed_techniques[waf_name] = set()
        
        self.failed_techniques[waf_name].add(technique)
    
    def get_learned_bypasses(self, waf_name: str) -> List[Dict]:
        """Get previously successful bypasses for a WAF"""
        return self.success_history.get(waf_name, [])
    
    def should_skip_technique(self, waf_name: str, technique: str) -> bool:
        """Check if technique has consistently failed for this WAF"""
        if waf_name in self.failed_techniques:
            return technique in self.failed_techniques[waf_name]
        return False
    
    def analyze_response_for_hints(self, response) -> Dict[str, any]:
        """
        Analyze response to extract hints about filtering/blocking
        
        Returns:
            Dict with analysis results
        """
        analysis = {
            'is_blocked': False,
            'block_reason': None,
            'suggested_bypasses': [],
            'detected_keywords': [],
        }
        
        if not response or not hasattr(response, 'text'):
            return analysis
        
        response_text = response.text.lower()
        
        # Check for specific keyword blocking
        sql_keywords = ['select', 'union', 'from', 'where', 'or', 'and', 'drop', 'insert']
        blocked_keywords = [kw for kw in sql_keywords if kw in response_text and 'blocked' in response_text]
        
        if blocked_keywords:
            analysis['is_blocked'] = True
            analysis['block_reason'] = f"Keywords blocked: {', '.join(blocked_keywords)}"
            analysis['detected_keywords'] = blocked_keywords
            # Suggest keyword obfuscation
            analysis['suggested_bypasses'] = ['versionedkeywords', 'randomcase', 'randomcomments']
        
        # Check for quote blocking
        if any(phrase in response_text for phrase in ["quote", "apostrophe", "'"]):
            analysis['is_blocked'] = True
            analysis['block_reason'] = "Quote character blocking detected"
            analysis['suggested_bypasses'].extend(['apostrophemask', 'apostrophenullencode', 'escapequotes'])
        
        # Check for space blocking
        if 'space' in response_text or '%20' in response_text:
            analysis['is_blocked'] = True
            analysis['block_reason'] = "Space character blocking detected"
            analysis['suggested_bypasses'].extend(['space2comment', 'space2plus', 'space2randomblank'])
        
        return analysis
