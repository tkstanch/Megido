"""
Unit tests for the Automated Exploitation Chain Orchestrator.
"""

import unittest
from unittest.mock import Mock, patch
from sql_attacker.exploitation_chain import (
    ExploitationChainOrchestrator,
    ExploitationResult,
)


class TestExploitationResult(unittest.TestCase):
    """Tests for the ExploitationResult dataclass."""

    def test_default_values(self):
        result = ExploitationResult()
        self.assertFalse(result.sqli_confirmed)
        self.assertEqual(result.database_type, "unknown")
        self.assertEqual(result.impact_score, 0)
        self.assertIsInstance(result.credentials_extracted, list)
        self.assertIsInstance(result.steps_completed, list)

    def test_can_set_fields(self):
        result = ExploitationResult(
            sqli_confirmed=True,
            database_type="mysql",
            impact_score=75,
        )
        self.assertTrue(result.sqli_confirmed)
        self.assertEqual(result.database_type, "mysql")
        self.assertEqual(result.impact_score, 75)


class TestExploitationChainOrchestrator(unittest.TestCase):
    """Tests for ExploitationChainOrchestrator."""

    def setUp(self):
        self.orchestrator = ExploitationChainOrchestrator(safe_mode=True)

    # ------------------------------------------------------------------
    # Step 1: confirmation
    # ------------------------------------------------------------------

    def test_pre_confirmed_vuln_skips_boolean(self):
        result = ExploitationResult()
        result = self.orchestrator._step1_confirm(
            result,
            "http://example.com",
            "id",
            {"confirmed": True},
        )
        self.assertTrue(result.sqli_confirmed)
        self.assertTrue(any("pre-confirmed" in s for s in result.steps_completed))

    @patch("sql_attacker.exploitation_chain.requests.get")
    def test_step1_boolean_confirmation(self, mock_get):
        # True payload returns longer response
        mock_get.side_effect = [
            Mock(text="<html>Found user: admin</html>"),
            Mock(text="<html>No user</html>"),
        ]
        result = ExploitationResult()
        result = self.orchestrator._step1_confirm(result, "http://example.com", "id", None)
        self.assertTrue(result.sqli_confirmed)

    @patch("sql_attacker.exploitation_chain.requests.get")
    def test_step1_no_boolean_difference(self, mock_get):
        mock_get.return_value = Mock(text="<html>same response</html>")
        result = ExploitationResult()
        result = self.orchestrator._step1_confirm(result, "http://example.com", "id", None)
        self.assertFalse(result.sqli_confirmed)

    @patch("sql_attacker.exploitation_chain.requests.get")
    def test_step1_request_exception(self, mock_get):
        mock_get.side_effect = Exception("Connection refused")
        result = ExploitationResult()
        result = self.orchestrator._step1_confirm(result, "http://example.com", "id", None)
        self.assertFalse(result.sqli_confirmed)

    # ------------------------------------------------------------------
    # Step 2: fingerprinting
    # ------------------------------------------------------------------

    @patch("sql_attacker.exploitation_chain.requests.get")
    def test_step2_fingerprint_mysql(self, mock_get):
        mock_get.return_value = Mock(text="5.7.32-MySQL Community Server")
        result = ExploitationResult(sqli_confirmed=True)
        result = self.orchestrator._step2_fingerprint(result, "http://example.com", "id")
        self.assertEqual(result.database_type, "mysql")

    @patch("sql_attacker.exploitation_chain.requests.get")
    def test_step2_fingerprint_postgresql(self, mock_get):
        mock_get.return_value = Mock(text="PostgreSQL 13.4 on x86_64")
        result = ExploitationResult(sqli_confirmed=True)
        result = self.orchestrator._step2_fingerprint(result, "http://example.com", "id")
        self.assertEqual(result.database_type, "postgresql")

    @patch("sql_attacker.exploitation_chain.requests.get")
    def test_step2_fingerprint_undetermined(self, mock_get):
        mock_get.return_value = Mock(text="<html>Regular page</html>")
        result = ExploitationResult(sqli_confirmed=True)
        result = self.orchestrator._step2_fingerprint(result, "http://example.com", "id")
        self.assertEqual(result.database_type, "unknown")
        self.assertTrue(any("undetermined" in s for s in result.steps_completed))

    # ------------------------------------------------------------------
    # Step 9: impact scoring
    # ------------------------------------------------------------------

    def test_step9_impact_confirmed_sqli(self):
        result = ExploitationResult(sqli_confirmed=True)
        result = self.orchestrator._step9_impact_report(result)
        self.assertGreater(result.impact_score, 0)
        self.assertLessEqual(result.impact_score, 100)

    def test_step9_impact_with_credentials(self):
        result = ExploitationResult(
            sqli_confirmed=True,
            database_type="mysql",
            credentials_extracted=[{"username": "admin", "hash": "abc123"}],
            privilege_level="admin",
        )
        result = self.orchestrator._step9_impact_report(result)
        self.assertGreater(result.impact_score, 30)

    def test_step9_recommendations_not_empty(self):
        result = ExploitationResult(sqli_confirmed=True)
        result = self.orchestrator._step9_impact_report(result)
        self.assertGreater(len(result.recommendations), 0)

    def test_step9_file_read_recommendation(self):
        result = ExploitationResult(sqli_confirmed=True, file_read_achieved=True)
        result = self.orchestrator._step9_impact_report(result)
        self.assertTrue(any("FILE" in r or "file" in r for r in result.recommendations))

    def test_step9_impact_score_capped_at_100(self):
        result = ExploitationResult(
            sqli_confirmed=True,
            database_type="mysql",
            credentials_extracted=[{"u": "a", "hash": "b"}] * 20,
            privilege_level="admin",
            file_read_achieved=True,
            rce_achieved=True,
            persistence_established=True,
        )
        result = self.orchestrator._step9_impact_report(result)
        self.assertLessEqual(result.impact_score, 100)

    # ------------------------------------------------------------------
    # Full chain (all mocked)
    # ------------------------------------------------------------------

    @patch("sql_attacker.exploitation_chain.requests.get")
    def test_execute_full_chain_unconfirmed(self, mock_get):
        mock_get.return_value = Mock(text="same response")
        result = self.orchestrator.execute_full_chain(
            "http://example.com", "id", sqli_vulnerability=None
        )
        self.assertFalse(result.sqli_confirmed)
        self.assertGreater(len(result.recommendations), 0)

    @patch("sql_attacker.exploitation_chain.requests.get")
    def test_execute_full_chain_pre_confirmed(self, mock_get):
        mock_get.return_value = Mock(text="5.7.32-MySQL Community Server")
        result = self.orchestrator.execute_full_chain(
            "http://example.com",
            "id",
            sqli_vulnerability={"confirmed": True},
        )
        self.assertTrue(result.sqli_confirmed)
        self.assertEqual(result.database_type, "mysql")
        self.assertGreater(result.impact_score, 0)

    def test_db_fingerprint_probes_defined(self):
        probes = ExploitationChainOrchestrator._DB_FINGERPRINT_PROBES
        self.assertIn("mysql", probes)
        self.assertIn("postgresql", probes)
        self.assertIn("mssql", probes)

    def test_table_enum_payloads_defined(self):
        payloads = ExploitationChainOrchestrator._TABLE_ENUM_PAYLOADS
        self.assertIn("mysql", payloads)
        self.assertIn("postgresql", payloads)


if __name__ == "__main__":
    unittest.main()
