# Exploitation Automation Enhancement Guide

## Overview

The Megido vulnerability scanner has been enhanced with comprehensive exploitation automation capabilities across multiple vulnerability types. This guide covers the new features, usage examples, and configuration options.

## Table of Contents

1. [Features](#features)
2. [Architecture](#architecture)
3. [Quick Start](#quick-start)
4. [Detailed Configuration](#detailed-configuration)
5. [Vulnerability Types](#vulnerability-types)
6. [Examples](#examples)
7. [API Reference](#api-reference)

---

## Features

### ‚ú® Core Capabilities

- **Automated Exploitation**: Automatically exploit detected vulnerabilities with minimal configuration
- **OOB Verification**: Out-of-band callback verification for blind vulnerabilities
- **Browser Automation**: Headless browser testing with Playwright and Selenium
- **Evidence Collection**: Screenshots, DOM snapshots, network logs, and proof-of-exploit
- **Modular Design**: Easily extensible for new vulnerability types
- **Comprehensive Reporting**: Detailed reports with statistics and evidence

### üéØ Supported Vulnerability Types

1. **Cross-Site Scripting (XSS)**
   - Automatic form field injection
   - Query parameter testing
   - Headless browser automation
   - OOB callback verification
   - DOM-based XSS detection
   - Context-aware payload generation

2. **Information Disclosure**
   - Automatic sensitive file/path testing (60+ paths)
   - Content verification
   - Response analysis
   - Stack trace detection

3. **Security Misconfiguration**
   - Comprehensive header checking (10+ headers)
   - CSP policy analysis and exploitation
   - HSTS weakness detection
   - Browser-based exploit testing
   - Screenshot evidence

4. **XML External Entity (XXE)**
   - Entity injection with file extraction
   - Out-of-band XXE with callback verification
   - Blind XXE techniques
   - DTD-based attacks
   - Multiple OS support (Linux/Windows)

5. **Mixed Content**
   - HTTP resource detection on HTTPS pages
   - Risk classification (critical/high/medium/low)
   - Browser verification
   - Console log monitoring
   - Exploitability testing

---

## Architecture

### Component Overview

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ     ExploitationAutomationController                ‚îÇ
‚îÇ  (Central orchestrator for all exploitations)       ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                ‚îÇ
                ‚îú‚îÄ‚îÄ‚îÄ ExploitationConfig
                ‚îÇ    (Configuration and validation)
                ‚îÇ
                ‚îú‚îÄ‚îÄ‚îÄ Plugin System
                ‚îÇ    ‚îÇ
                ‚îÇ    ‚îú‚îÄ‚îÄ XSS Plugin (existing, enhanced)
                ‚îÇ    ‚îú‚îÄ‚îÄ XXE Plugin (enhanced with OOB)
                ‚îÇ    ‚îú‚îÄ‚îÄ Info Disclosure Plugin (existing)
                ‚îÇ    ‚îú‚îÄ‚îÄ Security Misconfiguration Plugin (NEW)
                ‚îÇ    ‚îî‚îÄ‚îÄ Mixed Content Plugin (NEW)
                ‚îÇ
                ‚îú‚îÄ‚îÄ‚îÄ OOB Exploitation Framework
                ‚îÇ    (Callback generation and verification)
                ‚îÇ
                ‚îú‚îÄ‚îÄ‚îÄ Browser Automation
                ‚îÇ    ‚îú‚îÄ‚îÄ Playwright support
                ‚îÇ    ‚îî‚îÄ‚îÄ Selenium support
                ‚îÇ
                ‚îî‚îÄ‚îÄ‚îÄ Reporting
                     (Statistics and evidence collection)
```

### Key Classes

- **`ExploitationAutomationController`**: Central controller that routes exploitation requests to appropriate plugins
- **`ExploitationConfig`**: Configuration dataclass with validation
- **`ExploitationResult`**: Standardized result format for all exploitations
- **Exploit Plugins**: Modular plugins for each vulnerability type

---

## Quick Start

### Basic Usage

```python
from scanner.plugins.exploitation_automation_controller import (
    ExploitationAutomationController,
    ExploitationConfig
)

# Initialize with default configuration
controller = ExploitationAutomationController()

# Exploit XSS vulnerability
result = controller.exploit_xss(
    target_url='http://example.com/search',
    vulnerability_data={'parameter': 'q', 'method': 'GET'}
)

if result.success:
    print(f"XSS Exploited! Verified: {result.verified}")
    print(f"Evidence: {result.evidence}")
```

### With Custom Configuration

```python
# Create custom configuration
config = ExploitationConfig(
    # Enable/disable features
    enable_xss_exploitation=True,
    enable_info_disclosure_exploitation=True,
    enable_security_misconfiguration_exploitation=True,
    enable_xxe_exploitation=True,
    enable_mixed_content_detection=True,
    
    # OOB configuration
    oob_endpoint_base_url='https://your-callback-server.com',
    oob_timeout=30,
    
    # Browser automation
    browser_automation_enabled=True,
    browser_automation_engine='playwright',  # or 'selenium'
    browser_headless=True,
    
    # Evidence collection
    capture_screenshots=True,
    capture_dom_snapshots=True,
    
    # Timeouts
    exploitation_timeout=30,
    max_exploitation_attempts=3,
)

# Initialize controller
controller = ExploitationAutomationController(config)
```

### Using ngrok for OOB Callbacks

```python
config = ExploitationConfig(
    oob_use_ngrok=True,  # Automatically setup ngrok tunnel
    oob_timeout=30,
)

controller = ExploitationAutomationController(config)

# OOB verification will use ngrok callback URL
result = controller.exploit_xss(target_url, vulnerability_data)
```

---

## Detailed Configuration

### ExploitationConfig Options

#### Feature Toggles

| Option | Type | Default | Description |
|--------|------|---------|-------------|
| `enable_xss_exploitation` | bool | True | Enable XSS exploitation |
| `enable_info_disclosure_exploitation` | bool | True | Enable info disclosure testing |
| `enable_security_misconfiguration_exploitation` | bool | True | Enable security misconfiguration testing |
| `enable_xxe_exploitation` | bool | True | Enable XXE exploitation |
| `enable_mixed_content_detection` | bool | True | Enable mixed content detection |

#### OOB Configuration

| Option | Type | Default | Description |
|--------|------|---------|-------------|
| `oob_endpoint_base_url` | str | None | Base URL for OOB callback server |
| `oob_use_ngrok` | bool | False | Use ngrok for automatic tunnel setup |
| `oob_timeout` | int | 30 | Timeout (seconds) for OOB callback verification |

#### Browser Automation

| Option | Type | Default | Description |
|--------|------|---------|-------------|
| `browser_automation_enabled` | bool | True | Enable headless browser automation |
| `browser_automation_engine` | str | 'playwright' | Browser engine ('playwright' or 'selenium') |
| `browser_headless` | bool | True | Run browser in headless mode |

#### Exploitation Parameters

| Option | Type | Default | Description |
|--------|------|---------|-------------|
| `max_exploitation_attempts` | int | 3 | Maximum exploitation attempts per finding |
| `exploitation_timeout` | int | 30 | Timeout (seconds) per exploitation attempt |

#### Evidence Collection

| Option | Type | Default | Description |
|--------|------|---------|-------------|
| `capture_screenshots` | bool | True | Capture screenshots of successful exploits |
| `capture_dom_snapshots` | bool | True | Capture DOM snapshots for verification |
| `capture_network_logs` | bool | False | Capture network logs during exploitation |

#### Logging

| Option | Type | Default | Description |
|--------|------|---------|-------------|
| `verbose_logging` | bool | False | Enable verbose logging for debugging |

---

## Vulnerability Types

### 1. Cross-Site Scripting (XSS)

#### Features

- Automatic form field injection with multiple payload variants
- Query parameter testing
- Headless browser automation with JavaScript execution monitoring
- OOB callback verification for blind XSS
- Context-aware payload generation (HTML, JavaScript, attribute, etc.)
- DOM-based XSS detection
- Screenshot and evidence collection

#### Usage

```python
result = controller.exploit_xss(
    target_url='http://example.com/search',
    vulnerability_data={
        'parameter': 'q',
        'method': 'GET',
        'context': 'html',  # or 'javascript', 'attribute', etc.
        'injection_point': 'parameter',
    }
)

if result.success:
    print(f"XSS Verified: {result.verified}")
    if result.verified:
        print("OOB callback received!")
    print(f"Evidence: {result.evidence}")
    print(f"Proof: {result.proof_of_exploit}")
```

#### Evidence Collected

- Payload that triggered XSS
- Screenshot of executed payload
- Console logs
- DOM snapshot
- OOB callback data (if verified)

---

### 2. Information Disclosure

#### Features

- 60+ sensitive file/path patterns
- Automatic content verification
- Response analysis for stack traces
- Configuration file extraction
- Backup file detection

#### Tested Paths

- Environment files: `.env`, `.env.local`, `.env.production`
- Config files: `config.php`, `wp-config.php`, `database.php`
- Version control: `.git/config`, `.svn/entries`
- Web server: `.htaccess`, `nginx.conf`, `apache.conf`
- Backups: `backup.sql`, `database.sql`, `dump.sql`
- And 40+ more...

#### Usage

```python
result = controller.exploit_info_disclosure(
    target_url='http://example.com',
    vulnerability_data={
        'paths': ['.env', 'config.php', '.git/config'],
    }
)

if result.success:
    for file_path, content in result.proof_of_exploit.items():
        print(f"Extracted {file_path}:")
        print(content[:200])  # First 200 chars
```

---

### 3. Security Misconfiguration

#### Features

- Comprehensive security header checking (10+ headers)
- CSP policy analysis with weakness detection
- HSTS configuration validation
- Browser-based CSP bypass testing
- Screenshot evidence of successful exploits

#### Checked Headers

- Content-Security-Policy
- Strict-Transport-Security
- X-Frame-Options
- X-Content-Type-Options
- Referrer-Policy
- Permissions-Policy
- Cross-Origin-Opener-Policy (COOP)
- Cross-Origin-Embedder-Policy (COEP)
- Cross-Origin-Resource-Policy (CORP)
- X-XSS-Protection

#### CSP Bypass Techniques Tested

- `unsafe-inline` exploitation
- `unsafe-eval` exploitation
- Wildcard domain bypass

#### Usage

```python
result = controller.exploit_security_misconfiguration(
    target_url='http://example.com',
    vulnerability_data={
        'headers_to_check': ['CSP', 'HSTS', 'X-Frame-Options'],
    }
)

if result.success:
    headers = result.evidence.get('headers', {})
    print(f"Missing headers: {headers.get('missing_headers')}")
    print(f"Weak headers: {headers.get('weak_headers')}")
    
    if result.verified:
        print("CSP bypass successful!")
        print(f"Exploit method: {result.proof_of_exploit}")
```

---

### 4. XML External Entity (XXE)

#### Features

- XML entity injection with file extraction
- Out-of-band XXE with callback verification
- Blind XXE techniques
- DTD-based attacks
- Support for Linux and Windows file paths
- Base64 encoding for binary files

#### Usage

```python
result = controller.exploit_xxe(
    target_url='http://example.com/xml',
    vulnerability_data={
        'endpoint': '/xml',
        'method': 'POST',
    }
)

if result.success:
    if result.verified:
        print("XXE verified via OOB callback!")
        print(f"Callback data: {result.evidence.get('oob_data')}")
    
    if 'extracted_files' in result:
        for file_path, content in result['extracted_files'].items():
            print(f"Extracted {file_path}:")
            print(content)
```

#### With OOB Verification

```python
config = ExploitationConfig(
    oob_endpoint_base_url='https://callback.example.com',
    oob_timeout=30,
)

controller = ExploitationAutomationController(config)

result = controller.exploit_xxe(
    target_url='http://example.com/xml',
    vulnerability_data={}
)

# Result will be verified=True if OOB callback received
```

---

### 5. Mixed Content Detection

#### Features

- Detection of HTTP resources on HTTPS pages
- Risk classification (critical/high/medium/low)
- Browser-based verification
- Console log monitoring for security warnings
- Detailed resource inventory

#### Resource Types Detected

- **Critical Risk**: Scripts, forms
- **High Risk**: Stylesheets, iframes, plugins
- **Medium Risk**: Images, videos, audio
- **Low Risk**: Other passive content

#### Usage

```python
result = controller.detect_mixed_content(
    target_url='https://example.com'
)

if result.success:
    resources = result.proof_of_exploit.get('html_analysis', {})
    
    for resource_type, resource_list in resources.items():
        print(f"{resource_type}: {len(resource_list)} resources")
        for resource in resource_list:
            print(f"  - {resource['url']} (risk: {resource['risk']})")
    
    if result.verified:
        print("Mixed content verified by browser!")
```

---

## Examples

### Complete Scan with All Features

```python
from scanner.plugins.exploitation_automation_controller import (
    ExploitationAutomationController,
    ExploitationConfig
)

# Configure all features
config = ExploitationConfig(
    enable_xss_exploitation=True,
    enable_info_disclosure_exploitation=True,
    enable_security_misconfiguration_exploitation=True,
    enable_xxe_exploitation=True,
    enable_mixed_content_detection=True,
    
    oob_endpoint_base_url='https://your-callback-server.com',
    oob_timeout=30,
    
    browser_automation_enabled=True,
    browser_automation_engine='playwright',
    browser_headless=True,
    
    capture_screenshots=True,
    capture_dom_snapshots=True,
    
    exploitation_timeout=30,
    max_exploitation_attempts=3,
    verbose_logging=True,
)

# Initialize controller
controller = ExploitationAutomationController(config)

# Exploit different vulnerability types
results = []

# XSS
xss_result = controller.exploit_xss(
    'http://example.com/search',
    {'parameter': 'q', 'method': 'GET'}
)
results.append(xss_result)

# Info Disclosure
info_result = controller.exploit_info_disclosure(
    'http://example.com',
    {'paths': ['.env', 'config.php']}
)
results.append(info_result)

# Security Misconfiguration
sec_result = controller.exploit_security_misconfiguration(
    'http://example.com',
    {}
)
results.append(sec_result)

# XXE
xxe_result = controller.exploit_xxe(
    'http://example.com/xml',
    {'endpoint': '/xml', 'method': 'POST'}
)
results.append(xxe_result)

# Mixed Content
mixed_result = controller.detect_mixed_content(
    'https://example.com'
)
results.append(mixed_result)

# Generate comprehensive report
report = controller.generate_report(results)

print(f"Total Exploits: {report['summary']['total_exploits']}")
print(f"Successful: {report['summary']['successful']}")
print(f"Verified: {report['summary']['verified']}")
print(f"Failed: {report['summary']['failed']}")

# Save report
import json
with open('exploitation_report.json', 'w') as f:
    json.dump(report, f, indent=2)
```

### Using the Demo Script

The included demo script showcases all features:

```bash
# Run with default target
python demo_exploitation_automation.py

# Run with custom target
python demo_exploitation_automation.py http://testphp.vulnweb.com

# Output will include:
# - Individual vulnerability exploitation attempts
# - Evidence and proof-of-exploit for each
# - Summary report with statistics
# - JSON report file: exploitation_automation_report.json
```

---

## API Reference

### ExploitationAutomationController

#### `__init__(config: Optional[ExploitationConfig] = None)`

Initialize the controller with optional configuration.

**Parameters:**
- `config`: ExploitationConfig instance (optional, uses defaults if None)

**Raises:**
- `ValueError`: If configuration is invalid

---

#### `exploit_xss(target_url: str, vulnerability_data: Dict[str, Any]) -> ExploitationResult`

Exploit XSS vulnerability with automation.

**Parameters:**
- `target_url`: Target URL with XSS vulnerability
- `vulnerability_data`: Dictionary with:
  - `parameter`: Vulnerable parameter name
  - `method`: HTTP method (GET/POST)
  - `context`: Injection context (html/javascript/attribute)
  - `injection_point`: Where to inject (parameter/header/cookie)

**Returns:**
- `ExploitationResult` with success status, evidence, and proof

---

#### `exploit_info_disclosure(target_url: str, vulnerability_data: Dict[str, Any]) -> ExploitationResult`

Exploit information disclosure vulnerabilities.

**Parameters:**
- `target_url`: Base target URL
- `vulnerability_data`: Dictionary with:
  - `paths`: List of specific paths to test (optional)

**Returns:**
- `ExploitationResult` with discovered files/data

---

#### `exploit_security_misconfiguration(target_url: str, vulnerability_data: Dict[str, Any]) -> ExploitationResult`

Test and exploit security misconfigurations.

**Parameters:**
- `target_url`: Target URL
- `vulnerability_data`: Dictionary with:
  - `headers_to_check`: List of specific headers (optional)

**Returns:**
- `ExploitationResult` with header analysis and exploitation evidence

---

#### `exploit_xxe(target_url: str, vulnerability_data: Dict[str, Any]) -> ExploitationResult`

Exploit XXE vulnerabilities with OOB verification.

**Parameters:**
- `target_url`: Target URL with XXE vulnerability
- `vulnerability_data`: Dictionary with:
  - `endpoint`: XML endpoint path
  - `method`: HTTP method

**Returns:**
- `ExploitationResult` with extracted files or OOB confirmation

---

#### `detect_mixed_content(target_url: str) -> ExploitationResult`

Detect and test mixed content vulnerabilities.

**Parameters:**
- `target_url`: HTTPS URL to check for mixed content

**Returns:**
- `ExploitationResult` with detected HTTP resources

---

#### `exploit_vulnerability(vulnerability_type: str, target_url: str, vulnerability_data: Dict[str, Any]) -> ExploitationResult`

Generic method to exploit any vulnerability type.

**Parameters:**
- `vulnerability_type`: Type (xss/xxe/info_disclosure/security_misconfiguration/mixed_content)
- `target_url`: Target URL
- `vulnerability_data`: Vulnerability-specific data

**Returns:**
- `ExploitationResult`

---

#### `get_statistics() -> Dict[str, Any]`

Get exploitation statistics.

**Returns:**
- Dictionary with statistics:
  - `total_attempts`: Total exploitation attempts
  - `successful_exploits`: Successful exploitations
  - `verified_exploits`: Verified via OOB or browser
  - `failed_attempts`: Failed attempts
  - `by_type`: Statistics per vulnerability type

---

#### `generate_report(results: List[ExploitationResult]) -> Dict[str, Any]`

Generate comprehensive exploitation report.

**Parameters:**
- `results`: List of ExploitationResult objects

**Returns:**
- Dictionary with:
  - `summary`: Overall statistics
  - `by_type`: Statistics per vulnerability type
  - `results`: Detailed results for each exploitation
  - `statistics`: Controller statistics
  - `generated_at`: Timestamp

---

## Testing

Run the comprehensive test suite:

```bash
# Run all tests
python -m unittest scanner.tests_exploitation_automation -v

# Run specific test class
python -m unittest scanner.tests_exploitation_automation.TestExploitationAutomationController -v

# Run specific test
python -m unittest scanner.tests_exploitation_automation.TestExploitationAutomationController.test_exploit_xss_success -v
```

Test coverage:
- Configuration validation
- Controller initialization
- All exploitation methods
- Plugin integration
- Report generation
- Error handling

---

## Troubleshooting

### Common Issues

#### Browser Automation Not Working

**Issue**: Browser automation fails or is disabled

**Solutions**:
1. Install Playwright: `pip install playwright && playwright install chromium`
2. Install Selenium: `pip install selenium webdriver-manager`
3. Check `browser_automation_enabled` in config
4. Verify browser engine is installed

#### OOB Callbacks Not Received

**Issue**: OOB verification always fails

**Solutions**:
1. Ensure callback server is accessible from target
2. Increase `oob_timeout` value
3. Check firewall/network settings
4. Use ngrok: Set `oob_use_ngrok=True`
5. Verify callback URL is valid

#### Missing Dependencies

**Issue**: Features are disabled due to missing libraries

**Solutions**:
```bash
pip install requests beautifulsoup4 lxml
pip install playwright selenium
pip install Pillow fake-useragent
```

---

## Security Considerations

‚ö†Ô∏è **Warning**: This tool performs active exploitation of vulnerabilities. Only use on systems you own or have explicit permission to test.

### Best Practices

1. **Authorization**: Always obtain written permission before testing
2. **Scope**: Clearly define testing scope and boundaries
3. **Rate Limiting**: Use timeouts and delays to avoid DoS
4. **Data Handling**: Securely handle any extracted sensitive data
5. **Logging**: Enable verbose logging for audit trails
6. **Clean Up**: Remove any test artifacts after completion

---

## Contributing

To add support for a new vulnerability type:

1. Create a new plugin in `scanner/plugins/exploits/`
2. Inherit from `ExploitPlugin` base class
3. Implement required methods:
   - `vulnerability_type` property
   - `generate_payloads()`
   - `execute_attack()`
4. Add exploitation method to `ExploitationAutomationController`
5. Add tests in `tests_exploitation_automation.py`
6. Update documentation

---

## License

This enhancement is part of the Megido Security Testing Platform.

---

## Support

For issues, questions, or contributions:
- Create an issue on GitHub
- Review existing documentation
- Check demo scripts for examples
