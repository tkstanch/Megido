# Exploit Enhancement Architecture

## System Architecture

```
┌─────────────────────────────────────────────────────────────────────┐
│                        Exploit Orchestration                         │
│                    (exploit_integration.py)                          │
│                                                                       │
│  ┌──────────────────────────────────────────────────────────────┐  │
│  │  exploit_vulnerability(vuln, intensity='medium')              │  │
│  │                                                                │  │
│  │  1. Apply ExploitConfig based on intensity                    │  │
│  │  2. Get plugin from registry                                  │  │
│  │  3. Execute plugin.execute_attack()                           │  │
│  │  4. If fails → Try context-aware attack                       │  │
│  │  5. If fails → Try LastResortExploitPlugin                    │  │
│  │  6. Merge all partial evidence                                │  │
│  │  7. Return comprehensive result                               │  │
│  └──────────────────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────────────┘
                                    │
                    ┌───────────────┼───────────────┐
                    ↓               ↓               ↓
    ┌──────────────────┐ ┌──────────────────┐ ┌──────────────────┐
    │  ExploitConfig   │ │  Plugin Registry │ │  Evidence Store  │
    │                  │ │                  │ │                  │
    │ • Intensity      │ │ • Load Plugins  │ │ • Partial Evid.  │
    │ • Retries        │ │ • Get by Type   │ │ • Confidence     │
    │ • Timeouts       │ │ • Validate      │ │ • Merge Results  │
    │ • Parallel       │ │                  │ │                  │
    └──────────────────┘ └──────────────────┘ └──────────────────┘
                                    │
                    ┌───────────────┼───────────────┐
                    ↓               ↓               ↓
    ┌──────────────────┐ ┌──────────────────┐ ┌──────────────────┐
    │  Exploit Plugin  │ │  Exploit Plugin  │ │  Last Resort     │
    │   (e.g. LFI)     │ │   (e.g. RFI)     │ │     Plugin       │
    │                  │ │                  │ │                  │
    │ ┌──────────────┐ │ │ ┌──────────────┐ │ │ ┌──────────────┐ │
    │ │ExploitPlugin │ │ │ │ExploitPlugin │ │ │ │ExploitPlugin │ │
    │ └──────────────┘ │ │ └──────────────┘ │ │ └──────────────┘ │
    │ ┌──────────────┐ │ │ ┌──────────────┐ │ │ ┌──────────────┐ │
    │ │  Adaptive    │ │ │ │  Adaptive    │ │ │ │  Adaptive    │ │
    │ │    Mixin     │ │ │ │    Mixin     │ │ │ │    Mixin     │ │
    │ └──────────────┘ │ │ └──────────────┘ │ │ └──────────────┘ │
    └──────────────────┘ └──────────────────┘ └──────────────────┘
                                    │
                    ┌───────────────┼───────────────┐
                    ↓               ↓               ↓
    ┌──────────────────┐ ┌──────────────────┐ ┌──────────────────┐
    │ PayloadMutator   │ │ Adaptive Mixin   │ │  HTTP Client     │
    │                  │ │                  │ │                  │
    │ • Case Var.      │ │ • Retry Logic    │ │ • GET/POST/PUT   │
    │ • Encoding       │ │ • Multi-Method   │ │ • User-Agents    │
    │ • Extensions     │ │ • UA Rotation    │ │ • Custom Headers │
    │ • Traversal      │ │ • Error Detect   │ │ • Timeout Mgmt   │
    │ • XXE Entities   │ │ • Parallel Exec  │ │ • SSL Handling   │
    └──────────────────┘ └──────────────────┘ └──────────────────┘
```

## Execution Flow

### 1. Basic Exploitation Flow

```
User Request
    │
    ↓
ExploitConfig (intensity='high')
    │
    ├─→ max_retries: 3
    ├─→ timeout: 15
    ├─→ parallel_execution: true
    ├─→ enable_fallback: true
    └─→ enable_mutations: true
    │
    ↓
Plugin.execute_attack()
    │
    ├─→ generate_payloads() ──→ PayloadMutator
    │                               │
    │                               ├─→ Base payloads
    │                               ├─→ + Case variations
    │                               ├─→ + Encoding variations
    │                               └─→ + Extension variations
    │
    ├─→ _try_multiple_methods() ──→ AdaptiveMixin
    │                                   │
    │                                   ├─→ For each HTTP method:
    │                                   │   ├─→ GET with params
    │                                   │   ├─→ POST with data
    │                                   │   └─→ PUT if enabled
    │                                   │
    │                                   ├─→ For each User-Agent:
    │                                   │   ├─→ Rotate UA strings
    │                                   │   └─→ Custom headers
    │                                   │
    │                                   └─→ With retry strategy:
    │                                       ├─→ Attempt 1
    │                                       ├─→ Detect transient error
    │                                       ├─→ Backoff 0.5s
    │                                       ├─→ Attempt 2
    │                                       └─→ ...
    │
    └─→ _detect_error_evidence()
            │
            ├─→ Scan response for errors
            ├─→ Match regex patterns
            ├─→ Check status codes
            └─→ Return partial evidence
    │
    ↓
Result
```

### 2. Fallback Chain

```
Primary Plugin Fails
    │
    ↓
Context-Aware Attack
    │
    ├─→ Check for 'header' in description → Header Injection
    ├─→ Check for 'input' in description → XSS Attack
    └─→ Check for 'form' in description → XSS Attack
    │
    ↓ (if still fails)
    │
LastResortExploitPlugin
    │
    ├─→ Strategy 1: File Brute-forcing
    │   ├─→ Try 50+ sensitive files
    │   ├─→ With mutations (bak, old, etc.)
    │   └─→ Detect 200 OK responses
    │
    ├─→ Strategy 2: Directory Discovery
    │   ├─→ Try 20+ common directories
    │   ├─→ With/without trailing slash
    │   └─→ Detect 200/403 responses
    │
    ├─→ Strategy 3: Auth Bypass
    │   ├─→ SQL injection payloads
    │   ├─→ Boolean bypass
    │   └─→ NoSQL injection
    │
    └─→ Strategy 4: Default Credentials
        ├─→ Top 10 user:pass combos
        ├─→ Check success indicators
        └─→ Detect redirects
    │
    ↓
Merge All Partial Evidence
    │
    ↓
Final Result with Confidence Level
```

### 3. Parallel Execution (High/Aggressive Intensity)

```
Payload List [P1, P2, P3, ..., P50]
    │
    ↓
ThreadPoolExecutor (workers=5)
    │
    ├─→ Worker 1: P1, P6, P11, P16, ...
    ├─→ Worker 2: P2, P7, P12, P17, ...
    ├─→ Worker 3: P3, P8, P13, P18, ...
    ├─→ Worker 4: P4, P9, P14, P19, ...
    └─→ Worker 5: P5, P10, P15, P20, ...
    │
    ↓
First Success → Cancel Others
    │
    ↓
Result (faster exploitation)
```

## Data Flow

### Configuration Data Flow

```
User Input (intensity='high')
    │
    ↓
ExploitConfig
    │
    ├─→ INTENSITY_PRESETS['high']
    │   {
    │     max_retries: 3,
    │     timeout: 15,
    │     parallel_execution: true,
    │     enable_fallback: true,
    │     max_payloads_per_plugin: 50,
    │     enable_mutations: true,
    │     http_methods: ['GET', 'POST'],
    │     user_agent_rotation: true,
    │     max_workers: 3
    │   }
    │
    ├─→ Apply custom overrides (if any)
    │
    └─→ Add common defaults
        {
          verify_ssl: false,
          capture_visual_proof: true,
          detect_partial_evidence: true,
          log_failed_attempts: true
        }
    │
    ↓
Plugin Configuration
```

### Evidence Data Flow

```
HTTP Response
    │
    ├─→ Status Code (401/403/500)
    ├─→ Headers
    └─→ Body
    │
    ↓
_detect_error_evidence()
    │
    ├─→ Pattern Matching
    │   ├─→ PHP errors: "Fatal error.*in.*on line"
    │   ├─→ MySQL errors: "mysql_.*error"
    │   ├─→ Stack traces: "Traceback.*"
    │   └─→ Access denied: "Access denied for user"
    │
    ├─→ Status Code Analysis
    │   ├─→ 401/403: Check for info leakage
    │   └─→ 500+: Check for verbose errors
    │
    └─→ Generate Evidence
        {
          has_evidence: true,
          description: "PHP error detected...",
          status_code: 500,
          pattern_matched: "Fatal error"
        }
    │
    ↓
Partial Evidence List
    │
    ├─→ Evidence from primary plugin
    ├─→ Evidence from context-aware
    └─→ Evidence from last resort
    │
    ↓
_merge_partial_evidence()
    │
    └─→ Combined Evidence List
    │
    ↓
Result with Confidence Level
```

## Component Interactions

### Plugin Inheritance

```
ExploitPlugin (Abstract Base)
    ↑
    │ (inherits)
    │
    ├─→ LFIPlugin
    │   ├─→ vulnerability_type = 'lfi'
    │   ├─→ SENSITIVE_FILES (40+)
    │   ├─→ TRAVERSAL_PAYLOADS (25+)
    │   └─→ execute_attack()
    │
    └─→ AdaptiveExploitMixin
        ├─→ _get_retry_session()
        ├─→ _is_transient_error()
        ├─→ _detect_error_evidence()
        ├─→ _adaptive_request()
        ├─→ _try_multiple_methods()
        └─→ _parallel_payload_execution()

Final Plugin: LFIPlugin + AdaptiveMixin
    ↓
Has all adaptive capabilities + specific LFI logic
```

### Payload Generation

```
Plugin.generate_payloads(context)
    │
    ├─→ Base Payloads
    │   (plugin-specific, e.g., file paths)
    │
    └─→ PayloadMutator.mutate_payload_list()
        │
        ├─→ Case Variations
        │   config.php → CONFIG.PHP, Config.Php
        │
        ├─→ Encoding Variations
        │   /etc/passwd → %2fetc%2fpasswd
        │
        ├─→ Extension Variations
        │   config.php → config.php.bak, config.old
        │
        └─→ Path Variations
            /etc/passwd → etc/passwd, ./etc/passwd
    │
    ↓
Expanded Payload List (3-10x original)
```

## State Machine

### Exploitation States

```
┌─────────────────┐
│  NOT_ATTEMPTED  │
└────────┬────────┘
         │ exploit_vulnerability()
         ↓
┌─────────────────┐
│   IN_PROGRESS   │────────┐
└────────┬────────┘        │
         │                 │ Timeout/Error
         │ Success         ↓
         ↓          ┌─────────────────┐
┌─────────────────┐│     FAILED      │
│    EXPLOITED    ││  (full failure) │
│   (success)     │└─────────────────┘
└─────────────────┘        │
         │                 │ Has partial evidence
         │                 ↓
         │          ┌─────────────────┐
         │          │ PARTIAL_EXPLOIT │
         │          │  (confidence:   │
         │          │   partial/low)  │
         │          └─────────────────┘
         │
         ↓
Result Stored in Database
```

## Performance Characteristics

### Intensity vs. Performance

```
Intensity:  Low      Medium    High      Aggressive
            │         │         │         │
Payloads:   10        30        50        100
            │         │         │         │
Time:       ████      ████████  ████████████  ████████████████
            5-10s     15-30s    30-60s    60-120s
            │         │         │         │
Success:    ████      ██████    ████████  ██████████
            baseline  +25-40%   +40-60%   +50-75%
            │         │         │         │
Parallel:   No        No        Yes       Yes
            │         │         │         │
Fallback:   No        Yes       Yes       Yes
```

### Resource Usage

```
            CPU     Memory    Network
Low:        ▓       ▓         ▓▓
Medium:     ▓▓      ▓▓        ▓▓▓
High:       ▓▓▓▓    ▓▓▓       ▓▓▓▓
Aggressive: ▓▓▓▓▓   ▓▓▓▓      ▓▓▓▓▓
```

## Key Design Decisions

### 1. Mixin Pattern for Adaptivity
- **Why**: Allows adding adaptive capabilities to any plugin without changing base class
- **Benefit**: Backward compatible, plugins can opt-in to features
- **Trade-off**: Multiple inheritance requires careful method resolution

### 2. Separate Mutator Module
- **Why**: Centralized mutation logic, reusable across plugins
- **Benefit**: Consistent mutations, easier to test and maintain
- **Trade-off**: Additional dependency between modules

### 3. Intensity Presets
- **Why**: Balance between usability and flexibility
- **Benefit**: Users can start with presets, tune if needed
- **Trade-off**: Presets may not fit all use cases

### 4. Partial Evidence Collection
- **Why**: Extract value even from failed exploitations
- **Benefit**: Lower false negative rate, better vulnerability assessment
- **Trade-off**: More data to process and store

### 5. Automatic Fallback Chain
- **Why**: Maximize exploitation success without manual intervention
- **Benefit**: "Just works" for most scenarios
- **Trade-off**: Increased execution time, potential for noise

## Extension Points

### Adding a New Plugin

```python
from scanner.plugins.exploit_plugin import ExploitPlugin
from scanner.plugins.adaptive_exploit_mixin import AdaptiveExploitMixin

class MyPlugin(ExploitPlugin, AdaptiveExploitMixin):
    @property
    def vulnerability_type(self):
        return 'my_vuln_type'
    
    def generate_payloads(self, context=None):
        # Generate base payloads
        base = ['payload1', 'payload2']
        
        # Apply mutations if needed
        from scanner.plugins.payload_mutator import PayloadMutator
        return PayloadMutator.mutate_payload_list(base)
    
    def execute_attack(self, target_url, vuln_data, config=None):
        # Setup adaptive config
        config = config or {}
        config.update(self.get_adaptive_config_defaults())
        
        # Use adaptive methods
        result = self._try_multiple_methods(
            target_url,
            payload,
            parameter,
            config,
            verify_function
        )
        
        return result
```

### Adding a New Mutation Type

```python
class PayloadMutator:
    @staticmethod
    def generate_my_mutation(payload: str) -> List[str]:
        """Add your custom mutation logic"""
        variations = [payload]
        # ... mutation logic ...
        return variations
    
    @staticmethod
    def mutate_payload_list(base_payloads, mutation_types=None):
        # Add 'my_mutation' to available types
        if 'my_mutation' in mutation_types:
            all_mutations.update(
                PayloadMutator.generate_my_mutation(payload)
            )
```

### Adding a New Intensity Level

```python
class ExploitConfig:
    INTENSITY_PRESETS = {
        'custom_level': {
            'max_retries': 10,
            'timeout': 60,
            # ... your settings ...
        }
    }
```

## Monitoring and Debugging

### Logging Points

```
[INFO] Attempting LFI exploitation on http://example.com
[DEBUG] Generated 50 payload variations
[DEBUG] Trying payload: ../../etc/passwd
[DEBUG] Method GET, User-Agent: Mozilla/5.0...
[DEBUG] Response status: 200, length: 1234
[INFO] Successfully extracted: /etc/passwd
[DEBUG] Captured visual proof
[INFO] Exploitation successful in 12.3s
```

### Metrics to Track

- Exploitation attempts per vulnerability
- Success rate per plugin
- Average time per intensity level
- Partial evidence hit rate
- Fallback invocation rate
- Payload efficiency (successes per payload tested)

## Security Considerations

1. **Rate Limiting**: Respect target rate limits, implement backoff
2. **SSL Verification**: Configurable, default to False for testing
3. **Credential Storage**: Never log or store credentials in plaintext
4. **Evidence Handling**: Sanitize evidence before storage
5. **Network Isolation**: Consider running in isolated environment
6. **Authorization**: Only exploit with explicit permission
