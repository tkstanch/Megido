"""
Professional report generation for the malware analyser application.

STUB IMPLEMENTATION - All data-access and rendering logic is demonstration
code only.  No actual malware is analysed or created.
See models.py for full legal/ethical notices.

Classes
-------
ExecutiveSummaryGenerator     – natural-language summary of findings
ATTACKNavigatorGenerator      – MITRE ATT&CK Navigator JSON layer
IOCTableGenerator             – formatted IOC table
BehavioralTimelineGenerator   – chronological behaviour timeline
PDFReportGenerator            – PDF reports via reportlab (HTML fallback)
HTMLReportGenerator           – rich HTML reports with collapsible sections
ComparisonReportGenerator     – side-by-side sample comparison
ReportGenerator               – top-level orchestrator
"""

from __future__ import annotations

import json
import logging
import textwrap
import uuid
from datetime import datetime
from typing import Any, Dict, List, Optional

from django.conf import settings

logger = logging.getLogger(__name__)

# ---------------------------------------------------------------------------
# Optional dependency: reportlab
# ---------------------------------------------------------------------------
try:
    from reportlab.lib import colors
    from reportlab.lib.pagesizes import A4
    from reportlab.lib.styles import getSampleStyleSheet
    from reportlab.lib.units import cm
    from reportlab.platypus import (
        Paragraph,
        SimpleDocTemplate,
        Spacer,
        Table,
        TableStyle,
    )

    _REPORTLAB_AVAILABLE = True
    logger.debug("reportlab is available; PDF generation enabled.")
except ImportError:
    _REPORTLAB_AVAILABLE = False
    logger.info("reportlab not installed; PDF reports will fall back to HTML.")


# =============================================================================
# Helpers
# =============================================================================

def _now_iso() -> str:
    return datetime.utcnow().strftime("%Y-%m-%dT%H:%M:%SZ")


def _threat_label(threat_level: str) -> str:
    mapping = {
        "critical": "CRITICAL",
        "high": "HIGH",
        "medium": "MEDIUM",
        "low": "LOW",
        "none": "CLEAN",
    }
    return mapping.get(threat_level.lower(), threat_level.upper())


# =============================================================================
# ExecutiveSummaryGenerator
# =============================================================================

class ExecutiveSummaryGenerator:
    """
    Generate a natural-language executive summary of analysis findings.

    Parameters
    ----------
    scan_result :
        A :class:`malware_analyser.models.ScanResult` instance or any dict
        with equivalent keys.
    """

    def __init__(self, scan_result: Any) -> None:
        self.scan_result = scan_result

    def generate(self) -> str:
        """
        Return a multi-paragraph plain-text executive summary.

        Returns
        -------
        str
            Formatted executive summary text.
        """
        try:
            is_malicious = getattr(self.scan_result, "is_malicious", False)
            threat_level = getattr(self.scan_result, "threat_level", "none")
            detected = getattr(self.scan_result, "detected_malware", "") or "N/A"
            filename = getattr(self.scan_result.file, "original_filename", "unknown file")
        except AttributeError:
            # dict-like fallback
            is_malicious = self.scan_result.get("is_malicious", False)
            threat_level = self.scan_result.get("threat_level", "none")
            detected = self.scan_result.get("detected_malware") or "N/A"
            filename = self.scan_result.get("filename", "unknown file")

        verdict = "MALICIOUS" if is_malicious else "CLEAN"
        label = _threat_label(threat_level)

        summary = textwrap.dedent(
            f"""\
            Executive Summary
            =================
            File analysed : {filename}
            Verdict       : {verdict}
            Threat level  : {label}
            Detection     : {detected}

            {'The file has been identified as potentially malicious. '
             'Immediate remediation is recommended.' if is_malicious else
             'No significant threats were detected in this sample.'}

            This report was generated automatically by the Megido Malware
            Analyser platform and is intended for authorised security
            personnel only.
            """
        )
        logger.debug("Executive summary generated for %s", filename)
        return summary


# =============================================================================
# ATTACKNavigatorGenerator
# =============================================================================

class ATTACKNavigatorGenerator:
    """
    Generate a MITRE ATT&CK Navigator JSON layer from a list of technique IDs.

    Parameters
    ----------
    techniques :
        List of dicts with at least a ``technique_id`` key (e.g. ``"T1059"``).
    layer_name :
        Display name for the navigator layer.
    """

    def __init__(
        self,
        techniques: List[Dict[str, Any]],
        layer_name: str = "Megido Malware Analysis",
    ) -> None:
        self.techniques = techniques
        self.layer_name = layer_name

    def generate(self) -> Dict[str, Any]:
        """
        Build and return the ATT&CK Navigator layer as a Python dict.

        Returns
        -------
        dict
            ATT&CK Navigator v4 layer structure.
        """
        technique_entries = []
        for t in self.techniques:
            tid = t.get("technique_id") or t.get("id", "")
            if not tid:
                continue
            technique_entries.append(
                {
                    "techniqueID": tid,
                    "score": int(t.get("score", 1)),
                    "color": t.get("color", "#e60026"),
                    "comment": t.get("comment", ""),
                    "enabled": True,
                    "showSubtechniques": bool(t.get("show_subtechniques", False)),
                }
            )

        layer = {
            "name": self.layer_name,
            "versions": {"attack": "14", "navigator": "4.9", "layer": "4.5"},
            "domain": "enterprise-attack",
            "description": f"Generated by Megido at {_now_iso()}",
            "filters": {"platforms": []},
            "sorting": 0,
            "layout": {"layout": "side"},
            "hideDisabled": False,
            "techniques": technique_entries,
            "gradient": {
                "colors": ["#ff6666", "#ff0000"],
                "minValue": 0,
                "maxValue": 1,
            },
            "legendItems": [],
            "metadata": [],
            "links": [],
            "showTacticRowBackground": False,
            "tacticRowBackground": "#dddddd",
            "selectTechniquesAcrossTactics": True,
            "selectSubtechniquesWithParent": False,
        }
        logger.debug("ATT&CK Navigator layer generated with %d techniques", len(technique_entries))
        return layer

    def to_json(self) -> str:
        """Return the layer as a JSON string."""
        return json.dumps(self.generate(), indent=2)


# =============================================================================
# IOCTableGenerator
# =============================================================================

class IOCTableGenerator:
    """
    Generate a formatted IOC table from a list of indicator records.

    Parameters
    ----------
    iocs :
        List of dicts with keys: ``type``, ``value``, ``confidence``,
        ``context`` (all strings/numbers).
    """

    COLUMNS = ["Type", "Value", "Confidence", "Context"]

    def __init__(self, iocs: List[Dict[str, Any]]) -> None:
        self.iocs = iocs

    def generate_text(self) -> str:
        """Return a plain-text table representation."""
        if not self.iocs:
            return "No IOCs found.\n"

        col_widths = [len(c) for c in self.COLUMNS]
        rows = []
        for ioc in self.iocs:
            row = [
                str(ioc.get("type", "")),
                str(ioc.get("value", "")),
                str(ioc.get("confidence", "")),
                str(ioc.get("context", "")),
            ]
            for i, cell in enumerate(row):
                col_widths[i] = max(col_widths[i], len(cell))
            rows.append(row)

        fmt = "  ".join(f"{{:<{w}}}" for w in col_widths)
        sep = "  ".join("-" * w for w in col_widths)
        lines = [fmt.format(*self.COLUMNS), sep]
        for row in rows:
            lines.append(fmt.format(*row))
        return "\n".join(lines) + "\n"

    def generate_dict(self) -> List[Dict[str, Any]]:
        """Return IOCs enriched with a ``table_row`` helper list."""
        result = []
        for ioc in self.iocs:
            entry = dict(ioc)
            entry["table_row"] = [
                entry.get("type", ""),
                entry.get("value", ""),
                entry.get("confidence", ""),
                entry.get("context", ""),
            ]
            result.append(entry)
        return result


# =============================================================================
# BehavioralTimelineGenerator
# =============================================================================

class BehavioralTimelineGenerator:
    """
    Generate a chronological behaviour timeline from dynamic analysis events.

    Parameters
    ----------
    events :
        List of dicts with at least ``timestamp`` (ISO string or seconds
        float) and ``description`` keys.
    """

    def __init__(self, events: List[Dict[str, Any]]) -> None:
        self.events = sorted(events, key=lambda e: str(e.get("timestamp", "")))

    def generate(self) -> List[Dict[str, Any]]:
        """
        Return the sorted timeline with a human-readable ``label``.

        Returns
        -------
        list of dict
        """
        timeline = []
        for idx, event in enumerate(self.events, start=1):
            entry = dict(event)
            entry["sequence"] = idx
            entry["label"] = (
                f"[{idx:03d}] {event.get('timestamp', 'T+?')} — "
                f"{event.get('description', 'Unknown event')}"
            )
            timeline.append(entry)
        logger.debug("Behavioural timeline built: %d events", len(timeline))
        return timeline

    def generate_text(self) -> str:
        """Return a plain-text timeline."""
        if not self.events:
            return "No behavioural events recorded.\n"
        lines = ["Behavioural Timeline", "==================="]
        for entry in self.generate():
            lines.append(entry["label"])
        return "\n".join(lines) + "\n"


# =============================================================================
# HTMLReportGenerator
# =============================================================================

class HTMLReportGenerator:
    """
    Generate a rich HTML report with collapsible sections.

    Parameters
    ----------
    report_data :
        Dict containing all report sections.
    title :
        Optional report title override.
    """

    def __init__(
        self,
        report_data: Dict[str, Any],
        title: str = "Malware Analysis Report",
    ) -> None:
        self.report_data = report_data
        self.title = title

    # ------------------------------------------------------------------
    def _collapsible_section(self, heading: str, content: str, open_: bool = False) -> str:
        details_attr = " open" if open_ else ""
        return (
            f"<details{details_attr}><summary><strong>{heading}</strong></summary>"
            f"<div class='section-body'>{content}</div></details>\n"
        )

    # ------------------------------------------------------------------
    def generate(self) -> str:
        """
        Build and return a complete HTML document as a string.

        Returns
        -------
        str
            Full HTML document.
        """
        rd = self.report_data
        ts = _now_iso()

        exec_summary = rd.get("executive_summary", "No summary available.")
        iocs = rd.get("iocs", {})
        yara = rd.get("yara_matches", [])
        network = rd.get("network", {})
        mitre = rd.get("mitre_attack", [])

        ioc_html = "<ul>" + "".join(
            f"<li><code>{k}</code>: {v}</li>" for k, v in iocs.items()
        ) + "</ul>" if iocs else "<p>No IOCs found.</p>"

        yara_html = "<ul>" + "".join(
            f"<li>{r}</li>" for r in yara
        ) + "</ul>" if yara else "<p>No YARA matches.</p>"

        mitre_html = "<ul>" + "".join(
            f"<li>{t}</li>" for t in mitre
        ) + "</ul>" if mitre else "<p>No ATT&CK techniques mapped.</p>"

        sections = (
            self._collapsible_section("Executive Summary", f"<pre>{exec_summary}</pre>", open_=True)
            + self._collapsible_section("IOCs", ioc_html)
            + self._collapsible_section("YARA Matches", yara_html)
            + self._collapsible_section("Network Activity", f"<pre>{json.dumps(network, indent=2)}</pre>")
            + self._collapsible_section("MITRE ATT&amp;CK", mitre_html)
        )

        html = textwrap.dedent(
            f"""\
            <!DOCTYPE html>
            <html lang="en">
            <head>
              <meta charset="UTF-8">
              <title>{self.title}</title>
              <style>
                body {{ font-family: monospace; background: #1a1a2e; color: #e0e0e0; padding: 2rem; }}
                details {{ border: 1px solid #444; border-radius: 4px; margin: 1rem 0; padding: .5rem 1rem; }}
                summary {{ cursor: pointer; font-size: 1.1rem; }}
                .section-body {{ padding: .5rem 0; }}
                pre {{ white-space: pre-wrap; word-break: break-all; }}
                code {{ background: #333; padding: 2px 4px; border-radius: 2px; }}
                h1 {{ color: #7fff7f; }}
              </style>
            </head>
            <body>
              <h1>{self.title}</h1>
              <p>Generated: {ts}</p>
              {sections}
            </body>
            </html>
            """
        )
        logger.debug("HTML report generated: %d chars", len(html))
        return html


# =============================================================================
# PDFReportGenerator
# =============================================================================

class PDFReportGenerator:
    """
    Generate PDF reports using reportlab.

    Falls back gracefully to HTML if reportlab is not installed.

    Parameters
    ----------
    report_data :
        Dict containing all report sections.
    title :
        Optional report title override.
    """

    def __init__(
        self,
        report_data: Dict[str, Any],
        title: str = "Malware Analysis Report",
    ) -> None:
        self.report_data = report_data
        self.title = title
        self._html_gen = HTMLReportGenerator(report_data, title)

    # ------------------------------------------------------------------
    def generate_pdf_bytes(self) -> bytes:
        """
        Return PDF as bytes.

        Falls back to UTF-8-encoded HTML if reportlab is unavailable.

        Returns
        -------
        bytes
        """
        if not _REPORTLAB_AVAILABLE:
            logger.info("reportlab unavailable – returning HTML fallback from PDFReportGenerator.")
            return self._html_gen.generate().encode("utf-8")

        import io

        buffer = io.BytesIO()
        doc = SimpleDocTemplate(buffer, pagesize=A4)
        styles = getSampleStyleSheet()
        story = []

        story.append(Paragraph(self.title, styles["Title"]))
        story.append(Spacer(1, 0.5 * cm))
        story.append(Paragraph(f"Generated: {_now_iso()}", styles["Normal"]))
        story.append(Spacer(1, 1 * cm))

        exec_summary = self.report_data.get("executive_summary", "No summary available.")
        story.append(Paragraph("Executive Summary", styles["Heading2"]))
        for line in exec_summary.splitlines():
            if line.strip():
                story.append(Paragraph(line, styles["Normal"]))
        story.append(Spacer(1, 0.5 * cm))

        iocs = self.report_data.get("iocs", {})
        if iocs:
            story.append(Paragraph("Indicators of Compromise", styles["Heading2"]))
            table_data = [["Type", "Value"]] + [[k, str(v)] for k, v in iocs.items()]
            tbl = Table(table_data, hAlign="LEFT")
            tbl.setStyle(
                TableStyle(
                    [
                        ("BACKGROUND", (0, 0), (-1, 0), colors.grey),
                        ("TEXTCOLOR", (0, 0), (-1, 0), colors.whitesmoke),
                        ("GRID", (0, 0), (-1, -1), 0.25, colors.black),
                        ("FONTSIZE", (0, 0), (-1, -1), 8),
                    ]
                )
            )
            story.append(tbl)

        doc.build(story)
        pdf_bytes = buffer.getvalue()
        logger.debug("PDF report generated: %d bytes", len(pdf_bytes))
        return pdf_bytes

    def generate_html_fallback(self) -> str:
        """Always return an HTML fallback, regardless of reportlab availability."""
        return self._html_gen.generate()


# =============================================================================
# ComparisonReportGenerator
# =============================================================================

class ComparisonReportGenerator:
    """
    Compare two malware samples side-by-side.

    Parameters
    ----------
    sample_a, sample_b :
        Report data dicts for each sample (as returned by
        :class:`ReportGenerator`).
    """

    def __init__(
        self,
        sample_a: Dict[str, Any],
        sample_b: Dict[str, Any],
    ) -> None:
        self.sample_a = sample_a
        self.sample_b = sample_b

    # ------------------------------------------------------------------
    def _diff_field(self, key: str) -> Dict[str, Any]:
        va = self.sample_a.get(key)
        vb = self.sample_b.get(key)
        return {"key": key, "sample_a": va, "sample_b": vb, "equal": va == vb}

    # ------------------------------------------------------------------
    def generate(self) -> Dict[str, Any]:
        """
        Return a structured comparison dict.

        Returns
        -------
        dict
            Keys: ``summary``, ``differences``, ``similarities``.
        """
        all_keys = set(self.sample_a) | set(self.sample_b)
        diffs = [self._diff_field(k) for k in sorted(all_keys)]
        differences = [d for d in diffs if not d["equal"]]
        similarities = [d for d in diffs if d["equal"]]

        comparison = {
            "generated_at": _now_iso(),
            "summary": {
                "total_fields": len(diffs),
                "different": len(differences),
                "similar": len(similarities),
            },
            "differences": differences,
            "similarities": similarities,
        }
        logger.debug(
            "Comparison report: %d different, %d similar fields",
            len(differences),
            len(similarities),
        )
        return comparison

    def generate_html(self) -> str:
        """Return a basic HTML comparison table."""
        cmp = self.generate()
        rows = ""
        for d in cmp["differences"]:
            rows += (
                f"<tr><td><code>{d['key']}</code></td>"
                f"<td>{d['sample_a']}</td>"
                f"<td>{d['sample_b']}</td></tr>"
            )
        return textwrap.dedent(
            f"""\
            <!DOCTYPE html>
            <html lang="en">
            <head>
              <meta charset="UTF-8">
              <title>Sample Comparison</title>
              <style>
                body {{ font-family: monospace; background:#1a1a2e; color:#e0e0e0; padding:2rem; }}
                table {{ border-collapse: collapse; width: 100%; }}
                th, td {{ border: 1px solid #444; padding: .4rem .8rem; }}
                th {{ background: #333; }}
              </style>
            </head>
            <body>
              <h1>Sample Comparison</h1>
              <p>Generated: {cmp['generated_at']}</p>
              <p>{cmp['summary']['different']} differences,
                 {cmp['summary']['similar']} similarities.</p>
              <h2>Differences</h2>
              <table>
                <tr><th>Field</th><th>Sample A</th><th>Sample B</th></tr>
                {rows}
              </table>
            </body>
            </html>
            """
        )


# =============================================================================
# ReportGenerator  (top-level orchestrator)
# =============================================================================

class ReportGenerator:
    """
    Top-level orchestrator that coordinates all report-generation components.

    Parameters
    ----------
    scan_result_id :
        Primary key of a :class:`malware_analyser.models.ScanResult`.

    Examples
    --------
    >>> rg = ReportGenerator(scan_result_id=some_id)
    >>> report = rg.generate_full_report()
    >>> html = rg.generate_html_report()
    >>> pdf  = rg.generate_pdf_report()
    """

    def __init__(self, scan_result_id: Any) -> None:
        self.scan_result_id = scan_result_id
        self._scan_result: Optional[Any] = None
        self._report_data: Optional[Dict[str, Any]] = None

    # ------------------------------------------------------------------
    def _load_scan_result(self) -> Any:
        if self._scan_result is not None:
            return self._scan_result
        from malware_analyser.models import ScanResult

        try:
            self._scan_result = ScanResult.objects.select_related("file").get(
                pk=self.scan_result_id
            )
        except ScanResult.DoesNotExist:
            logger.warning("ScanResult %s not found; using stub data.", self.scan_result_id)
            self._scan_result = None
        return self._scan_result

    # ------------------------------------------------------------------
    def _build_report_data(self) -> Dict[str, Any]:
        """Collect all analysis data into a single dict."""
        scan = self._load_scan_result()

        if scan is None:
            return {
                "scan_result_id": str(self.scan_result_id),
                "executive_summary": "Scan result not found – stub data only.",
                "iocs": {},
                "yara_matches": [],
                "network": {},
                "mitre_attack": [],
                "behaviours": [],
                "config": {},
            }

        exec_gen = ExecutiveSummaryGenerator(scan)
        exec_text = exec_gen.generate()

        # IOCs
        report_obj = getattr(scan, "reports", None)
        iocs: Dict[str, Any] = {}
        if report_obj:
            try:
                latest_report = report_obj.order_by("-created_at").first()
                if latest_report:
                    iocs = latest_report.indicators_of_compromise or {}
            except Exception:  # noqa: BLE001
                pass

        # YARA
        yara_matches: List[Any] = []
        if hasattr(scan, "static_analysis"):
            try:
                yara_matches = scan.static_analysis.yara_matches or []
            except Exception:  # noqa: BLE001
                pass

        # Network
        network: Dict[str, Any] = {}
        if hasattr(scan, "dynamic_analysis"):
            try:
                da = scan.dynamic_analysis
                network = {
                    "dns_queries": da.dns_queries,
                    "http_requests": da.http_requests,
                    "network_connections": da.network_connections,
                }
            except Exception:  # noqa: BLE001
                pass

        # MITRE ATT&CK
        mitre: List[Any] = scan.scan_details.get("mitre_attack", [])

        # Behaviours
        behaviours: List[Any] = scan.scan_details.get("behaviours", [])

        return {
            "scan_result_id": str(self.scan_result_id),
            "filename": scan.file.original_filename,
            "md5": scan.file.file_hash_md5,
            "sha256": scan.file.file_hash_sha256,
            "is_malicious": scan.is_malicious,
            "threat_level": scan.threat_level,
            "detected_malware": scan.detected_malware,
            "executive_summary": exec_text,
            "iocs": iocs,
            "yara_matches": yara_matches,
            "network": network,
            "mitre_attack": mitre,
            "behaviours": behaviours,
            "config": scan.scan_details.get("malware_config", {}),
            "generated_at": _now_iso(),
        }

    # ------------------------------------------------------------------
    def generate_full_report(self) -> Dict[str, Any]:
        """
        Build and return the complete report data dict.

        Returns
        -------
        dict
        """
        if self._report_data is None:
            self._report_data = self._build_report_data()
        logger.info("Full report generated for scan_result_id=%s", self.scan_result_id)
        return self._report_data

    # ------------------------------------------------------------------
    def generate_html_report(self) -> str:
        """
        Return the full analysis report as an HTML string.

        Returns
        -------
        str
        """
        data = self.generate_full_report()
        gen = HTMLReportGenerator(data, title=f"Analysis Report – {data.get('filename', 'unknown')}")
        return gen.generate()

    # ------------------------------------------------------------------
    def generate_pdf_report(self) -> bytes:
        """
        Return the full analysis report as PDF bytes.

        Falls back to UTF-8-encoded HTML if reportlab is unavailable.

        Returns
        -------
        bytes
        """
        data = self.generate_full_report()
        gen = PDFReportGenerator(data, title=f"Analysis Report – {data.get('filename', 'unknown')}")
        return gen.generate_pdf_bytes()

    # ------------------------------------------------------------------
    def generate_attack_navigator_layer(self) -> Dict[str, Any]:
        """
        Return the MITRE ATT&CK Navigator layer for detected techniques.

        Returns
        -------
        dict
        """
        data = self.generate_full_report()
        techniques = [{"technique_id": t} for t in data.get("mitre_attack", [])]
        gen = ATTACKNavigatorGenerator(
            techniques,
            layer_name=f"Megido – {data.get('filename', 'sample')}",
        )
        return gen.generate()

    # ------------------------------------------------------------------
    def generate_ioc_table(self) -> List[Dict[str, Any]]:
        """
        Return enriched IOC table rows.

        Returns
        -------
        list of dict
        """
        data = self.generate_full_report()
        iocs_flat = [
            {"type": k, "value": str(v), "confidence": "medium", "context": "extracted"}
            for k, v in data.get("iocs", {}).items()
        ]
        gen = IOCTableGenerator(iocs_flat)
        return gen.generate_dict()

    # ------------------------------------------------------------------
    def generate_behavioral_timeline(self) -> List[Dict[str, Any]]:
        """
        Return the chronological behaviour timeline.

        Returns
        -------
        list of dict
        """
        data = self.generate_full_report()
        gen = BehavioralTimelineGenerator(data.get("behaviours", []))
        return gen.generate()
