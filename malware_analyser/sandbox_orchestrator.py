"""
Sandbox Orchestrator for Malware Analyzer

Provides a unified interface to multiple dynamic analysis sandboxes:
- Cuckoo Sandbox (open-source)
- CAPE Sandbox (Cuckoo fork with config extraction)
- ANY.RUN (cloud SaaS)
- Local Docker-based sandbox

All sandbox credentials/URLs are read from Django settings to avoid
hardcoded secrets.  When Django is not configured the module falls back
to reading from environment variables.

Architecture:
    BaseSandbox (abstract)
        ├── CuckooSandbox
        ├── CAPESandbox
        ├── AnyRunSandbox
        └── DockerSandbox

    SandboxOrchestrator   ← primary entry point
        Manages sandbox pool, submits samples, collects and parses reports.
"""

import abc
import logging
import os
import time
import uuid
import json
import hashlib
from typing import Dict, List, Optional, Any, Tuple

logger = logging.getLogger(__name__)

# ---------------------------------------------------------------------------
# Optional dependency guards
# ---------------------------------------------------------------------------

try:
    import requests
    REQUESTS_AVAILABLE = True
except ImportError:
    REQUESTS_AVAILABLE = False
    logger.warning("requests library not available; sandbox HTTP submissions disabled")

try:
    import docker
    DOCKER_AVAILABLE = True
except ImportError:
    DOCKER_AVAILABLE = False
    logger.info("docker SDK not available; DockerSandbox disabled")


# ---------------------------------------------------------------------------
# Settings helper
# ---------------------------------------------------------------------------

def _get_setting(key: str, default: Any = None) -> Any:
    """
    Read a setting from Django settings, falling back to environment variables.

    Avoids a hard Django dependency so this module can be imported standalone.
    """
    try:
        from django.conf import settings
        return getattr(settings, key, os.environ.get(key, default))
    except Exception:
        return os.environ.get(key, default)


# ---------------------------------------------------------------------------
# Result data structures
# ---------------------------------------------------------------------------

class BehaviorReport:
    """
    Parsed behavioural analysis report from any sandbox.

    Attributes are populated from sandbox-specific JSON reports.
    """

    def __init__(self):
        self.sandbox_name: str = "unknown"
        self.task_id: str = ""
        self.sample_sha256: str = ""
        self.status: str = "pending"          # pending | running | completed | failed
        self.score: float = 0.0               # 0–10
        self.verdict: str = "unknown"          # benign | suspicious | malicious

        # Process tree
        self.process_tree: List[Dict] = []

        # File system activity
        self.files_created: List[str] = []
        self.files_deleted: List[str] = []
        self.files_modified: List[str] = []

        # Registry activity
        self.registry_created: List[str] = []
        self.registry_deleted: List[str] = []
        self.registry_modified: List[str] = []

        # Network activity
        self.dns_queries: List[str] = []
        self.http_requests: List[Dict] = []
        self.tcp_connections: List[Dict] = []
        self.udp_connections: List[Dict] = []

        # API call trace
        self.api_calls: List[Dict] = []

        # MITRE ATT&CK techniques
        self.mitre_techniques: List[Dict] = []

        # Raw report (truncated)
        self.raw_summary: Dict = {}

    def to_dict(self) -> Dict[str, Any]:
        """Serialise the report to a JSON-compatible dict."""
        return {
            "sandbox": self.sandbox_name,
            "task_id": self.task_id,
            "sample_sha256": self.sample_sha256,
            "status": self.status,
            "score": self.score,
            "verdict": self.verdict,
            "process_tree": self.process_tree,
            "files": {
                "created": self.files_created,
                "deleted": self.files_deleted,
                "modified": self.files_modified,
            },
            "registry": {
                "created": self.registry_created,
                "deleted": self.registry_deleted,
                "modified": self.registry_modified,
            },
            "network": {
                "dns": self.dns_queries,
                "http": self.http_requests,
                "tcp": self.tcp_connections,
                "udp": self.udp_connections,
            },
            "api_calls": self.api_calls[:200],   # cap for storage
            "mitre_techniques": self.mitre_techniques,
            "raw_summary": self.raw_summary,
        }


# ---------------------------------------------------------------------------
# Abstract base sandbox
# ---------------------------------------------------------------------------

class BaseSandbox(abc.ABC):
    """
    Abstract base class for sandbox integrations.

    Subclasses must implement:
    - ``submit_file(file_path, options)`` → task_id str
    - ``get_status(task_id)`` → str (pending|running|completed|failed)
    - ``get_report(task_id)`` → BehaviorReport
    """

    name: str = "base"
    enabled: bool = False

    def __init__(self):
        self._session: Optional[Any] = None

    @abc.abstractmethod
    def submit_file(self, file_path: str, options: Optional[Dict] = None) -> str:
        """
        Submit a file for analysis.

        :param file_path: Path to the sample.
        :param options: Sandbox-specific submission options.
        :returns: Task/analysis ID string.
        :raises RuntimeError: on submission failure.
        """

    @abc.abstractmethod
    def get_status(self, task_id: str) -> str:
        """
        Query the status of a submitted task.

        :returns: One of ``pending``, ``running``, ``completed``, ``failed``.
        """

    @abc.abstractmethod
    def get_report(self, task_id: str) -> BehaviorReport:
        """
        Retrieve and parse the completed analysis report.

        :returns: Populated :class:`BehaviorReport`.
        """

    def wait_for_completion(
        self, task_id: str, poll_interval: int = 30, max_wait: int = 600
    ) -> BehaviorReport:
        """
        Poll until the task completes, then return the report.

        :param task_id: Task identifier returned by ``submit_file``.
        :param poll_interval: Seconds between status polls.
        :param max_wait: Maximum total wait time in seconds.
        :returns: Completed :class:`BehaviorReport`.
        :raises TimeoutError: if max_wait is exceeded.
        """
        deadline = time.monotonic() + max_wait
        while time.monotonic() < deadline:
            status = self.get_status(task_id)
            logger.debug("[%s] task %s status: %s", self.name, task_id, status)
            if status == "completed":
                return self.get_report(task_id)
            if status == "failed":
                report = BehaviorReport()
                report.task_id = task_id
                report.status = "failed"
                report.sandbox_name = self.name
                return report
            time.sleep(poll_interval)

        raise TimeoutError(
            f"[{self.name}] task {task_id} did not complete within {max_wait}s"
        )

    def _sha256(self, file_path: str) -> str:
        h = hashlib.sha256()
        with open(file_path, "rb") as fh:
            for chunk in iter(lambda: fh.read(65536), b""):
                h.update(chunk)
        return h.hexdigest()

    def _http_session(self) -> Any:
        """Return a lazily-initialised requests.Session."""
        if not REQUESTS_AVAILABLE:
            raise RuntimeError("requests library not available")
        if self._session is None:
            import requests as _req
            self._session = _req.Session()
        return self._session


# ---------------------------------------------------------------------------
# Cuckoo Sandbox
# ---------------------------------------------------------------------------

class CuckooSandbox(BaseSandbox):
    """
    Cuckoo Sandbox integration.

    Settings (Django or env):
    - ``CUCKOO_API_URL``: e.g. ``http://cuckoo.local:8090``
    - ``CUCKOO_API_TOKEN``: API token (if auth enabled)
    """

    name = "cuckoo"

    def __init__(self):
        super().__init__()
        self.api_url = (_get_setting("CUCKOO_API_URL") or "http://localhost:8090").rstrip("/")
        self.api_token = _get_setting("CUCKOO_API_TOKEN") or ""
        self.enabled = bool(self.api_url) and REQUESTS_AVAILABLE

    def _headers(self) -> Dict[str, str]:
        h: Dict[str, str] = {"Accept": "application/json"}
        if self.api_token:
            h["Authorization"] = f"Bearer {self.api_token}"
        return h

    def submit_file(self, file_path: str, options: Optional[Dict] = None) -> str:
        session = self._http_session()
        url = f"{self.api_url}/tasks/create/file"
        data = options or {}
        try:
            with open(file_path, "rb") as fh:
                resp = session.post(
                    url,
                    files={"file": (os.path.basename(file_path), fh, "application/octet-stream")},
                    data=data,
                    headers=self._headers(),
                    timeout=30,
                )
            resp.raise_for_status()
            task_id = str(resp.json()["task_id"])
            logger.info("[cuckoo] submitted %s → task %s", file_path, task_id)
            return task_id
        except Exception as exc:
            logger.error("[cuckoo] submit_file error: %s", exc)
            raise RuntimeError(f"Cuckoo submission failed: {exc}") from exc

    def get_status(self, task_id: str) -> str:
        session = self._http_session()
        url = f"{self.api_url}/tasks/view/{task_id}"
        try:
            resp = session.get(url, headers=self._headers(), timeout=10)
            resp.raise_for_status()
            cuckoo_status = resp.json().get("task", {}).get("status", "unknown")
            status_map = {
                "pending": "pending",
                "running": "running",
                "reported": "completed",
                "failed_analysis": "failed",
                "failed_processing": "failed",
            }
            return status_map.get(cuckoo_status, "running")
        except Exception as exc:
            logger.error("[cuckoo] get_status error: %s", exc)
            return "failed"

    def get_report(self, task_id: str) -> BehaviorReport:
        session = self._http_session()
        url = f"{self.api_url}/tasks/report/{task_id}"
        report = BehaviorReport()
        report.task_id = task_id
        report.sandbox_name = self.name
        try:
            resp = session.get(url, headers=self._headers(), timeout=30)
            resp.raise_for_status()
            data = resp.json()
            report.status = "completed"
            report.score = float(data.get("info", {}).get("score", 0))
            report.verdict = _score_to_verdict(report.score)
            report = _parse_cuckoo_report(data, report)
        except Exception as exc:
            logger.error("[cuckoo] get_report error: %s", exc)
            report.status = "failed"
            report.raw_summary = {"error": str(exc)}
        return report


def _score_to_verdict(score: float) -> str:
    if score >= 7.0:
        return "malicious"
    if score >= 4.0:
        return "suspicious"
    return "benign"


def _parse_cuckoo_report(data: Dict, report: BehaviorReport) -> BehaviorReport:
    """Populate a BehaviorReport from raw Cuckoo JSON."""
    # Process tree
    procs = data.get("behavior", {}).get("processtree", [])
    report.process_tree = _flatten_process_tree(procs)

    # File activity
    file_ops = data.get("behavior", {}).get("summary", {}).get("files", {})
    report.files_created = file_ops.get("created", [])[:100]
    report.files_deleted = file_ops.get("deleted", [])[:100]
    report.files_modified = file_ops.get("modified", [])[:100]

    # Registry activity
    reg_ops = data.get("behavior", {}).get("summary", {}).get("keys", {})
    report.registry_created = reg_ops.get("created", [])[:100]
    report.registry_deleted = reg_ops.get("deleted", [])[:100]
    report.registry_modified = reg_ops.get("modified", [])[:100]

    # Network
    network = data.get("network", {})
    report.dns_queries = [d.get("request", "") for d in network.get("dns", [])][:100]
    report.http_requests = [
        {"url": h.get("uri", ""), "method": h.get("method", ""), "host": h.get("host", "")}
        for h in network.get("http", [])
    ][:100]
    report.tcp_connections = [
        {"dst": c.get("dst", ""), "dport": c.get("dport", 0)}
        for c in network.get("tcp", [])
    ][:100]

    # API calls
    processes = data.get("behavior", {}).get("processes", [])
    for proc in processes[:5]:  # limit to first 5 processes
        calls = proc.get("calls", [])
        for call in calls[:50]:
            report.api_calls.append({
                "process": proc.get("process_name", ""),
                "api": call.get("api", ""),
                "category": call.get("category", ""),
            })

    # MITRE
    report.mitre_techniques = [
        {"id": t.get("ttp", ""), "description": t.get("description", "")}
        for t in data.get("ttps", [])
    ]

    report.raw_summary = {
        "cuckoo_score": data.get("info", {}).get("score"),
        "machine": data.get("info", {}).get("machine"),
        "duration": data.get("info", {}).get("duration"),
    }
    return report


def _flatten_process_tree(tree: List[Dict], depth: int = 0) -> List[Dict]:
    flat = []
    for node in tree:
        flat.append({
            "pid": node.get("pid"),
            "name": node.get("process_name", node.get("name", "")),
            "depth": depth,
            "cmdline": node.get("command_line", ""),
        })
        children = node.get("children", [])
        if children:
            flat.extend(_flatten_process_tree(children, depth + 1))
    return flat


# ---------------------------------------------------------------------------
# CAPE Sandbox
# ---------------------------------------------------------------------------

class CAPESandbox(BaseSandbox):
    """
    CAPE Sandbox integration (Cuckoo fork with config extraction).

    Settings:
    - ``CAPE_API_URL``: e.g. ``http://cape.local:8000``
    - ``CAPE_API_TOKEN``: API token
    """

    name = "cape"

    def __init__(self):
        super().__init__()
        self.api_url = (_get_setting("CAPE_API_URL") or "http://localhost:8000").rstrip("/")
        self.api_token = _get_setting("CAPE_API_TOKEN") or ""
        self.enabled = bool(self.api_url) and REQUESTS_AVAILABLE

    def _headers(self) -> Dict[str, str]:
        h: Dict[str, str] = {"Accept": "application/json"}
        if self.api_token:
            h["Authorization"] = f"Token {self.api_token}"
        return h

    def submit_file(self, file_path: str, options: Optional[Dict] = None) -> str:
        session = self._http_session()
        url = f"{self.api_url}/api/tasks/create/file/"
        try:
            with open(file_path, "rb") as fh:
                resp = session.post(
                    url,
                    files={"file": (os.path.basename(file_path), fh)},
                    data=options or {},
                    headers=self._headers(),
                    timeout=30,
                )
            resp.raise_for_status()
            task_id = str(resp.json().get("task_ids", [None])[0] or resp.json().get("task_id", ""))
            logger.info("[cape] submitted %s → task %s", file_path, task_id)
            return task_id
        except Exception as exc:
            logger.error("[cape] submit_file error: %s", exc)
            raise RuntimeError(f"CAPE submission failed: {exc}") from exc

    def get_status(self, task_id: str) -> str:
        session = self._http_session()
        url = f"{self.api_url}/api/tasks/view/{task_id}/"
        try:
            resp = session.get(url, headers=self._headers(), timeout=10)
            resp.raise_for_status()
            status = resp.json().get("data", {}).get("status", "unknown")
            return {"reported": "completed", "failed_analysis": "failed"}.get(status, "running")
        except Exception as exc:
            logger.error("[cape] get_status error: %s", exc)
            return "failed"

    def get_report(self, task_id: str) -> BehaviorReport:
        session = self._http_session()
        url = f"{self.api_url}/api/tasks/get/report/{task_id}/"
        report = BehaviorReport()
        report.task_id = task_id
        report.sandbox_name = self.name
        try:
            resp = session.get(url, headers=self._headers(), timeout=60)
            resp.raise_for_status()
            data = resp.json()
            report.status = "completed"
            report.score = float(data.get("malscore", data.get("info", {}).get("score", 0)))
            report.verdict = _score_to_verdict(report.score)
            # CAPE shares Cuckoo's report schema
            report = _parse_cuckoo_report(data, report)
            # CAPE-specific: extracted configs
            configs = data.get("CAPE", {}).get("configs", [])
            if configs:
                report.raw_summary["cape_configs"] = configs[:5]
        except Exception as exc:
            logger.error("[cape] get_report error: %s", exc)
            report.status = "failed"
            report.raw_summary = {"error": str(exc)}
        return report


# ---------------------------------------------------------------------------
# ANY.RUN Sandbox
# ---------------------------------------------------------------------------

class AnyRunSandbox(BaseSandbox):
    """
    ANY.RUN cloud sandbox integration.

    Settings:
    - ``ANYRUN_API_KEY``: API key from any.run account
    - ``ANYRUN_API_URL``: defaults to ``https://api.any.run/v1``
    """

    name = "anyrun"
    BASE_URL = "https://api.any.run/v1"

    def __init__(self):
        super().__init__()
        self.api_key = _get_setting("ANYRUN_API_KEY") or ""
        self.api_url = (_get_setting("ANYRUN_API_URL") or self.BASE_URL).rstrip("/")
        self.enabled = bool(self.api_key) and REQUESTS_AVAILABLE

    def _headers(self) -> Dict[str, str]:
        return {
            "Authorization": f"API-Key {self.api_key}",
            "Accept": "application/json",
        }

    def submit_file(self, file_path: str, options: Optional[Dict] = None) -> str:
        if not self.api_key:
            raise RuntimeError("ANYRUN_API_KEY not configured")
        session = self._http_session()
        url = f"{self.api_url}/analysis"
        defaults = {
            "env_os": "windows",
            "env_bitness": "64",
            "env_version": "10",
            "obj_type": "file",
            "opt_timeout": "120",
        }
        if options:
            defaults.update(options)
        try:
            with open(file_path, "rb") as fh:
                resp = session.post(
                    url,
                    files={"file": (os.path.basename(file_path), fh)},
                    data=defaults,
                    headers=self._headers(),
                    timeout=60,
                )
            resp.raise_for_status()
            task_id = resp.json().get("data", {}).get("taskid", "")
            logger.info("[anyrun] submitted %s → task %s", file_path, task_id)
            return task_id
        except Exception as exc:
            logger.error("[anyrun] submit_file error: %s", exc)
            raise RuntimeError(f"ANY.RUN submission failed: {exc}") from exc

    def get_status(self, task_id: str) -> str:
        session = self._http_session()
        url = f"{self.api_url}/analysis/{task_id}"
        try:
            resp = session.get(url, headers=self._headers(), timeout=10)
            resp.raise_for_status()
            status = resp.json().get("data", {}).get("analysis", {}).get("status", "unknown")
            return {"done": "completed", "running": "running", "queued": "pending"}.get(
                status.lower(), "running"
            )
        except Exception as exc:
            logger.error("[anyrun] get_status error: %s", exc)
            return "failed"

    def get_report(self, task_id: str) -> BehaviorReport:
        session = self._http_session()
        url = f"{self.api_url}/analysis/{task_id}"
        report = BehaviorReport()
        report.task_id = task_id
        report.sandbox_name = self.name
        try:
            resp = session.get(url, headers=self._headers(), timeout=30)
            resp.raise_for_status()
            data = resp.json().get("data", {})
            report.status = "completed"

            analysis = data.get("analysis", {})
            scores = analysis.get("scores", {})
            report.score = float(scores.get("verdict", {}).get("score", 0))  # ANY.RUN returns 0-10
            verdict_str = scores.get("verdict", {}).get("verdict", "no verdict")
            report.verdict = "malicious" if "malicious" in verdict_str.lower() else (
                "suspicious" if "suspicious" in verdict_str.lower() else "benign"
            )

            # Network
            network = data.get("network", [])
            for item in network:
                if item.get("type") == "dns":
                    report.dns_queries.append(item.get("domain", ""))
                elif item.get("type") == "http":
                    report.http_requests.append({
                        "url": item.get("url", ""),
                        "method": item.get("method", ""),
                        "host": item.get("domain", ""),
                    })

            # Processes
            processes = data.get("processes", [])
            for proc in processes:
                report.process_tree.append({
                    "pid": proc.get("pid"),
                    "name": proc.get("image", ""),
                    "cmdline": proc.get("cmd", ""),
                    "depth": 0,
                })

            report.raw_summary = {
                "anyrun_verdict": verdict_str,
                "tags": analysis.get("tags", []),
            }
        except Exception as exc:
            logger.error("[anyrun] get_report error: %s", exc)
            report.status = "failed"
            report.raw_summary = {"error": str(exc)}
        return report


# ---------------------------------------------------------------------------
# Local Docker Sandbox
# ---------------------------------------------------------------------------

class DockerSandbox(BaseSandbox):
    """
    Local Docker-based sandbox for offline analysis.

    Runs a sample inside an isolated Docker container and captures
    filesystem/process changes via container diffs.

    Settings:
    - ``DOCKER_SANDBOX_IMAGE``: Docker image name (default: ``remnux/remnux-distro``)
    - ``DOCKER_SANDBOX_TIMEOUT``: Max run time in seconds (default: 60)
    - ``DOCKER_SANDBOX_NETWORK``: ``none`` | ``bridge`` (default: ``none``)
    """

    name = "docker"
    DEFAULT_IMAGE = "remnux/remnux-distro"

    def __init__(self):
        super().__init__()
        self.image = _get_setting("DOCKER_SANDBOX_IMAGE") or self.DEFAULT_IMAGE
        self.timeout = int(_get_setting("DOCKER_SANDBOX_TIMEOUT") or 60)
        self.network = _get_setting("DOCKER_SANDBOX_NETWORK") or "none"
        self.enabled = DOCKER_AVAILABLE
        self._client: Optional[Any] = None
        self._tasks: Dict[str, Dict] = {}  # in-memory task store

    def _docker_client(self) -> Any:
        if not DOCKER_AVAILABLE:
            raise RuntimeError("docker SDK not available")
        if self._client is None:
            self._client = docker.from_env()
        return self._client

    def submit_file(self, file_path: str, options: Optional[Dict] = None) -> str:
        client = self._docker_client()
        task_id = str(uuid.uuid4())
        sha256 = self._sha256(file_path)
        logger.info("[docker] submitting %s (sha256=%s) as task %s", file_path, sha256, task_id)

        try:
            # Run sample in a resource-limited container with no network by default.
            # IMPORTANT: ensure the Docker daemon itself runs without root privileges
            # (rootless mode) to minimise container-escape risk.
            container = client.containers.run(
                self.image,
                command="/bin/sh -c 'chmod +x /sample && /sample' 2>&1 || true",
                volumes={os.path.abspath(file_path): {"bind": "/sample", "mode": "ro"}},
                network_mode=self.network,
                detach=True,
                remove=False,
                mem_limit="256m",
                cpu_period=100000,
                cpu_quota=50000,   # 50% of one CPU
                cap_drop=["ALL"],
                security_opt=["no-new-privileges"],
            )
            self._tasks[task_id] = {
                "container_id": container.id,
                "status": "running",
                "sha256": sha256,
                "file_path": file_path,
                "submitted_at": time.time(),
            }
        except Exception as exc:
            logger.error("[docker] submit_file error: %s", exc)
            self._tasks[task_id] = {"status": "failed", "error": str(exc)}
            raise RuntimeError(f"Docker sandbox submission failed: {exc}") from exc

        return task_id

    def get_status(self, task_id: str) -> str:
        task = self._tasks.get(task_id)
        if not task:
            return "failed"
        if task["status"] in ("failed", "completed"):
            return task["status"]

        container_id = task.get("container_id")
        if not container_id:
            return "failed"

        try:
            client = self._docker_client()
            container = client.containers.get(container_id)
            state = container.status  # running / exited / paused …
            if state == "exited":
                task["status"] = "completed"
                return "completed"
            # Check timeout
            if time.time() - task.get("submitted_at", 0) > self.timeout:
                container.stop(timeout=5)
                task["status"] = "completed"
                return "completed"
            return "running"
        except Exception as exc:
            logger.error("[docker] get_status error: %s", exc)
            task["status"] = "failed"
            return "failed"

    def get_report(self, task_id: str) -> BehaviorReport:
        report = BehaviorReport()
        report.task_id = task_id
        report.sandbox_name = self.name

        task = self._tasks.get(task_id)
        if not task or task.get("status") == "failed":
            report.status = "failed"
            return report

        container_id = task.get("container_id")
        if not container_id:
            report.status = "failed"
            return report

        try:
            client = self._docker_client()
            container = client.containers.get(container_id)

            # Capture stdout/stderr logs
            logs = container.logs(stdout=True, stderr=True).decode("utf-8", errors="replace")
            report.raw_summary["logs"] = logs[:4096]

            # Container filesystem diff
            changes = container.diff() or []
            for change in changes[:200]:
                kind = change.get("Kind", -1)
                path = change.get("Path", "")
                if kind == 0:    # modified
                    report.files_modified.append(path)
                elif kind == 1:  # added
                    report.files_created.append(path)
                elif kind == 2:  # deleted
                    report.files_deleted.append(path)

            # Simple heuristic score from filesystem changes
            n_changes = len(report.files_created) + len(report.files_modified) + len(report.files_deleted)
            report.score = min(10.0, n_changes / 10)
            report.verdict = _score_to_verdict(report.score)
            report.status = "completed"

            # Clean up container
            try:
                container.remove(force=True)
            except Exception:
                pass

        except Exception as exc:
            logger.error("[docker] get_report error: %s", exc)
            report.status = "failed"
            report.raw_summary["error"] = str(exc)

        return report


# ---------------------------------------------------------------------------
# Orchestrator
# ---------------------------------------------------------------------------

class SandboxOrchestrator:
    """
    Manages a pool of configured sandboxes and provides a single
    interface for submitting samples and collecting results.

    Usage::

        orchestrator = SandboxOrchestrator()
        task_id, sandbox_name = orchestrator.submit("/path/to/sample.exe")
        report = orchestrator.wait_and_collect(task_id, sandbox_name)
        print(report.to_dict())
    """

    def __init__(self, sandboxes: Optional[List[BaseSandbox]] = None):
        if sandboxes is not None:
            self._sandboxes = sandboxes
        else:
            self._sandboxes = self._auto_configure()

        enabled = [s.name for s in self._sandboxes if s.enabled]
        logger.info("SandboxOrchestrator initialised with sandboxes: %s", enabled or ["none"])

    @staticmethod
    def _auto_configure() -> List[BaseSandbox]:
        """Instantiate all known sandbox adapters; callers use only enabled ones."""
        return [
            CuckooSandbox(),
            CAPESandbox(),
            AnyRunSandbox(),
            DockerSandbox(),
        ]

    @property
    def enabled_sandboxes(self) -> List[BaseSandbox]:
        return [s for s in self._sandboxes if s.enabled]

    def submit(
        self,
        file_path: str,
        sandbox_name: Optional[str] = None,
        options: Optional[Dict] = None,
    ) -> Tuple[str, str]:
        """
        Submit a file for analysis.

        :param file_path: Path to the sample.
        :param sandbox_name: Specific sandbox to use; if None, uses the first
            enabled sandbox.
        :param options: Sandbox-specific submission options.
        :returns: ``(task_id, sandbox_name)`` tuple.
        :raises RuntimeError: If no sandbox is available or submission fails.
        """
        sandbox = self._select_sandbox(sandbox_name)
        task_id = sandbox.submit_file(file_path, options=options)
        return task_id, sandbox.name

    def get_status(self, task_id: str, sandbox_name: str) -> str:
        """Query task status on the named sandbox."""
        sandbox = self._get_sandbox(sandbox_name)
        return sandbox.get_status(task_id)

    def get_report(self, task_id: str, sandbox_name: str) -> BehaviorReport:
        """Fetch report from the named sandbox."""
        sandbox = self._get_sandbox(sandbox_name)
        return sandbox.get_report(task_id)

    def wait_and_collect(
        self,
        task_id: str,
        sandbox_name: str,
        poll_interval: int = 30,
        max_wait: int = 600,
    ) -> BehaviorReport:
        """Block until analysis completes and return the parsed report."""
        sandbox = self._get_sandbox(sandbox_name)
        return sandbox.wait_for_completion(task_id, poll_interval=poll_interval, max_wait=max_wait)

    def analyze(
        self,
        file_path: str,
        sandbox_name: Optional[str] = None,
        options: Optional[Dict] = None,
        poll_interval: int = 30,
        max_wait: int = 600,
    ) -> BehaviorReport:
        """
        One-shot convenience: submit, wait, collect.

        :returns: Completed :class:`BehaviorReport`.
        """
        task_id, chosen_sandbox = self.submit(file_path, sandbox_name=sandbox_name, options=options)
        return self.wait_and_collect(
            task_id, chosen_sandbox, poll_interval=poll_interval, max_wait=max_wait
        )

    @property
    def status_info(self) -> Dict[str, Any]:
        """Return availability info for all configured sandboxes."""
        return {
            s.name: {
                "enabled": s.enabled,
                "class": type(s).__name__,
            }
            for s in self._sandboxes
        }

    # ------------------------------------------------------------------
    # Private helpers
    # ------------------------------------------------------------------

    def _select_sandbox(self, name: Optional[str]) -> BaseSandbox:
        if name:
            return self._get_sandbox(name)
        available = self.enabled_sandboxes
        if not available:
            raise RuntimeError(
                "No sandbox is currently enabled. "
                "Configure at least one of: CUCKOO_API_URL, CAPE_API_URL, "
                "ANYRUN_API_KEY, or install the docker SDK."
            )
        return available[0]

    def _get_sandbox(self, name: str) -> BaseSandbox:
        for s in self._sandboxes:
            if s.name == name:
                return s
        raise ValueError(f"Unknown sandbox: '{name}'. Available: {[s.name for s in self._sandboxes]}")
