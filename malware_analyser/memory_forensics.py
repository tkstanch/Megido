"""
Memory forensics module.

Provides basic memory dump scanning and optional Volatility 3 integration.
"""
import logging
import os
import re
import shutil
import subprocess
import tempfile
from pathlib import Path
from typing import Any, Dict, List, Optional

logger = logging.getLogger(__name__)

# ---------------------------------------------------------------------------
# Compiled patterns for memory scanning
# ---------------------------------------------------------------------------

_IP_RE = re.compile(
    rb"(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)"
    rb"(?::\d{1,5})?"
)
_URL_RE = re.compile(rb"https?://[^\x00\r\n \"'<>]{4,256}")
_DOMAIN_RE = re.compile(
    rb"(?:[a-zA-Z0-9](?:[a-zA-Z0-9\-]{0,61}[a-zA-Z0-9])?\.)+"
    rb"(?:com|net|org|info|biz|ru|cn|pw|top|xyz|io)"
    rb"(?=[\x00\r\n\x09 \"'<>]|$)"
)
_WIN_PATH_RE = re.compile(rb"[Cc]:\\(?:[^\x00\r\n\"*?<>|]{1,64}\\){0,8}[^\x00\r\n\"*?<>|]{1,128}")
_REG_RE = re.compile(rb"(?:HKEY_[A-Z_]+|HKCU|HKLM)\\[^\x00\r\n]{4,256}")

# Shellcode / injected code heuristics.
_SHELLCODE_SIGS: List[bytes] = [
    b"\x60\x89\xe5",           # pushad / mov ebp, esp
    b"\x31\xc0\x50\x68",       # xor eax,eax / push / push string
    b"\xfc\xe8",               # cld / call  (common in meterpreter)
    b"MZ",                     # embedded PE
    b"\x7fELF",                # embedded ELF
]

# Minimum contiguous printable string length.
_MIN_STRING_LEN = 8


def _extract_strings(data: bytes, min_len: int = _MIN_STRING_LEN) -> List[str]:
    """Extract printable ASCII strings of at least *min_len* characters."""
    results: List[str] = []
    pattern = re.compile(rb"[ -~]{%d,}" % min_len)
    for m in pattern.finditer(data):
        results.append(m.group(0).decode("ascii", errors="replace"))
    return results


def _scan_for_iocs(data: bytes) -> Dict[str, List[str]]:
    """Return network, file, and registry IOCs found in *data*."""
    ips = list({m.group(0).decode("ascii", errors="replace") for m in _IP_RE.finditer(data)})
    urls = list({m.group(0).decode("ascii", errors="replace") for m in _URL_RE.finditer(data)})
    domains = list({m.group(0).decode("ascii", errors="replace") for m in _DOMAIN_RE.finditer(data)})
    file_paths = list({m.group(0).decode("utf-8", errors="replace") for m in _WIN_PATH_RE.finditer(data)})
    reg_keys = list({m.group(0).decode("utf-8", errors="replace") for m in _REG_RE.finditer(data)})
    return {
        "ips": ips,
        "urls": urls,
        "domains": domains,
        "file_paths": file_paths,
        "registry_keys": reg_keys,
    }


def _detect_injected_code(data: bytes) -> List[Dict]:
    """
    Heuristically detect regions containing shellcode or injected PEs.

    Returns a list of dicts with ``offset``, ``signature``, and ``hex_preview``.
    """
    findings: List[Dict] = []
    for sig in _SHELLCODE_SIGS:
        idx = 0
        while True:
            pos = data.find(sig, idx)
            if pos == -1:
                break
            preview = data[pos: pos + 32].hex()
            findings.append({"offset": pos, "signature": sig.hex(), "hex_preview": preview})
            idx = pos + 1
    return findings


# ---------------------------------------------------------------------------
# MemoryScanner
# ---------------------------------------------------------------------------

class MemoryScanner:
    """
    Scan memory dump files for IOCs, injected code, and suspicious strings.
    """

    def scan(self, dump_path: str) -> Dict:
        """
        Read *dump_path* and perform a full scan.

        Args:
            dump_path: Filesystem path to a raw memory dump file.

        Returns:
            Dict with keys ``iocs``, ``injected_code``, ``strings``,
            and ``dump_path``.
        """
        path = Path(dump_path)
        if not path.exists():
            logger.error("Memory dump not found: %s", dump_path)
            return {"error": f"File not found: {dump_path}"}

        logger.info("Scanning memory dump: %s (%.1f MB)", dump_path, path.stat().st_size / 1_048_576)

        try:
            data = path.read_bytes()
        except OSError as exc:
            logger.error("Cannot read dump file: %s", exc)
            return {"error": str(exc)}

        iocs = _scan_for_iocs(data)
        injected = _detect_injected_code(data)
        strings = _extract_strings(data)

        return {
            "dump_path": dump_path,
            "size_bytes": len(data),
            "iocs": iocs,
            "injected_code_regions": injected[:50],  # cap output
            "strings": strings[:500],
        }


# ---------------------------------------------------------------------------
# Volatility 3 Runner
# ---------------------------------------------------------------------------

# Volatility 3 plugins we run by default.
_VOL_PLUGINS = [
    "windows.pslist.PsList",
    "windows.pstree.PsTree",
    "windows.netscan.NetScan",
    "windows.malfind.Malfind",
    "windows.dlllist.DllList",
    "windows.cmdline.CmdLine",
]


def _find_volatility() -> Optional[str]:
    """Return the path to vol.py or vol if available, otherwise None."""
    for candidate in ["vol", "vol.py", "volatility3"]:
        found = shutil.which(candidate)
        if found:
            return found
    # Also check common installation paths.
    for path in ["/usr/local/bin/vol", "/opt/volatility3/vol.py"]:
        if os.path.isfile(path):
            return path
    return None


class VolatilityRunner:
    """
    Run Volatility 3 plugins against a memory dump.

    Falls back gracefully when Volatility is not installed.
    """

    def __init__(self, vol_path: Optional[str] = None) -> None:
        self._vol_path = vol_path or _find_volatility()
        if self._vol_path:
            logger.info("Volatility found at: %s", self._vol_path)
        else:
            logger.info("Volatility not available; basic scanning only")

    @property
    def available(self) -> bool:
        """True if Volatility 3 is installed and executable."""
        return self._vol_path is not None

    def run_plugin(self, dump_path: str, plugin: str, timeout: int = 120) -> Dict:
        """
        Run a single Volatility plugin and return its output.

        Args:
            dump_path: Path to the memory dump.
            plugin: Volatility plugin name, e.g. ``windows.pslist.PsList``.
            timeout: Seconds before the subprocess is killed.

        Returns:
            Dict with keys ``plugin``, ``output`` (list of lines), and
            optionally ``error``.
        """
        if not self.available:
            return {"plugin": plugin, "error": "Volatility not available"}

        cmd = [self._vol_path, "-f", dump_path, plugin]
        logger.debug("Running Volatility: %s", " ".join(cmd))
        try:
            result = subprocess.run(
                cmd,
                capture_output=True,
                text=True,
                timeout=timeout,
            )
            output_lines = result.stdout.splitlines()
            return {
                "plugin": plugin,
                "output": output_lines,
                "return_code": result.returncode,
            }
        except subprocess.TimeoutExpired:
            logger.warning("Volatility plugin %s timed out", plugin)
            return {"plugin": plugin, "error": "timeout"}
        except Exception as exc:
            logger.error("Volatility plugin %s failed: %s", plugin, exc)
            return {"plugin": plugin, "error": str(exc)}

    def run_all_plugins(self, dump_path: str) -> List[Dict]:
        """Run all default Volatility plugins and collect results."""
        return [self.run_plugin(dump_path, plugin) for plugin in _VOL_PLUGINS]


# ---------------------------------------------------------------------------
# MemoryForensicsEngine
# ---------------------------------------------------------------------------

class MemoryForensicsEngine:
    """
    Top-level engine combining :class:`MemoryScanner` and
    :class:`VolatilityRunner`.
    """

    def __init__(self) -> None:
        self.scanner = MemoryScanner()
        self.volatility = VolatilityRunner()

    def analyse(self, dump_path: str, run_volatility: bool = True) -> Dict:
        """
        Perform a full memory forensics analysis.

        Args:
            dump_path: Path to the memory dump file.
            run_volatility: Whether to attempt Volatility plugin execution.

        Returns:
            Dict with keys ``scan``, ``volatility_results``, and
            ``summary_iocs``.
        """
        scan_results = self.scanner.scan(dump_path)

        vol_results: List[Dict] = []
        if run_volatility and self.volatility.available:
            vol_results = self.volatility.run_all_plugins(dump_path)
        elif run_volatility:
            logger.info("Volatility not available; skipping plugin execution")
            vol_results = [{"info": "Volatility 3 not installed; basic scanning only"}]

        # Build aggregated IOC summary from scan results.
        summary_iocs = scan_results.get("iocs", {})

        return {
            "scan": scan_results,
            "volatility_results": vol_results,
            "summary_iocs": summary_iocs,
        }
