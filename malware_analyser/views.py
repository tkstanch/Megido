"""
SECURITY WARNING: Malware Analysis Views
=========================================
This module contains STUB IMPLEMENTATIONS ONLY for educational/testing purposes.
NEVER use this code with real malware in production environments.

All scanning and cleaning functions are PLACEHOLDERS that demonstrate
the workflow but do NOT perform actual malware detection or removal.

For Production Implementation:
- Integrate with professional malware analysis tools (ClamAV, VirusTotal, etc.)
- Implement proper sandboxing and isolation
- Use secure file handling and storage
- Follow security best practices and legal compliance
"""

from django.shortcuts import render, redirect, get_object_or_404
from django.contrib.auth.decorators import login_required, user_passes_test
from django.views.decorators.csrf import csrf_protect
from django.views.decorators.http import require_http_methods
from django.http import JsonResponse, HttpResponse
from django.contrib import messages
from django.utils import timezone
from django.core.files.uploadedfile import InMemoryUploadedFile
import hashlib
import uuid
import io

from .models import ScanRecord, MalwareSignature, ActivityLog, TestMalwareSample


def get_client_ip(request):
    """Extract client IP address from request."""
    x_forwarded_for = request.META.get('HTTP_X_FORWARDED_FOR')
    if x_forwarded_for:
        ip = x_forwarded_for.split(',')[0]
    else:
        ip = request.META.get('REMOTE_ADDR')
    return ip


def log_activity(user, activity_type, description, success=True, error_message='', 
                 related_scan=None, related_signature=None, request=None):
    """Helper function to log activities."""
    ip_address = get_client_ip(request) if request else None
    user_agent = request.META.get('HTTP_USER_AGENT', '') if request else ''
    
    ActivityLog.objects.create(
        user=user,
        activity_type=activity_type,
        description=description,
        related_scan=related_scan,
        related_signature=related_signature,
        ip_address=ip_address,
        user_agent=user_agent,
        success=success,
        error_message=error_message
    )


@login_required
def malware_home(request):
    """
    Home page for Malware Analyser with important security warnings.
    """
    recent_scans = ScanRecord.objects.filter(scanned_by=request.user).order_by('-scanned_at')[:5]
    
    context = {
        'title': 'Malware Analyser',
        'recent_scans': recent_scans,
        'warning': 'STUB IMPLEMENTATION - For educational/testing purposes only',
    }
    return render(request, 'malware_analyser/home.html', context)


@login_required
@csrf_protect
@require_http_methods(["GET", "POST"])
def upload_file(request):
    """
    Handle file uploads for malware analysis.
    
    STUB IMPLEMENTATION: Accepts all file types for demonstration.
    Real implementation would need:
    - Strict file type validation
    - Size limits
    - Sandboxed storage
    - Isolated processing environment
    """
    if request.method == 'POST':
        if 'file' not in request.FILES:
            messages.error(request, 'No file provided')
            return redirect('malware_analyser:upload')
        
        uploaded_file = request.FILES['file']
        
        # Basic validation
        max_size = 100 * 1024 * 1024  # 100MB limit
        if uploaded_file.size > max_size:
            messages.error(request, 'File too large (max 100MB)')
            return redirect('malware_analyser:upload')
        
        # Create scan record
        scan = ScanRecord.objects.create(
            file_name=uploaded_file.name,
            file_size=uploaded_file.size,
            file=uploaded_file,
            scanned_by=request.user,
            scan_status='pending'
        )
        
        # Calculate file hashes
        scan.calculate_file_hashes()
        
        # Log activity
        log_activity(
            user=request.user,
            activity_type='upload',
            description=f"Uploaded file: {uploaded_file.name}",
            related_scan=scan,
            request=request
        )
        
        messages.success(request, f'File uploaded successfully. Scan ID: {scan.scan_id}')
        return redirect('malware_analyser:scan_detail', scan_id=scan.scan_id)
    
    return render(request, 'malware_analyser/upload.html', {
        'title': 'Upload File for Analysis'
    })


@login_required
def scan_detail(request, scan_id):
    """
    Display details of a specific scan.
    """
    scan = get_object_or_404(ScanRecord, scan_id=scan_id)
    
    # Check permissions
    if scan.scanned_by != request.user and not request.user.is_staff:
        messages.error(request, "You don't have permission to view this scan")
        return redirect('malware_analyser:home')
    
    context = {
        'title': f'Scan Details - {scan.file_name}',
        'scan': scan,
    }
    return render(request, 'malware_analyser/scan_detail.html', context)


@login_required
@csrf_protect
@require_http_methods(["POST"])
def perform_scan(request, scan_id):
    """
    Perform malware scan on uploaded file.
    
    CRITICAL STUB IMPLEMENTATION:
    This is a PLACEHOLDER that simulates scanning but does NOT actually detect malware.
    
    Real Implementation Requirements:
    - Integration with antivirus engines (ClamAV, etc.)
    - Sandboxed execution environment
    - Multiple scanner engines for accuracy
    - Behavioral analysis capabilities
    - Regular signature updates
    """
    scan = get_object_or_404(ScanRecord, scan_id=scan_id)
    
    # Check permissions
    if scan.scanned_by != request.user and not request.user.is_staff:
        return JsonResponse({'error': 'Permission denied'}, status=403)
    
    # Update status
    scan.scan_status = 'scanning'
    scan.save()
    
    # STUB: Simulate scanning process
    # In real implementation, this would:
    # 1. Run antivirus engine(s)
    # 2. Check against malware signatures
    # 3. Perform heuristic analysis
    # 4. Execute behavioral analysis in sandbox
    
    # Placeholder: Check against our simple signature database
    threat_detected = False
    matched_sigs = []
    
    # Check hash-based signatures
    hash_signatures = MalwareSignature.objects.filter(
        signature_type='hash',
        is_active=True
    )
    
    for sig in hash_signatures:
        if sig.signature_value == scan.file_hash_md5 or sig.signature_value == scan.file_hash_sha256:
            threat_detected = True
            matched_sigs.append(sig)
    
    # Update scan results
    scan.scan_status = 'completed'
    scan.scan_completed_at = timezone.now()
    scan.threat_detected = threat_detected
    
    if threat_detected:
        scan.threat_level = matched_sigs[0].severity if matched_sigs else 'medium'
        scan.detection_name = matched_sigs[0].name if matched_sigs else 'Unknown Threat'
        scan.matched_signatures.set(matched_sigs)
        scan.scan_details = {
            'warning': 'STUB IMPLEMENTATION - Not a real malware detection',
            'matched_signatures': [sig.name for sig in matched_sigs],
            'recommendation': 'This is a placeholder detection for testing only'
        }
    else:
        scan.threat_level = 'none'
        scan.scan_details = {
            'warning': 'STUB IMPLEMENTATION - This does not guarantee file safety',
            'note': 'No threats detected in placeholder signature database',
            'recommendation': 'Real implementation required for actual malware detection'
        }
    
    scan.save()
    
    # Log activity
    log_activity(
        user=request.user,
        activity_type='scan',
        description=f"Scanned file: {scan.file_name} - Threat: {threat_detected}",
        related_scan=scan,
        request=request
    )
    
    return JsonResponse({
        'success': True,
        'threat_detected': threat_detected,
        'threat_level': scan.threat_level,
        'detection_name': scan.detection_name,
        'redirect_url': f'/malware_analyser/scan/{scan.scan_id}/'
    })


@login_required
@csrf_protect
@require_http_methods(["POST"])
def clean_file(request, scan_id):
    """
    Attempt to clean/remove detected malware.
    
    CRITICAL STUB IMPLEMENTATION:
    This is a PLACEHOLDER that simulates cleaning but does NOT actually remove malware.
    
    Real Implementation Requirements:
    - Professional malware removal tools
    - Backup before cleaning
    - Verification after cleaning
    - Quarantine capabilities
    - Isolated processing environment
    
    WARNING: Real malware cleaning requires:
    - Deep file analysis
    - Understanding of infection vectors
    - Often impossible without file damage
    - Professional security tools
    """
    scan = get_object_or_404(ScanRecord, scan_id=scan_id)
    
    # Check permissions
    if scan.scanned_by != request.user and not request.user.is_staff:
        return JsonResponse({'error': 'Permission denied'}, status=403)
    
    if not scan.threat_detected:
        return JsonResponse({'error': 'No threat detected to clean'}, status=400)
    
    # STUB: Simulate cleaning process
    # Real implementation would:
    # 1. Create backup of file
    # 2. Identify infection type and location
    # 3. Attempt surgical removal of malicious code
    # 4. Verify file integrity
    # 5. Re-scan to confirm cleaning
    
    # Placeholder: Mark as "cleaned" for demonstration
    scan.action_taken = 'cleaned'
    scan.notes += f"\n[STUB] Cleaning attempted at {timezone.now()}. This is a placeholder action."
    scan.save()
    
    # Log activity
    log_activity(
        user=request.user,
        activity_type='clean',
        description=f"Attempted cleaning on: {scan.file_name} (STUB ONLY)",
        related_scan=scan,
        request=request
    )
    
    messages.warning(request, 'STUB: Cleaning simulated. Real implementation required for actual malware removal.')
    
    return JsonResponse({
        'success': True,
        'message': 'Cleaning simulated (STUB IMPLEMENTATION)',
        'warning': 'This is a placeholder - no actual malware removal occurred'
    })


@login_required
def scan_history(request):
    """
    Display scan history for the current user.
    """
    if request.user.is_staff:
        scans = ScanRecord.objects.all().order_by('-scanned_at')
    else:
        scans = ScanRecord.objects.filter(scanned_by=request.user).order_by('-scanned_at')
    
    context = {
        'title': 'Scan History',
        'scans': scans,
    }
    return render(request, 'malware_analyser/scan_history.html', context)


@login_required
def activity_log_view(request):
    """
    Display activity logs (staff only).
    """
    if not request.user.is_staff:
        messages.error(request, 'Staff access required')
        return redirect('malware_analyser:home')
    
    logs = ActivityLog.objects.all().order_by('-timestamp')[:100]
    
    context = {
        'title': 'Activity Logs',
        'logs': logs,
    }
    return render(request, 'malware_analyser/activity_log.html', context)


def is_staff_or_superuser(user):
    """Check if user is staff or superuser."""
    return user.is_staff or user.is_superuser


@login_required
@user_passes_test(is_staff_or_superuser)
def test_malware_generate(request):
    """
    Generate safe test malware samples for testing detection capabilities.
    
    CRITICAL SECURITY RESTRICTIONS:
    - Staff/Superuser access only
    - Generates SAFE, NON-FUNCTIONAL test data only
    - NEVER generates real malware
    - All output is clearly marked as test data
    
    Legal Notice:
    - These are safe test files only (EICAR, patterns)
    - Not functional malware
    - For testing detection systems only
    - No legal liability for safe test files
    """
    if request.method == 'POST':
        sample_type = request.POST.get('sample_type', 'placeholder')
        name = request.POST.get('name', 'Test Sample')
        description = request.POST.get('description', '')
        
        # Generate safe test content based on type
        if sample_type == 'eicar':
            test_content = TestMalwareSample.get_eicar_test_string()
            expected_detection = 'EICAR-Test-File'
        elif sample_type == 'pattern':
            test_content = 'This is a safe test file with a test pattern: TEST-MALWARE-PATTERN-123'
            expected_detection = 'Test Pattern Detection'
        else:
            test_content = 'Safe placeholder test content'
            expected_detection = 'None (Benign)'
        
        # Create test sample
        sample = TestMalwareSample.objects.create(
            name=name,
            sample_type=sample_type,
            description=description,
            test_content=test_content,
            expected_detection=expected_detection,
            created_by=request.user
        )
        
        # Log activity
        log_activity(
            user=request.user,
            activity_type='test_generate',
            description=f"Generated test sample: {name} ({sample_type})",
            request=request
        )
        
        messages.success(request, f'Test sample "{name}" created successfully (SAFE TEST DATA ONLY)')
        return redirect('malware_analyser:test_samples')
    
    context = {
        'title': 'Generate Test Malware Sample (Safe Only)',
        'warning': 'Only generates SAFE, non-functional test data for detection testing',
    }
    return render(request, 'malware_analyser/test_generate.html', context)


@login_required
@user_passes_test(is_staff_or_superuser)
def test_samples_list(request):
    """
    List all test malware samples (staff only).
    """
    samples = TestMalwareSample.objects.filter(is_active=True).order_by('-created_at')
    
    context = {
        'title': 'Test Malware Samples (Safe Test Data)',
        'samples': samples,
    }
    return render(request, 'malware_analyser/test_samples.html', context)


@login_required
@user_passes_test(is_staff_or_superuser)
def download_test_sample(request, sample_id):
    """
    Download a test malware sample.
    Safe test content only - no real malware.
    """
    sample = get_object_or_404(TestMalwareSample, sample_id=sample_id)
    
    # Update usage tracking
    sample.times_used += 1
    sample.last_used = timezone.now()
    sample.save()
    
    # Create file response with safe test content
    filename = f"{sample.name.replace(' ', '_')}.{sample.file_extension}"
    response = HttpResponse(sample.test_content, content_type='text/plain')
    response['Content-Disposition'] = f'attachment; filename="{filename}"'
    response['X-Content-Type-Options'] = 'nosniff'
    
    # Add warning header
    response['X-Warning'] = 'Safe test file only - not real malware'
    
    # Log activity
    log_activity(
        user=request.user,
        activity_type='admin_action',
        description=f"Downloaded test sample: {sample.name}",
        request=request
    )
    
    return response


@login_required
@user_passes_test(is_staff_or_superuser)
def manage_signatures(request):
    """
    Manage malware signatures (staff only).
    """
    if request.method == 'POST':
        name = request.POST.get('name')
        signature_type = request.POST.get('signature_type')
        signature_value = request.POST.get('signature_value')
        description = request.POST.get('description', '')
        severity = request.POST.get('severity', 'medium')
        
        signature = MalwareSignature.objects.create(
            name=name,
            signature_type=signature_type,
            signature_value=signature_value,
            description=description,
            severity=severity,
            created_by=request.user
        )
        
        # Log activity
        log_activity(
            user=request.user,
            activity_type='signature_create',
            description=f"Created signature: {name}",
            related_signature=signature,
            request=request
        )
        
        messages.success(request, f'Signature "{name}" created successfully')
        return redirect('malware_analyser:manage_signatures')
    
    signatures = MalwareSignature.objects.filter(is_active=True).order_by('-created_at')
    
    context = {
        'title': 'Manage Malware Signatures',
        'signatures': signatures,
    }
    return render(request, 'malware_analyser/manage_signatures.html', context)
