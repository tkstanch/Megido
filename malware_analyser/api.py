"""
DRF REST API for the malware analyser application.

STUB IMPLEMENTATION - All analysis logic is delegated to Celery tasks.
No actual malware is analysed. See models.py for full legal/ethical notices.

URL patterns are exposed via the module-level ``urlpatterns`` list and should
be included from the project's root ``urls.py``::

    path('api/v1/malware/', include('malware_analyser.api')),
"""

import logging
import uuid
from typing import Any, Dict

from django.conf import settings
from django.utils import timezone
from rest_framework import serializers, status
from rest_framework.authentication import SessionAuthentication, TokenAuthentication
from rest_framework.parsers import MultiPartParser
from rest_framework.permissions import IsAuthenticated
from rest_framework.response import Response
from rest_framework.views import APIView
from django.urls import path

logger = logging.getLogger(__name__)


# =============================================================================
# Serializers
# =============================================================================

class FileUploadSerializer(serializers.Serializer):
    """Serializer for the file-upload endpoint."""

    file = serializers.FileField(help_text="File to be analysed.")


class AnalysisTriggerSerializer(serializers.Serializer):
    """Optional parameters when triggering a full analysis."""

    sandbox_type = serializers.ChoiceField(
        choices=["docker", "vm", "none"],
        default="docker",
        required=False,
    )
    priority = serializers.IntegerField(min_value=1, max_value=5, default=3, required=False)


class YaraRuleUploadSerializer(serializers.Serializer):
    """Serializer for uploading custom YARA rules."""

    rule_name = serializers.CharField(max_length=255)
    rule_content = serializers.CharField(help_text="Raw YARA rule text.")
    description = serializers.CharField(required=False, allow_blank=True, default="")


class BatchHashLookupSerializer(serializers.Serializer):
    """Serializer for batch threat-intel hash lookups."""

    hashes = serializers.ListField(
        child=serializers.CharField(min_length=32, max_length=64),
        min_length=1,
        max_length=100,
    )


class FileUploadResponseSerializer(serializers.Serializer):
    """Read serializer for a FileUpload model instance."""

    file_id = serializers.UUIDField()
    original_filename = serializers.CharField()
    file_size = serializers.IntegerField()
    file_hash_md5 = serializers.CharField()
    file_hash_sha256 = serializers.CharField()
    mime_type = serializers.CharField()
    uploaded_at = serializers.DateTimeField()
    scan_status = serializers.CharField()


# =============================================================================
# Shared helpers
# =============================================================================

_DEFAULT_AUTH = [TokenAuthentication, SessionAuthentication]
_DEFAULT_PERM = [IsAuthenticated]


def _std_auth_view(cls):
    """Class decorator: inject default authentication/permission classes."""
    cls.authentication_classes = _DEFAULT_AUTH
    cls.permission_classes = _DEFAULT_PERM
    return cls


def _get_file_or_404(file_id: str):
    """Return a FileUpload instance or raise Http404."""
    from malware_analyser.models import FileUpload
    from django.http import Http404

    try:
        uid = uuid.UUID(str(file_id))
    except ValueError as exc:
        raise Http404("Invalid file_id format.") from exc
    try:
        return FileUpload.objects.get(file_id=uid)
    except FileUpload.DoesNotExist as exc:
        raise Http404(f"File {file_id!r} not found.") from exc


def _get_task_result(task_id: str) -> Dict[str, Any]:
    """
    Return a simplified Celery task status dict.

    Falls back gracefully if Celery / Redis is unavailable.
    """
    try:
        from celery.result import AsyncResult

        result = AsyncResult(task_id)
        return {
            "task_id": task_id,
            "state": result.state,
            "info": result.info if isinstance(result.info, dict) else {},
        }
    except Exception as exc:  # noqa: BLE001
        logger.warning("Could not retrieve task result for %s: %s", task_id, exc)
        return {"task_id": task_id, "state": "UNKNOWN", "info": {}}


# =============================================================================
# Endpoint views
# =============================================================================

@_std_auth_view
class FileUploadView(APIView):
    """
    POST /api/v1/malware/upload/

    Upload a file for malware analysis.  Returns the generated ``file_id``.
    """

    parser_classes = [MultiPartParser]

    def post(self, request) -> Response:
        ser = FileUploadSerializer(data=request.data)
        if not ser.is_valid():
            return Response(ser.errors, status=status.HTTP_400_BAD_REQUEST)

        uploaded_file = ser.validated_data["file"]

        from malware_analyser.models import FileUpload
        import mimetypes

        mime_type, _ = mimetypes.guess_type(uploaded_file.name)

        file_obj = FileUpload.objects.create(
            original_filename=uploaded_file.name,
            file=uploaded_file,
            file_size=uploaded_file.size,
            mime_type=mime_type or "application/octet-stream",
            uploaded_by=request.user,
        )
        file_obj.calculate_hashes()

        logger.info(
            "File uploaded by %s: %s (id=%s)", request.user, file_obj.original_filename, file_obj.file_id
        )

        out = FileUploadResponseSerializer(file_obj)
        return Response(out.data, status=status.HTTP_201_CREATED)


@_std_auth_view
class AnalyzeTriggerView(APIView):
    """
    POST /api/v1/malware/{file_id}/analyze/

    Trigger an asynchronous full analysis pipeline.  Returns ``task_id``.
    """

    def post(self, request, file_id: str) -> Response:
        file_obj = _get_file_or_404(file_id)
        ser = AnalysisTriggerSerializer(data=request.data)
        if not ser.is_valid():
            return Response(ser.errors, status=status.HTTP_400_BAD_REQUEST)

        from malware_analyser.tasks import async_full_analysis

        try:
            task = async_full_analysis.delay(str(file_obj.file_id))
            logger.info("Analysis task %s queued for file %s", task.id, file_id)
            return Response(
                {
                    "task_id": task.id,
                    "file_id": str(file_obj.file_id),
                    "status": "queued",
                },
                status=status.HTTP_202_ACCEPTED,
            )
        except Exception as exc:  # noqa: BLE001
            logger.exception("Failed to queue analysis task for %s", file_id)
            return Response(
                {"detail": f"Could not queue analysis task: {exc}"},
                status=status.HTTP_503_SERVICE_UNAVAILABLE,
            )


@_std_auth_view
class AnalysisStatusView(APIView):
    """
    GET /api/v1/malware/{file_id}/status/

    Return the current scan status and Celery task progress (if a
    ``task_id`` query-parameter is provided).
    """

    def get(self, request, file_id: str) -> Response:
        file_obj = _get_file_or_404(file_id)
        task_id = request.query_params.get("task_id")

        payload: Dict[str, Any] = {
            "file_id": str(file_obj.file_id),
            "scan_status": file_obj.scan_status,
            "is_scanned": file_obj.is_scanned,
        }
        if task_id:
            payload["task"] = _get_task_result(task_id)

        return Response(payload)


@_std_auth_view
class AnalysisReportView(APIView):
    """
    GET /api/v1/malware/{file_id}/report/

    Return the full analysis report.  Supports ``?format=stix`` and
    ``?format=misp`` query parameters.
    """

    def get(self, request, file_id: str) -> Response:
        file_obj = _get_file_or_404(file_id)
        report_format = request.query_params.get("format", "json").lower()

        from malware_analyser.models import ScanResult

        scan_qs = ScanResult.objects.filter(file=file_obj).order_by("-started_at")
        latest_scan = scan_qs.first()

        report: Dict[str, Any] = {
            "file_id": str(file_obj.file_id),
            "filename": file_obj.original_filename,
            "md5": file_obj.file_hash_md5,
            "sha256": file_obj.file_hash_sha256,
            "scan_status": file_obj.scan_status,
            "report_format": report_format,
            "scan_result": None,
        }

        if latest_scan:
            report["scan_result"] = {
                "scan_id": str(latest_scan.scan_id),
                "scan_type": latest_scan.scan_type,
                "is_malicious": latest_scan.is_malicious,
                "threat_level": latest_scan.threat_level,
                "detected_malware": latest_scan.detected_malware,
                "scan_details": latest_scan.scan_details,
                "started_at": latest_scan.started_at,
                "completed_at": latest_scan.completed_at,
            }

        if report_format == "stix":
            report["stix_bundle"] = _build_stix_stub(file_obj, latest_scan)
        elif report_format == "misp":
            report["misp_event"] = _build_misp_stub(file_obj, latest_scan)

        return Response(report)


@_std_auth_view
class YaraMatchesView(APIView):
    """
    GET /api/v1/malware/{file_id}/yara-matches/

    Return YARA match details for the given file.
    """

    def get(self, request, file_id: str) -> Response:
        file_obj = _get_file_or_404(file_id)

        from malware_analyser.models import ScanResult

        latest_scan = ScanResult.objects.filter(file=file_obj).order_by("-started_at").first()
        yara_matches: Any = []

        if latest_scan and hasattr(latest_scan, "static_analysis"):
            yara_matches = latest_scan.static_analysis.yara_matches

        return Response(
            {
                "file_id": str(file_obj.file_id),
                "yara_matches": yara_matches,
            }
        )


@_std_auth_view
class MalwareConfigView(APIView):
    """
    GET /api/v1/malware/{file_id}/config/

    Return extracted malware configuration.
    """

    def get(self, request, file_id: str) -> Response:
        file_obj = _get_file_or_404(file_id)

        from malware_analyser.models import ScanResult

        latest_scan = ScanResult.objects.filter(file=file_obj).order_by("-started_at").first()
        config: Dict[str, Any] = {}

        if latest_scan:
            config = latest_scan.scan_details.get("malware_config", {})

        return Response({"file_id": str(file_obj.file_id), "config": config})


@_std_auth_view
class IOCView(APIView):
    """
    GET /api/v1/malware/{file_id}/iocs/

    Return extracted Indicators of Compromise.
    """

    def get(self, request, file_id: str) -> Response:
        file_obj = _get_file_or_404(file_id)

        from malware_analyser.models import AnalysisReport, ScanResult

        latest_scan = ScanResult.objects.filter(file=file_obj).order_by("-started_at").first()
        iocs: Dict[str, Any] = {}

        if latest_scan:
            report = AnalysisReport.objects.filter(scan_result=latest_scan).first()
            if report:
                iocs = report.indicators_of_compromise

        return Response({"file_id": str(file_obj.file_id), "iocs": iocs})


@_std_auth_view
class NetworkAnalysisView(APIView):
    """
    GET /api/v1/malware/{file_id}/network/

    Return network analysis results from dynamic analysis.
    """

    def get(self, request, file_id: str) -> Response:
        file_obj = _get_file_or_404(file_id)

        from malware_analyser.models import ScanResult

        latest_scan = ScanResult.objects.filter(file=file_obj).order_by("-started_at").first()
        network: Dict[str, Any] = {
            "dns_queries": [],
            "http_requests": [],
            "network_connections": [],
        }

        if latest_scan and hasattr(latest_scan, "dynamic_analysis"):
            da = latest_scan.dynamic_analysis
            network = {
                "dns_queries": da.dns_queries,
                "http_requests": da.http_requests,
                "network_connections": da.network_connections,
            }

        return Response({"file_id": str(file_obj.file_id), "network": network})


@_std_auth_view
class MitreAttackView(APIView):
    """
    GET /api/v1/malware/{file_id}/mitre-attack/

    Return the MITRE ATT&CK technique mapping for the given file.
    """

    def get(self, request, file_id: str) -> Response:
        file_obj = _get_file_or_404(file_id)

        from malware_analyser.models import ScanResult

        latest_scan = ScanResult.objects.filter(file=file_obj).order_by("-started_at").first()
        attack_mapping: Any = []

        if latest_scan:
            attack_mapping = latest_scan.scan_details.get("mitre_attack", [])

        return Response(
            {
                "file_id": str(file_obj.file_id),
                "mitre_attack_techniques": attack_mapping,
            }
        )


@_std_auth_view
class YaraRuleUploadView(APIView):
    """
    POST /api/v1/malware/yara-rules/

    Upload a custom YARA rule to the platform signature library.
    """

    def post(self, request) -> Response:
        ser = YaraRuleUploadSerializer(data=request.data)
        if not ser.is_valid():
            return Response(ser.errors, status=status.HTTP_400_BAD_REQUEST)

        from malware_analyser.models import MalwareSignature

        sig = MalwareSignature.objects.create(
            name=ser.validated_data["rule_name"],
            signature_type="yara",
            signature_data=ser.validated_data["rule_content"],
            description=ser.validated_data.get("description", ""),
            created_by=request.user,
        )
        logger.info("YARA rule %s uploaded by %s", sig.name, request.user)

        return Response(
            {
                "id": sig.pk,
                "name": sig.name,
                "created_at": sig.created_at,
            },
            status=status.HTTP_201_CREATED,
        )


@_std_auth_view
class PlatformStatsView(APIView):
    """
    GET /api/v1/malware/stats/

    Return aggregate platform statistics.
    """

    def get(self, request) -> Response:
        from malware_analyser.models import FileUpload, ScanResult

        total_files = FileUpload.objects.count()
        total_scans = ScanResult.objects.count()
        malicious_count = ScanResult.objects.filter(is_malicious=True).count()

        return Response(
            {
                "total_files_uploaded": total_files,
                "total_scans": total_scans,
                "malicious_detected": malicious_count,
                "clean": total_scans - malicious_count,
            }
        )


@_std_auth_view
class BatchHashLookupView(APIView):
    """
    POST /api/v1/malware/batch-lookup/

    Perform batch hash lookups against threat intelligence sources
    via an asynchronous Celery task.
    """

    def post(self, request) -> Response:
        ser = BatchHashLookupSerializer(data=request.data)
        if not ser.is_valid():
            return Response(ser.errors, status=status.HTTP_400_BAD_REQUEST)

        from malware_analyser.tasks import async_threat_intel_lookup

        hashes = ser.validated_data["hashes"]
        try:
            task = async_threat_intel_lookup.delay(hashes)
            return Response(
                {"task_id": task.id, "hashes_queued": len(hashes)},
                status=status.HTTP_202_ACCEPTED,
            )
        except Exception as exc:  # noqa: BLE001
            logger.exception("Failed to queue batch hash lookup")
            return Response(
                {"detail": f"Could not queue batch lookup: {exc}"},
                status=status.HTTP_503_SERVICE_UNAVAILABLE,
            )


# =============================================================================
# Private STIX / MISP stub builders
# =============================================================================

def _build_stix_stub(file_obj, scan_result) -> Dict[str, Any]:
    """Return a minimal STIX 2.1 bundle stub."""
    return {
        "type": "bundle",
        "id": f"bundle--{uuid.uuid4()}",
        "spec_version": "2.1",
        "objects": [
            {
                "type": "file",
                "id": f"file--{uuid.uuid4()}",
                "name": file_obj.original_filename,
                "hashes": {
                    "MD5": file_obj.file_hash_md5,
                    "SHA-256": file_obj.file_hash_sha256,
                },
            }
        ],
        "_note": "STUB – populate with real intelligence data in production.",
    }


def _build_misp_stub(file_obj, scan_result) -> Dict[str, Any]:
    """Return a minimal MISP event stub."""
    return {
        "Event": {
            "info": f"Malware analysis – {file_obj.original_filename}",
            "Attribute": [
                {"type": "md5", "value": file_obj.file_hash_md5},
                {"type": "sha256", "value": file_obj.file_hash_sha256},
                {"type": "filename", "value": file_obj.original_filename},
            ],
            "_note": "STUB – populate with real intelligence data in production.",
        }
    }


# =============================================================================
# URL patterns
# =============================================================================

urlpatterns = [
    path("upload/", FileUploadView.as_view(), name="malware-upload"),
    path("<str:file_id>/analyze/", AnalyzeTriggerView.as_view(), name="malware-analyze"),
    path("<str:file_id>/status/", AnalysisStatusView.as_view(), name="malware-status"),
    path("<str:file_id>/report/", AnalysisReportView.as_view(), name="malware-report"),
    path("<str:file_id>/yara-matches/", YaraMatchesView.as_view(), name="malware-yara-matches"),
    path("<str:file_id>/config/", MalwareConfigView.as_view(), name="malware-config"),
    path("<str:file_id>/iocs/", IOCView.as_view(), name="malware-iocs"),
    path("<str:file_id>/network/", NetworkAnalysisView.as_view(), name="malware-network"),
    path("<str:file_id>/mitre-attack/", MitreAttackView.as_view(), name="malware-mitre"),
    path("yara-rules/", YaraRuleUploadView.as_view(), name="malware-yara-rules"),
    path("stats/", PlatformStatsView.as_view(), name="malware-stats"),
    path("batch-lookup/", BatchHashLookupView.as_view(), name="malware-batch-lookup"),
]
