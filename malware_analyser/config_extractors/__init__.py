"""
Config extractors package for malware configuration extraction.

Provides a registry of extractor classes that can parse embedded
configurations from malware samples.
"""
import logging
from abc import ABC, abstractmethod
from typing import List, Optional, Type

logger = logging.getLogger(__name__)


class BaseConfigExtractor(ABC):
    """Abstract base class for all malware config extractors."""

    name: str = "base"
    family: str = "unknown"

    @abstractmethod
    def can_extract(self, sample_data: bytes) -> bool:
        """
        Determine whether this extractor can handle the given sample.

        Args:
            sample_data: Raw bytes of the sample.

        Returns:
            True if this extractor recognises the sample, False otherwise.
        """

    @abstractmethod
    def extract(self, sample_data: bytes) -> dict:
        """
        Extract configuration from the sample.

        Args:
            sample_data: Raw bytes of the sample.

        Returns:
            Dictionary containing the extracted configuration fields.
            Returns an empty dict when extraction fails.
        """


class ExtractorRegistry:
    """Auto-discovery registry for :class:`BaseConfigExtractor` subclasses."""

    def __init__(self) -> None:
        self._extractors: List[Type[BaseConfigExtractor]] = []

    def register(self, extractor_cls: Type[BaseConfigExtractor]) -> Type[BaseConfigExtractor]:
        """Register an extractor class.  Can be used as a decorator."""
        if extractor_cls not in self._extractors:
            self._extractors.append(extractor_cls)
            logger.debug("Registered config extractor: %s", extractor_cls.name)
        return extractor_cls

    def get_all(self) -> List[Type[BaseConfigExtractor]]:
        """Return all registered extractor classes."""
        return list(self._extractors)

    def extract_all(self, sample_data: bytes) -> List[dict]:
        """
        Run every applicable extractor against *sample_data*.

        Returns:
            List of result dicts from extractors that succeeded.
        """
        results = []
        for cls in self._extractors:
            extractor = cls()
            try:
                if extractor.can_extract(sample_data):
                    config = extractor.extract(sample_data)
                    if config:
                        config.setdefault("extractor", cls.name)
                        config.setdefault("family", cls.family)
                        results.append(config)
            except Exception:
                logger.exception("Extractor %s raised an exception", cls.name)
        return results


# Global registry instance
registry = ExtractorRegistry()

# ---------------------------------------------------------------------------
# Auto-discovery: import all sibling modules so their @registry.register
# decorators (or explicit registry.register() calls) fire automatically.
# ---------------------------------------------------------------------------
import importlib
import pkgutil
import os as _os

_package_dir = _os.path.dirname(__file__)
for _module_info in pkgutil.iter_modules([_package_dir]):
    if _module_info.name.startswith("_"):
        continue
    try:
        importlib.import_module(f"{__name__}.{_module_info.name}")
    except ImportError:
        logger.warning("Could not import config extractor module: %s", _module_info.name)

__all__ = [
    "BaseConfigExtractor",
    "ExtractorRegistry",
    "registry",
]
