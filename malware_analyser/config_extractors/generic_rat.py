"""
Generic RAT (Remote Access Trojan) configuration extractor.

Scans samples for common RAT indicators regardless of specific family:
  - Embedded IP:port pairs
  - Hardcoded domain names
  - Base64-encoded configuration blobs
  - Mutex names used for single-instance enforcement
  - Registry run-key persistence paths
"""
import base64
import logging
import re
from typing import List, Optional

from . import BaseConfigExtractor, registry

logger = logging.getLogger(__name__)

# ---------------------------------------------------------------------------
# Compiled patterns
# ---------------------------------------------------------------------------

_IP_PORT_RE = re.compile(
    rb"(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}"
    rb"(?:25[0-5]|2[0-4]\d|[01]?\d\d?)"
    rb"[:\x00](\d{1,5})"
)

_BARE_IP_RE = re.compile(
    rb"(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}"
    rb"(?:25[0-5]|2[0-4]\d|[01]?\d\d?)"
)

_DOMAIN_RE = re.compile(
    rb"(?:[a-zA-Z0-9](?:[a-zA-Z0-9\-]{0,61}[a-zA-Z0-9])?\.)+"
    rb"(?:com|net|org|info|biz|ru|cn|pw|top|xyz|club|tk|ml|ga|cf|gq)"
    rb"(?=[\x00\r\n \"'<>\x09]|$)"
)

# Base64 blobs of at least 64 characters.
_B64_RE = re.compile(rb"[A-Za-z0-9+/]{64,}={0,2}")

# Common mutex names used by popular RAT families.
_MUTEX_PATTERNS: List[bytes] = [
    b"DCRat",
    b"AsyncRat",
    b"NjRAT",
    b"QuasarRAT",
    b"CrimsonRAT",
    b"RemcosRAT",
    b"Remcos",
    b"DarkComet",
    b"Poison_Ivy",
    b"PoisonIvy",
    b"XtremeRAT",
    b"jRAT",
    b"_PERSIST_",
    b"MUTEX_",
    b"Global\\",
    b"Local\\",
]

# Registry persistence key fragments.
_REG_PERSIST_PATTERNS: List[bytes] = [
    b"Software\\Microsoft\\Windows\\CurrentVersion\\Run",
    b"Software\\Microsoft\\Windows\\CurrentVersion\\RunOnce",
    b"SYSTEM\\CurrentControlSet\\Services",
    b"SOFTWARE\\Microsoft\\Active Setup\\Installed Components",
    b"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon",
    b"SOFTWARE\\Classes\\",
    b"HKCU\\",
    b"HKLM\\",
    b"HKEY_LOCAL_MACHINE\\",
    b"HKEY_CURRENT_USER\\",
]

# Minimum port threshold to filter obviously invalid values.
_MIN_PORT = 1
_MAX_PORT = 65535

# Ports that are almost certainly false-positives (e.g. packed integers).
_COMMON_FP_PORTS = {0, 80, 443, 8080, 8443}


def _extract_ip_ports(data: bytes) -> List[str]:
    """Return unique IP:port strings found in *data*."""
    results: List[str] = []
    seen = set()
    for m in _IP_PORT_RE.finditer(data):
        try:
            port = int(m.group(1))
        except ValueError:
            continue
        if _MIN_PORT <= port <= _MAX_PORT and port not in _COMMON_FP_PORTS:
            full_match = m.group(0).decode("ascii", errors="replace")
            if full_match not in seen:
                seen.add(full_match)
                results.append(full_match)
    # Bare IPs (no port).
    for m in _BARE_IP_RE.finditer(data):
        ip = m.group(0).decode("ascii", errors="replace")
        if ip not in seen:
            seen.add(ip)
            results.append(ip)
    return results


def _extract_domains(data: bytes) -> List[str]:
    """Return unique domain names found in *data*."""
    seen = set()
    results: List[str] = []
    for m in _DOMAIN_RE.finditer(data):
        domain = m.group(0).decode("ascii", errors="replace").lower()
        if domain not in seen:
            seen.add(domain)
            results.append(domain)
    return results


def _extract_base64_configs(data: bytes) -> List[str]:
    """
    Find base64 blobs and attempt to decode them.

    Returns the decoded content (as a printable string) when it contains
    useful ASCII characters (printable ratio > 70 %).
    """
    decoded_blobs: List[str] = []
    for m in _B64_RE.finditer(data):
        raw_b64 = m.group(0)
        # Pad if necessary.
        padding = (4 - len(raw_b64) % 4) % 4
        try:
            decoded = base64.b64decode(raw_b64 + b"=" * padding)
        except Exception:
            continue
        if len(decoded) < 4:
            continue
        printable = sum(32 <= b < 127 for b in decoded)
        if printable / len(decoded) > 0.70:
            decoded_blobs.append(decoded.decode("ascii", errors="replace"))
    return decoded_blobs


def _extract_mutexes(data: bytes) -> List[str]:
    """Return known mutex strings found in *data*."""
    found: List[str] = []
    for pattern in _MUTEX_PATTERNS:
        idx = data.find(pattern)
        while idx != -1:
            # Read up to 64 bytes to capture the full mutex name.
            end = data.find(b"\x00", idx)
            if end == -1 or end - idx > 64:
                end = idx + 64
            candidate = data[idx:end].decode("utf-8", errors="replace")
            if candidate not in found:
                found.append(candidate)
            idx = data.find(pattern, idx + 1)
    return found


def _extract_registry_keys(data: bytes) -> List[str]:
    """Return registry persistence key strings found in *data*."""
    found: List[str] = []
    for pattern in _REG_PERSIST_PATTERNS:
        idx = data.find(pattern)
        while idx != -1:
            end = data.find(b"\x00", idx)
            if end == -1 or end - idx > 256:
                end = idx + 256
            candidate = data[idx:end].decode("utf-8", errors="replace")
            if candidate not in found:
                found.append(candidate)
            idx = data.find(pattern, idx + 1)
    return found


@registry.register
class GenericRATExtractor(BaseConfigExtractor):
    """Broad-spectrum extractor for generic RAT configuration artefacts."""

    name = "generic_rat"
    family = "GenericRAT"

    # This extractor is intentionally permissive â€” it is a last-resort scanner.
    _MINIMUM_RESULTS = 1

    def can_extract(self, sample_data: bytes) -> bool:
        """
        Accept any sample that contains at least one RAT indicator.

        This extractor intentionally runs on most executables; more specific
        extractors (e.g. CobaltStrike, Emotet) should be registered first so
        that they take priority.
        """
        if _BARE_IP_RE.search(sample_data):
            return True
        if _DOMAIN_RE.search(sample_data):
            return True
        for p in _MUTEX_PATTERNS:
            if p in sample_data:
                return True
        return False

    def extract(self, sample_data: bytes) -> dict:
        """
        Extract generic RAT configuration artefacts.

        Returns:
            Dictionary with keys ``ip_ports``, ``domains``,
            ``base64_configs``, ``mutexes``, and ``registry_keys``.
        """
        ip_ports = _extract_ip_ports(sample_data)
        domains = _extract_domains(sample_data)
        b64_configs = _extract_base64_configs(sample_data)
        mutexes = _extract_mutexes(sample_data)
        reg_keys = _extract_registry_keys(sample_data)

        if not any([ip_ports, domains, b64_configs, mutexes, reg_keys]):
            return {}

        result: dict = {
            "ip_ports": ip_ports,
            "domains": domains,
            "base64_configs": b64_configs,
            "mutexes": mutexes,
            "registry_keys": reg_keys,
        }
        logger.info(
            "Generic RAT scan: %d IPs, %d domains, %d mutexes, %d reg keys",
            len(ip_ports),
            len(domains),
            len(mutexes),
            len(reg_keys),
        )
        return result
