"""
Cobalt Strike beacon configuration extractor.

Supports XOR-encoded configs from Cobalt Strike versions 3.x / 4.x.
"""
import logging
import re
import struct
from typing import List, Optional

from . import BaseConfigExtractor, registry

logger = logging.getLogger(__name__)

# Magic patterns that appear in Cobalt Strike beacon payloads.
_CS_MAGIC_PATTERNS: List[bytes] = [
    b"\x00\x01\x00\x01\x00\x02",   # 3.x / 4.x watermark region
    b"%%IMPORT%%",
    b"ReflectiveLoader",
    b"beacon.dll",
]

# Single-byte XOR keys to try when hunting for the config block.
_XOR_KEYS = list(range(1, 256))

# Cobalt Strike config setting IDs mapped to human-readable names.
_SETTING_NAMES = {
    1:  "beacon_type",
    2:  "port",
    3:  "sleep_time",
    4:  "max_get_size",
    5:  "jitter",
    6:  "max_dns",
    7:  "public_key",
    8:  "server_and_port",
    9:  "host_header",
    10: "useragent_header",
    11: "http_get_uri",
    12: "http_unk_header",
    13: "http_post_uri",
    14: "http_post_chunk",
    15: "spawn_to_x86",
    16: "spawn_to_x64",
    17: "cfg_caution_flag",
    18: "kill_date",
    19: "dns_sleep",
    20: "dns_idle",
    28: "http_method_path2",
    29: "http_post_chunk2",
    37: "watermark",
    40: "inject_options",
    50: "ssh_port",
    51: "ssh_banner",
    52: "ssh_key",
}

# Beacon type constants.
_BEACON_TYPES = {
    0:  "HTTP",
    1:  "Hybrid HTTP and DNS",
    2:  "SMB",
    8:  "HTTPS",
    16: "TCP",
}

# XOR key applied to the entire 4096-byte config block in many builds.
_CONFIG_BLOCK_XOR = 0x69


def _xor_decode(data: bytes, key: int) -> bytes:
    """XOR-decode *data* with a single-byte *key*."""
    return bytes(b ^ key for b in data)


def _find_config_block(data: bytes, xor_key: int = _CONFIG_BLOCK_XOR) -> Optional[bytes]:
    """
    Search for a Cobalt Strike 4096-byte config block encoded with *xor_key*.

    The decoded block starts with the 4-byte sequence ``\\x00\\x01\\x00\\x01``.
    """
    decoded = _xor_decode(data, xor_key)
    target = b"\x00\x01\x00\x01"
    idx = decoded.find(target)
    if idx == -1:
        return None
    return decoded[idx: idx + 4096]


def _parse_config_block(block: bytes) -> dict:
    """Parse a raw (decoded) 4096-byte Cobalt Strike config block."""
    config: dict = {}
    offset = 0
    length = len(block)

    while offset + 6 <= length:
        setting_id = struct.unpack_from(">H", block, offset)[0]
        setting_type = struct.unpack_from(">H", block, offset + 2)[0]
        setting_len = struct.unpack_from(">H", block, offset + 4)[0]
        offset += 6

        if setting_id == 0:
            break
        if offset + setting_len > length:
            break

        raw = block[offset: offset + setting_len]
        offset += setting_len

        name = _SETTING_NAMES.get(setting_id, f"setting_{setting_id}")

        if setting_type == 1:  # short
            val = struct.unpack_from(">H", raw)[0] if len(raw) >= 2 else None
        elif setting_type == 2:  # int
            val = struct.unpack_from(">I", raw)[0] if len(raw) >= 4 else None
        else:  # bytes / string
            val = raw.rstrip(b"\x00").decode("utf-8", errors="replace")

        if val is not None:
            config[name] = val

    return config


def _extract_c2_urls(config: dict) -> List[str]:
    """Parse C2 URL(s) from the raw config dictionary."""
    urls: List[str] = []
    server_raw = config.get("server_and_port", "")
    if server_raw:
        for entry in str(server_raw).split(","):
            entry = entry.strip()
            if entry:
                urls.append(entry)
    return urls


@registry.register
class CobaltStrikeExtractor(BaseConfigExtractor):
    """Extract configuration from Cobalt Strike beacon payloads."""

    name = "cobalt_strike"
    family = "CobaltStrike"

    def can_extract(self, sample_data: bytes) -> bool:
        """Return True if any Cobalt Strike magic pattern is present."""
        for pattern in _CS_MAGIC_PATTERNS:
            if pattern in sample_data:
                return True
        # Also attempt heuristic: does XOR-0x69 decode reveal the config header?
        return _find_config_block(sample_data) is not None

    def extract(self, sample_data: bytes) -> dict:
        """
        Extract Cobalt Strike beacon configuration.

        Tries the standard XOR-0x69 key first, then falls back to a brute-force
        single-byte XOR search.
        """
        block = _find_config_block(sample_data, _CONFIG_BLOCK_XOR)

        if block is None:
            # Brute-force other single-byte XOR keys.
            for key in _XOR_KEYS:
                if key == _CONFIG_BLOCK_XOR:
                    continue
                block = _find_config_block(sample_data, key)
                if block:
                    logger.debug("CS config found with XOR key 0x%02x", key)
                    break

        if block is None:
            logger.debug("No Cobalt Strike config block found")
            return {}

        raw_config = _parse_config_block(block)
        if not raw_config:
            return {}

        result: dict = {
            "c2_urls": _extract_c2_urls(raw_config),
            "raw_settings": raw_config,
        }

        # Normalise well-known fields.
        if "sleep_time" in raw_config:
            result["sleep_time_ms"] = raw_config["sleep_time"]
        if "jitter" in raw_config:
            result["jitter_percent"] = raw_config["jitter"]
        if "useragent_header" in raw_config:
            result["user_agent"] = raw_config["useragent_header"]
        if "watermark" in raw_config:
            result["watermark"] = raw_config["watermark"]
        if "public_key" in raw_config:
            result["public_key"] = raw_config["public_key"]

        beacon_type_id = raw_config.get("beacon_type")
        if beacon_type_id is not None:
            result["beacon_type"] = _BEACON_TYPES.get(int(beacon_type_id), str(beacon_type_id))

        logger.info("Extracted Cobalt Strike config: %d C2 URLs", len(result["c2_urls"]))
        return result
