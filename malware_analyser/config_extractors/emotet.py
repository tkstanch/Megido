"""
Emotet malware configuration extractor.

Supports multiple Emotet variants / epochs including the post-2021 comeback
(Epoch 4/5) and older builds.
"""
import logging
import re
import struct
from typing import List, Optional, Tuple

from . import BaseConfigExtractor, registry

logger = logging.getLogger(__name__)

# ------------------------------------------------------------------
# Heuristic signatures for Emotet recognition
# ------------------------------------------------------------------

# Emotet frequently contains these import names.
_EMOTET_IMPORTS = [
    b"BCryptDecrypt",
    b"BCryptGenerateSymmetricKey",
    b"BCryptOpenAlgorithmProvider",
]

# Byte patterns typical of Emotet's network initialisation.
_EMOTET_PATTERNS = [
    b"\x85\xC0\x0F\x84",  # test eax, eax / jz  (common in payload loop)
    b"Content-Type: application/x-www-form-urlencoded",
]

# Campaign IDs observed in the wild (used for rough epoch detection).
_KNOWN_CAMPAIGNS = {
    b"Epoch1": "Epoch1",
    b"Epoch2": "Epoch2",
    b"Epoch3": "Epoch3",
    b"Epoch4": "Epoch4",
    b"Epoch5": "Epoch5",
}

# C2 list offset heuristic: Emotet stores a packed array of
# (IP uint32 LE, port uint16 BE) tuples, usually preceded by a 4-byte count.
_C2_RECORD_FMT = "<IH"  # IP (LE), port (BE â€” actually LE in newer builds)
_C2_RECORD_SIZE = struct.calcsize(_C2_RECORD_FMT)


def _ip_from_uint(n: int) -> str:
    """Convert a little-endian 32-bit integer to dotted-quad notation."""
    return ".".join(str((n >> (8 * i)) & 0xFF) for i in range(4))


def _extract_c2_list_v1(data: bytes) -> List[str]:
    """
    Extract C2 IP:port pairs from an older Emotet build.

    Scans for a valid ``count`` DWORD followed by that many IP+port records.
    """
    c2_list: List[str] = []
    for offset in range(0, len(data) - 4):
        count = struct.unpack_from("<I", data, offset)[0]
        if count < 1 or count > 512:
            continue
        end = offset + 4 + count * _C2_RECORD_SIZE
        if end > len(data):
            continue
        candidates: List[str] = []
        ok = True
        for i in range(count):
            rec_off = offset + 4 + i * _C2_RECORD_SIZE
            ip_int, port = struct.unpack_from(_C2_RECORD_FMT, data, rec_off)
            if port == 0 or port > 65535:
                ok = False
                break
            ip_str = _ip_from_uint(ip_int)
            # Filter obviously invalid IPs.
            first_octet = ip_int & 0xFF
            if first_octet == 0 or first_octet == 255:
                ok = False
                break
            candidates.append(f"{ip_str}:{port}")
        if ok and candidates:
            c2_list.extend(candidates)
            break
    return c2_list


_IP_PORT_RE = re.compile(
    rb"(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)"
    rb"[:\x00]"
    rb"(\d{1,5})"
)


def _extract_c2_list_v2(data: bytes) -> List[str]:
    """
    Fallback C2 extraction using printable IP:port regex patterns.

    Used for newer Emotet epochs and string-table variants.
    """
    results: List[str] = []
    for m in re.finditer(
        rb"(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)"
        rb"(?::\d{1,5})?",
        data,
    ):
        entry = m.group(0).decode("ascii", errors="replace")
        if entry not in results:
            results.append(entry)
    return results


def _detect_epoch(data: bytes) -> Optional[str]:
    """Heuristically identify the Emotet epoch / campaign."""
    for marker, label in _KNOWN_CAMPAIGNS.items():
        if marker in data:
            return label
    # Post-2021 builds are commonly identified by the presence of ECC keys.
    if b"bcrypt.dll" in data.lower() or b"BCryptDecrypt" in data:
        return "Epoch4/5"
    return None


def _extract_keys(data: bytes) -> List[str]:
    """Extract potential RSA/ECC key blobs (rough heuristic)."""
    keys: List[str] = []
    # PEM-like markers in memory.
    for marker in [b"-----BEGIN", b"RSAPUBLICKEY", b"ECPublicKey"]:
        idx = data.find(marker)
        if idx != -1:
            snippet = data[idx: idx + 128].rstrip(b"\x00")
            keys.append(snippet.decode("utf-8", errors="replace"))
    return keys


@registry.register
class EmotetExtractor(BaseConfigExtractor):
    """Extract C2 list, encryption keys and campaign ID from Emotet samples."""

    name = "emotet"
    family = "Emotet"

    def can_extract(self, sample_data: bytes) -> bool:
        """Return True if the sample shows Emotet characteristics."""
        hit_count = sum(1 for p in _EMOTET_IMPORTS if p in sample_data)
        if hit_count >= 2:
            return True
        hit_count = sum(1 for p in _EMOTET_PATTERNS if p in sample_data)
        return hit_count >= 1

    def extract(self, sample_data: bytes) -> dict:
        """
        Extract Emotet configuration.

        Returns:
            Dictionary with keys ``c2_list``, ``encryption_keys``,
            ``campaign_id``, and ``epoch``.
        """
        # Try structured extraction first, fall back to regex.
        c2_list = _extract_c2_list_v1(sample_data)
        if not c2_list:
            c2_list = _extract_c2_list_v2(sample_data)

        epoch = _detect_epoch(sample_data)
        keys = _extract_keys(sample_data)

        # Campaign ID: sometimes stored as a 4-byte integer immediately after
        # a known marker.  This is a rough heuristic.
        campaign_id: Optional[str] = None
        for marker in [b"CampaignID", b"campaign_id", b"camp_id"]:
            idx = sample_data.find(marker)
            if idx != -1 and idx + len(marker) + 4 <= len(sample_data):
                raw = sample_data[idx + len(marker): idx + len(marker) + 4]
                try:
                    campaign_id = str(struct.unpack_from("<I", raw)[0])
                except struct.error:
                    pass
                break

        if not c2_list and not keys and epoch is None:
            return {}

        result: dict = {
            "c2_list": c2_list,
            "encryption_keys": keys,
            "campaign_id": campaign_id,
            "epoch": epoch,
        }
        logger.info("Extracted Emotet config: %d C2 endpoints, epoch=%s", len(c2_list), epoch)
        return result
