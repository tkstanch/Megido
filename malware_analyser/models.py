"""
SECURITY WARNING: Malware Analysis Models
==========================================
This module contains STUB IMPLEMENTATIONS ONLY for educational/testing purposes.
NEVER use this code with real malware in production environments.

Legal Notice:
- Handling real malware requires proper licensing, security measures, and legal authorization
- This implementation uses safe placeholders only
- Real malware analysis requires isolated environments (air-gapped, VM-based sandboxes)
- Consult legal counsel before implementing real malware handling capabilities

For Production Implementation:
- Use professional malware analysis platforms (ClamAV, VirusTotal API, etc.)
- Implement proper sandboxing and isolation
- Follow industry security standards (NIST, OWASP)
- Obtain necessary legal authorizations
"""

from django.db import models
from django.contrib.auth.models import User
from django.utils import timezone
import uuid
import hashlib


class MalwareSignature(models.Model):
    """
    Model for storing custom malware signatures and definitions.
    
    STUB IMPLEMENTATION: This is a simplified placeholder for educational purposes.
    Real implementation would include:
    - Integration with malware signature databases (ClamAV, YARA rules)
    - Regular updates from threat intelligence feeds
    - Machine learning-based detection patterns
    """
    signature_id = models.UUIDField(default=uuid.uuid4, editable=False, unique=True)
    name = models.CharField(max_length=255, help_text="Signature name")
    signature_type = models.CharField(max_length=50, choices=[
        ('hash', 'File Hash (MD5/SHA256)'),
        ('pattern', 'Byte Pattern/String'),
        ('heuristic', 'Heuristic Rule'),
        ('behavioral', 'Behavioral Pattern'),
    ])
    signature_value = models.TextField(help_text="Signature data (hash, pattern, or rule)")
    description = models.TextField(blank=True)
    severity = models.CharField(max_length=20, choices=[
        ('low', 'Low'),
        ('medium', 'Medium'),
        ('high', 'High'),
        ('critical', 'Critical'),
    ], default='medium')
    is_active = models.BooleanField(default=True)
    created_by = models.ForeignKey(User, on_delete=models.SET_NULL, null=True, related_name='created_signatures')
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    
    class Meta:
        ordering = ['-created_at']
        indexes = [
            models.Index(fields=['signature_type', 'is_active']),
        ]
    
    def __str__(self):
        return f"{self.name} ({self.signature_type})"


class ScanRecord(models.Model):
    """
    Model for tracking malware scan history and results.
    
    STUB IMPLEMENTATION: Real implementation would integrate with:
    - Professional antivirus engines
    - Sandboxed analysis environments
    - Multi-scanner aggregation (VirusTotal API)
    """
    scan_id = models.UUIDField(default=uuid.uuid4, editable=False, unique=True)
    file_name = models.CharField(max_length=255)
    file_hash_md5 = models.CharField(max_length=32, blank=True)
    file_hash_sha256 = models.CharField(max_length=64, blank=True)
    file_size = models.BigIntegerField(help_text="File size in bytes")
    file = models.FileField(upload_to='malware_analysis/', blank=True, null=True)
    
    # Scan metadata
    scanned_by = models.ForeignKey(User, on_delete=models.CASCADE, related_name='malware_scans')
    scanned_at = models.DateTimeField(auto_now_add=True)
    scan_completed_at = models.DateTimeField(null=True, blank=True)
    
    # Scan results (STUB - placeholder only)
    scan_status = models.CharField(max_length=20, choices=[
        ('pending', 'Pending'),
        ('scanning', 'Scanning'),
        ('completed', 'Completed'),
        ('error', 'Error'),
    ], default='pending')
    
    threat_detected = models.BooleanField(default=False)
    threat_level = models.CharField(max_length=20, choices=[
        ('none', 'No Threat'),
        ('low', 'Low Risk'),
        ('medium', 'Medium Risk'),
        ('high', 'High Risk'),
        ('critical', 'Critical'),
    ], default='none')
    
    detection_name = models.CharField(max_length=255, blank=True, help_text="Name of detected threat")
    matched_signatures = models.ManyToManyField(MalwareSignature, blank=True, related_name='scan_matches')
    
    # Analysis results (STUB)
    scan_details = models.JSONField(default=dict, blank=True, help_text="Detailed scan results")
    
    # Action taken
    action_taken = models.CharField(max_length=50, choices=[
        ('none', 'No Action'),
        ('quarantine', 'Quarantined'),
        ('cleaned', 'Cleaned'),
        ('deleted', 'Deleted'),
        ('flagged', 'Flagged for Review'),
    ], default='none')
    
    notes = models.TextField(blank=True)
    
    class Meta:
        ordering = ['-scanned_at']
        indexes = [
            models.Index(fields=['scanned_by', 'scanned_at']),
            models.Index(fields=['threat_detected', 'scanned_at']),
        ]
    
    def __str__(self):
        return f"Scan {self.scan_id} - {self.file_name}"
    
    def calculate_file_hashes(self):
        """
        Calculate MD5 and SHA256 hashes of the uploaded file.
        Note: In real implementation, this should be done in isolated environment.
        """
        if self.file:
            md5_hash = hashlib.md5()
            sha256_hash = hashlib.sha256()
            
            for chunk in self.file.chunks():
                md5_hash.update(chunk)
                sha256_hash.update(chunk)
            
            self.file_hash_md5 = md5_hash.hexdigest()
            self.file_hash_sha256 = sha256_hash.hexdigest()
            self.save()


class ActivityLog(models.Model):
    """
    Model for logging all malware analysis activities for audit trail.
    
    Security: Maintains comprehensive audit trail of all actions.
    """
    log_id = models.UUIDField(default=uuid.uuid4, editable=False, unique=True)
    user = models.ForeignKey(User, on_delete=models.SET_NULL, null=True, related_name='malware_activities')
    activity_type = models.CharField(max_length=50, choices=[
        ('upload', 'File Upload'),
        ('scan', 'Malware Scan'),
        ('clean', 'Cleaning Attempt'),
        ('quarantine', 'Quarantine'),
        ('delete', 'Delete'),
        ('signature_create', 'Signature Created'),
        ('signature_update', 'Signature Updated'),
        ('test_generate', 'Test Sample Generated'),
        ('admin_action', 'Administrative Action'),
    ])
    description = models.TextField()
    related_scan = models.ForeignKey(ScanRecord, on_delete=models.SET_NULL, null=True, blank=True, related_name='activity_logs')
    related_signature = models.ForeignKey(MalwareSignature, on_delete=models.SET_NULL, null=True, blank=True, related_name='activity_logs')
    
    # Metadata
    ip_address = models.GenericIPAddressField(null=True, blank=True)
    user_agent = models.CharField(max_length=512, blank=True)
    timestamp = models.DateTimeField(auto_now_add=True)
    
    # Result
    success = models.BooleanField(default=True)
    error_message = models.TextField(blank=True)
    
    class Meta:
        ordering = ['-timestamp']
        indexes = [
            models.Index(fields=['user', 'timestamp']),
            models.Index(fields=['activity_type', 'timestamp']),
        ]
    
    def __str__(self):
        return f"{self.activity_type} by {self.user} at {self.timestamp}"


class TestMalwareSample(models.Model):
    """
    Model for safe, non-functional test samples for educational purposes.
    
    CRITICAL SECURITY WARNING:
    - This model stores ONLY SAFE, NON-FUNCTIONAL test data
    - NEVER store real malware code or functional malicious payloads
    - All samples are PLACEHOLDERS for testing detection capabilities
    - Staff/Superuser access only
    
    Real Implementation Requirements:
    - Isolated storage (separate encrypted volume)
    - Access controls and monitoring
    - Legal compliance (authorization, liability)
    - Professional security measures
    """
    sample_id = models.UUIDField(default=uuid.uuid4, editable=False, unique=True)
    name = models.CharField(max_length=255, help_text="Test sample name (descriptive only)")
    sample_type = models.CharField(max_length=50, choices=[
        ('eicar', 'EICAR Test File (Safe Standard Test)'),
        ('pattern', 'Pattern-Based Test'),
        ('benign', 'Benign Test File'),
        ('placeholder', 'Placeholder/Stub'),
    ], default='placeholder')
    
    description = models.TextField(help_text="Description of what this sample tests")
    
    # Safe test content only
    test_content = models.TextField(blank=True, help_text="SAFE test content - NO REAL MALWARE")
    file_extension = models.CharField(max_length=10, default='txt')
    expected_detection = models.CharField(max_length=255, blank=True, help_text="Expected detection result")
    
    # Metadata
    created_by = models.ForeignKey(User, on_delete=models.SET_NULL, null=True, related_name='test_samples')
    created_at = models.DateTimeField(auto_now_add=True)
    is_active = models.BooleanField(default=True)
    
    # Usage tracking
    times_used = models.IntegerField(default=0)
    last_used = models.DateTimeField(null=True, blank=True)
    
    class Meta:
        ordering = ['-created_at']
        permissions = [
            ('generate_test_samples', 'Can generate test malware samples'),
        ]
    
    def __str__(self):
        return f"{self.name} ({self.sample_type})"
    
    @staticmethod
    def get_eicar_test_string():
        """
        Returns the standard EICAR test string.
        This is a safe, industry-standard test file recognized by all antivirus software.
        It is NOT malware and is completely safe.
        """
        return "X5O!P%@AP[4\\PZX54(P^)7CC)7}$EICAR-STANDARD-ANTIVIRUS-TEST-FILE!$H+H*"
