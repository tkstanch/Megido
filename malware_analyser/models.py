"""
MALWARE ANALYSER MODELS

⚠️  CRITICAL SAFETY AND LEGAL NOTICE ⚠️

This module contains STUB/DEMONSTRATION code for malware analysis functionality.
NO ACTUAL MALWARE is created, distributed, or analyzed by this code.

LEGAL WARNINGS:
1. Creating, distributing, or using malware without authorization is ILLEGAL in most jurisdictions
2. Unauthorized computer access is a criminal offense under laws like:
   - Computer Fraud and Abuse Act (CFAA) - USA
   - Computer Misuse Act - UK
   - Council of Europe Convention on Cybercrime - International
3. This code is for EDUCATIONAL PURPOSES ONLY in controlled environments
4. Users are responsible for compliance with all applicable laws and regulations

ETHICAL GUIDELINES:
- Only use in authorized testing environments
- Obtain proper authorization before any security testing
- Never deploy against systems you don't own/have permission to test
- Follow responsible disclosure practices
- Respect privacy and data protection laws

TECHNICAL NOTES:
- All malware detection logic uses STUB implementations
- All malware generation logic uses STUB implementations
- Test artifacts created are benign demonstration files only
- Production use requires integration with real security tools
"""

from django.db import models
from django.contrib.auth.models import User
from django.core.validators import FileExtensionValidator
from django.utils import timezone
import uuid
import hashlib


class MalwareSignature(models.Model):
    """
    Model for storing malware signatures used in signature-based detection.
    
    STUB IMPLEMENTATION: In production, this would integrate with malware
    signature databases like YARA rules, ClamAV signatures, or custom patterns.
    
    Security: This is demonstration code only. Real signatures would come from
    trusted threat intelligence sources.
    """
    name = models.CharField(max_length=255, help_text="Name of the malware signature")
    signature_type = models.CharField(
        max_length=50,
        choices=[
            ('hash', 'File Hash'),
            ('pattern', 'Byte Pattern'),
            ('yara', 'YARA Rule'),
            ('behavior', 'Behavioral Signature'),
        ],
        default='hash'
    )
    signature_data = models.TextField(help_text="Signature data (hash, pattern, or rule)")
    severity = models.CharField(
        max_length=20,
        choices=[
            ('low', 'Low'),
            ('medium', 'Medium'),
            ('high', 'High'),
            ('critical', 'Critical'),
        ],
        default='medium'
    )
    description = models.TextField(blank=True)
    malware_family = models.CharField(max_length=255, blank=True, help_text="Known malware family")
    is_active = models.BooleanField(default=True)
    created_at = models.DateTimeField(auto_now_add=True)
    created_by = models.ForeignKey(User, on_delete=models.SET_NULL, null=True, related_name='signatures')
    
    class Meta:
        ordering = ['-created_at']
        indexes = [
            models.Index(fields=['signature_type', 'is_active']),
        ]
    
    def __str__(self):
        return f"{self.name} ({self.get_signature_type_display()})"


class FileUpload(models.Model):
    """
    Model for storing uploaded files for malware scanning.
    
    ACCEPTS ALL FILE TYPES as per requirements.
    
    Security Notes:
    - Files stored with UUID names to prevent path traversal
    - Original filenames sanitized
    - Access control enforced
    - Scan status tracked
    """
    file_id = models.UUIDField(default=uuid.uuid4, editable=False, unique=True, primary_key=True)
    original_filename = models.CharField(max_length=500)
    file = models.FileField(upload_to='malware_analyser_uploads/')
    file_size = models.BigIntegerField(help_text="File size in bytes")
    file_hash_md5 = models.CharField(max_length=32, blank=True)
    file_hash_sha256 = models.CharField(max_length=64, blank=True)
    mime_type = models.CharField(max_length=255, blank=True)
    uploaded_by = models.ForeignKey(User, on_delete=models.CASCADE, related_name='uploaded_files')
    uploaded_at = models.DateTimeField(auto_now_add=True)
    is_scanned = models.BooleanField(default=False)
    scan_status = models.CharField(
        max_length=20,
        choices=[
            ('pending', 'Pending Scan'),
            ('scanning', 'Scanning'),
            ('clean', 'Clean'),
            ('infected', 'Infected'),
            ('error', 'Scan Error'),
        ],
        default='pending'
    )
    
    class Meta:
        ordering = ['-uploaded_at']
        indexes = [
            models.Index(fields=['uploaded_by', 'uploaded_at']),
            models.Index(fields=['scan_status']),
            models.Index(fields=['file_hash_sha256']),
        ]
    
    def __str__(self):
        return f"{self.original_filename} - {self.scan_status}"
    
    def calculate_hashes(self):
        """Calculate file hashes for signature matching (STUB)."""
        # STUB: In production, this would read the actual file
        # For now, we generate a pseudo-hash based on filename and size
        content = f"{self.original_filename}{self.file_size}".encode()
        self.file_hash_md5 = hashlib.md5(content).hexdigest()
        self.file_hash_sha256 = hashlib.sha256(content).hexdigest()
        self.save()


class ScanResult(models.Model):
    """
    Model for storing scan results.
    
    STUB IMPLEMENTATION: Real scanning would integrate with:
    - ClamAV or similar antivirus engines
    - YARA rule matching
    - Sandboxing systems (Cuckoo, ANY.RUN)
    - Behavioral analysis tools
    - Threat intelligence platforms
    """
    scan_id = models.UUIDField(default=uuid.uuid4, editable=False, unique=True)
    file = models.ForeignKey(FileUpload, on_delete=models.CASCADE, related_name='scan_results')
    scan_type = models.CharField(
        max_length=50,
        choices=[
            ('signature', 'Signature-based'),
            ('heuristic', 'Heuristic'),
            ('behavioral', 'Behavioral'),
            ('full', 'Full Scan'),
        ],
        default='full'
    )
    started_at = models.DateTimeField(auto_now_add=True)
    completed_at = models.DateTimeField(null=True, blank=True)
    is_malicious = models.BooleanField(default=False)
    threat_level = models.CharField(
        max_length=20,
        choices=[
            ('none', 'No Threat'),
            ('low', 'Low'),
            ('medium', 'Medium'),
            ('high', 'High'),
            ('critical', 'Critical'),
        ],
        default='none'
    )
    detected_malware = models.CharField(max_length=255, blank=True, help_text="Name of detected malware")
    matched_signatures = models.ManyToManyField(MalwareSignature, blank=True, related_name='scan_results')
    scan_details = models.JSONField(default=dict, blank=True, help_text="Detailed scan information")
    performed_by = models.ForeignKey(User, on_delete=models.SET_NULL, null=True, related_name='scans')
    
    class Meta:
        ordering = ['-started_at']
        indexes = [
            models.Index(fields=['file', 'started_at']),
            models.Index(fields=['is_malicious']),
        ]
    
    def __str__(self):
        return f"Scan {self.scan_id} - {self.file.original_filename} ({'Malicious' if self.is_malicious else 'Clean'})"


class CleaningLog(models.Model):
    """
    Model for tracking malware cleaning/removal operations.
    
    STUB IMPLEMENTATION: Real cleaning would involve:
    - Quarantine procedures
    - Safe file deletion
    - Registry cleaning (Windows)
    - Process termination
    - System restoration
    
    Security: In production, cleaning operations must be carefully designed
    to avoid system damage or data loss.
    """
    cleaning_id = models.UUIDField(default=uuid.uuid4, editable=False, unique=True)
    scan_result = models.ForeignKey(ScanResult, on_delete=models.CASCADE, related_name='cleaning_logs')
    file = models.ForeignKey(FileUpload, on_delete=models.CASCADE, related_name='cleaning_logs')
    cleaning_action = models.CharField(
        max_length=50,
        choices=[
            ('quarantine', 'Quarantine'),
            ('delete', 'Delete'),
            ('clean', 'Clean/Disinfect'),
            ('restore', 'Restore from Quarantine'),
        ],
        default='quarantine'
    )
    performed_at = models.DateTimeField(auto_now_add=True)
    performed_by = models.ForeignKey(User, on_delete=models.SET_NULL, null=True, related_name='cleaning_actions')
    success = models.BooleanField(default=False)
    action_details = models.TextField(blank=True, help_text="Details of cleaning action performed")
    backup_location = models.CharField(max_length=500, blank=True, help_text="Backup/quarantine location")
    
    class Meta:
        ordering = ['-performed_at']
    
    def __str__(self):
        status = "Success" if self.success else "Failed"
        return f"{self.get_cleaning_action_display()} - {self.file.original_filename} ({status})"


class TestMalwareArtifact(models.Model):
    """
    Model for tracking TEST malware artifacts created for safe testing.
    
    ⚠️  CRITICAL WARNING ⚠️
    This functionality is RESTRICTED to authorized staff/superusers only.
    
    LEGAL AND ETHICAL REQUIREMENTS:
    1. Only use in isolated, authorized testing environments
    2. Never distribute outside controlled environment
    3. Obtain proper authorization before creation
    4. Follow organizational security policies
    5. Document all usage for audit purposes
    
    STUB IMPLEMENTATION: This creates benign demonstration files only.
    Real implementation would require:
    - Air-gapped/isolated systems
    - Comprehensive audit logging
    - Secure storage with encryption
    - Access control and MFA
    - Legal review and approval
    - Compliance with applicable laws
    
    NO ACTUAL MALWARE IS CREATED BY THIS STUB CODE.
    """
    artifact_id = models.UUIDField(default=uuid.uuid4, editable=False, unique=True, primary_key=True)
    name = models.CharField(max_length=255, help_text="Name of the test artifact")
    artifact_type = models.CharField(
        max_length=50,
        choices=[
            ('benign_test', 'Benign Test File'),
            ('eicar_test', 'EICAR Test String'),
            ('custom_pattern', 'Custom Pattern Test'),
        ],
        default='benign_test',
        help_text="Type of test artifact (STUB - all are benign)"
    )
    description = models.TextField(help_text="Description of the test artifact and its purpose")
    file_content = models.TextField(blank=True, help_text="Content of the test artifact (if text-based)")
    file_path = models.CharField(max_length=500, blank=True, help_text="Path to stored test file")
    created_at = models.DateTimeField(auto_now_add=True)
    created_by = models.ForeignKey(
        User, 
        on_delete=models.SET_NULL, 
        null=True, 
        related_name='test_artifacts',
        help_text="MUST be staff/superuser"
    )
    purpose = models.TextField(help_text="Documented purpose for creating this test artifact")
    authorization_reference = models.CharField(
        max_length=255, 
        blank=True,
        help_text="Reference to authorization/approval"
    )
    is_active = models.BooleanField(default=True)
    destroyed_at = models.DateTimeField(null=True, blank=True, help_text="When artifact was safely destroyed")
    
    class Meta:
        ordering = ['-created_at']
        permissions = [
            ('can_create_test_malware', 'Can create test malware artifacts'),
        ]
    
    def __str__(self):
        return f"Test Artifact: {self.name} (Created: {self.created_at.strftime('%Y-%m-%d')})"
    
    def generate_eicar_test(self):
        """
        Generate the standard EICAR test string.
        
        The EICAR test file is an industry-standard, non-malicious test file
        recognized by antivirus software. It is safe and legal to use for testing.
        
        Reference: https://www.eicar.org/download-anti-malware-testfile/
        """
        # EICAR Standard Anti-Virus Test File
        self.file_content = r'X5O!P%@AP[4\PZX54(P^)7CC)7}$EICAR-STANDARD-ANTIVIRUS-TEST-FILE!$H+H*'
        self.artifact_type = 'eicar_test'
        self.save()
    
    def generate_benign_test(self):
        """Generate a benign test file for testing purposes (STUB)."""
        self.file_content = f"BENIGN TEST FILE\nCreated: {timezone.now()}\nPurpose: {self.purpose}"
        self.artifact_type = 'benign_test'
        self.save()


class AuditLog(models.Model):
    """
    Comprehensive audit logging for all malware analyser operations.
    
    Critical for:
    - Security incident response
    - Compliance requirements
    - Forensic analysis
    - Access control verification
    """
    log_id = models.UUIDField(default=uuid.uuid4, editable=False, unique=True)
    timestamp = models.DateTimeField(auto_now_add=True)
    user = models.ForeignKey(User, on_delete=models.SET_NULL, null=True, blank=True)
    action = models.CharField(max_length=100)
    resource_type = models.CharField(max_length=50)
    resource_id = models.CharField(max_length=100, blank=True)
    ip_address = models.GenericIPAddressField(null=True, blank=True)
    user_agent = models.CharField(max_length=500, blank=True)
    details = models.JSONField(default=dict, blank=True)
    success = models.BooleanField(default=True)
    error_message = models.TextField(blank=True)
    
    class Meta:
        ordering = ['-timestamp']
        indexes = [
            models.Index(fields=['user', 'timestamp']),
            models.Index(fields=['action', 'timestamp']),
            models.Index(fields=['resource_type', 'resource_id']),
        ]
    
    def __str__(self):
        return f"{self.action} by {self.user} at {self.timestamp}"


class AnalysisGoal(models.Model):
    """
    Model for defining malware analysis goals and objectives.
    
    Analysis goals help guide the investigation and define success criteria.
    Common goals include: identification, functionality analysis, IOCs, attribution.
    """
    GOAL_TYPES = [
        ('identification', 'Malware Identification'),
        ('functionality', 'Functionality Analysis'),
        ('iocs', 'IOC Extraction'),
        ('attribution', 'Attribution & Origin'),
        ('behavior', 'Behavior Analysis'),
        ('impact', 'Impact Assessment'),
        ('custom', 'Custom Goal'),
    ]
    
    goal_id = models.UUIDField(default=uuid.uuid4, editable=False, unique=True, primary_key=True)
    name = models.CharField(max_length=255, help_text="Goal name/title")
    goal_type = models.CharField(max_length=50, choices=GOAL_TYPES, default='identification')
    description = models.TextField(help_text="Detailed description of the analysis goal")
    priority = models.IntegerField(
        default=3,
        choices=[(1, 'Critical'), (2, 'High'), (3, 'Medium'), (4, 'Low')],
        help_text="Goal priority level"
    )
    is_default = models.BooleanField(default=False, help_text="Default goal for new analyses")
    created_at = models.DateTimeField(auto_now_add=True)
    created_by = models.ForeignKey(User, on_delete=models.SET_NULL, null=True, related_name='analysis_goals')
    
    class Meta:
        ordering = ['priority', '-created_at']
    
    def __str__(self):
        return f"{self.name} ({self.get_goal_type_display()})"


class AnalysisTechnique(models.Model):
    """
    Model for documenting malware analysis techniques and methodologies.
    
    Tracks which techniques are used in each analysis and provides guidance.
    """
    TECHNIQUE_CATEGORIES = [
        ('basic_static', 'Basic Static Analysis'),
        ('basic_dynamic', 'Basic Dynamic Analysis'),
        ('advanced_static', 'Advanced Static Analysis'),
        ('advanced_dynamic', 'Advanced Dynamic Analysis'),
    ]
    
    technique_id = models.UUIDField(default=uuid.uuid4, editable=False, unique=True, primary_key=True)
    name = models.CharField(max_length=255, help_text="Technique name")
    category = models.CharField(max_length=50, choices=TECHNIQUE_CATEGORIES)
    description = models.TextField(help_text="Detailed description of the technique")
    guidance = models.TextField(help_text="Step-by-step guidance for applying this technique")
    tools_required = models.JSONField(default=list, blank=True, help_text="List of tools needed")
    documentation_url = models.URLField(blank=True, help_text="Link to detailed documentation")
    is_active = models.BooleanField(default=True)
    created_at = models.DateTimeField(auto_now_add=True)
    
    class Meta:
        ordering = ['category', 'name']
    
    def __str__(self):
        return f"{self.name} ({self.get_category_display()})"


class MalwareType(models.Model):
    """
    Model for malware classification types and families.
    
    Used for auto-classification and enrichment of malware samples.
    """
    TYPE_CATEGORIES = [
        ('virus', 'Virus'),
        ('worm', 'Worm'),
        ('trojan', 'Trojan'),
        ('ransomware', 'Ransomware'),
        ('spyware', 'Spyware'),
        ('adware', 'Adware'),
        ('rootkit', 'Rootkit'),
        ('backdoor', 'Backdoor'),
        ('botnet', 'Botnet'),
        ('keylogger', 'Keylogger'),
        ('cryptominer', 'Cryptominer'),
        ('rat', 'Remote Access Trojan (RAT)'),
        ('dropper', 'Dropper'),
        ('loader', 'Loader'),
        ('other', 'Other'),
    ]
    
    type_id = models.UUIDField(default=uuid.uuid4, editable=False, unique=True, primary_key=True)
    name = models.CharField(max_length=255, help_text="Malware type/family name")
    category = models.CharField(max_length=50, choices=TYPE_CATEGORIES)
    description = models.TextField(help_text="Description of this malware type")
    characteristics = models.JSONField(default=dict, help_text="Key characteristics and behaviors")
    detection_patterns = models.JSONField(default=list, help_text="Detection patterns for classification")
    is_active = models.BooleanField(default=True)
    created_at = models.DateTimeField(auto_now_add=True)
    
    class Meta:
        ordering = ['category', 'name']
    
    def __str__(self):
        return f"{self.name} ({self.get_category_display()})"


class BestPractice(models.Model):
    """
    Model for storing safety best practices and guidelines.
    
    Provides in-app reminders and checklists for safe malware analysis.
    """
    PRACTICE_CATEGORIES = [
        ('isolation', 'Isolation & Containment'),
        ('vm_setup', 'Virtual Machine Setup'),
        ('networking', 'Network Configuration'),
        ('snapshots', 'Snapshots & Backups'),
        ('monitoring', 'Monitoring & Logging'),
        ('cleanup', 'Cleanup & Disposal'),
        ('legal', 'Legal & Compliance'),
        ('general', 'General Safety'),
    ]
    
    practice_id = models.UUIDField(default=uuid.uuid4, editable=False, unique=True, primary_key=True)
    title = models.CharField(max_length=255, help_text="Best practice title")
    category = models.CharField(max_length=50, choices=PRACTICE_CATEGORIES)
    description = models.TextField(help_text="Detailed description of the best practice")
    checklist_items = models.JSONField(default=list, help_text="List of checklist items")
    severity = models.CharField(
        max_length=20,
        choices=[('critical', 'Critical'), ('high', 'High'), ('medium', 'Medium'), ('low', 'Low')],
        default='medium'
    )
    is_mandatory = models.BooleanField(default=False, help_text="Must be acknowledged before analysis")
    display_order = models.IntegerField(default=0)
    is_active = models.BooleanField(default=True)
    created_at = models.DateTimeField(auto_now_add=True)
    
    class Meta:
        ordering = ['display_order', 'category']
    
    def __str__(self):
        return f"{self.title} ({self.get_category_display()})"


class StaticAnalysisResult(models.Model):
    """
    Model for storing static analysis results.
    
    Captures results from basic and advanced static analysis techniques.
    """
    analysis_id = models.UUIDField(default=uuid.uuid4, editable=False, unique=True, primary_key=True)
    scan_result = models.OneToOneField(ScanResult, on_delete=models.CASCADE, related_name='static_analysis')
    
    # Hash values
    md5_hash = models.CharField(max_length=32, blank=True)
    sha1_hash = models.CharField(max_length=40, blank=True)
    sha256_hash = models.CharField(max_length=64, blank=True)
    
    # Strings extraction
    strings_extracted = models.TextField(blank=True, help_text="Extracted strings from file")
    suspicious_strings = models.JSONField(default=list, help_text="Suspicious strings identified")
    
    # PE analysis (Windows executables)
    pe_data = models.JSONField(default=dict, blank=True, help_text="PE header information")
    dependencies = models.JSONField(default=list, help_text="DLL dependencies")
    imports = models.JSONField(default=list, help_text="Imported functions")
    exports = models.JSONField(default=list, help_text="Exported functions")
    
    # Packing/Obfuscation
    is_packed = models.BooleanField(default=False)
    packer_detected = models.CharField(max_length=255, blank=True)
    entropy = models.FloatField(null=True, blank=True, help_text="File entropy (0-8)")
    unpacking_suggestions = models.TextField(blank=True)
    
    # YARA/Sigma rules
    yara_matches = models.JSONField(default=list, help_text="Matched YARA rules")
    sigma_matches = models.JSONField(default=list, help_text="Matched Sigma rules")
    
    # Disassembly/Decompilation
    disassembly_summary = models.TextField(blank=True)
    code_similarity_matches = models.JSONField(default=list, help_text="Similar code samples found")
    
    analyzed_at = models.DateTimeField(auto_now_add=True)
    techniques_used = models.ManyToManyField(AnalysisTechnique, blank=True, related_name='static_analyses')
    
    class Meta:
        ordering = ['-analyzed_at']
    
    def __str__(self):
        return f"Static Analysis for {self.scan_result.file.original_filename}"


class DynamicAnalysisResult(models.Model):
    """
    Model for storing dynamic analysis results.
    
    Captures results from sandbox execution and runtime monitoring.
    """
    analysis_id = models.UUIDField(default=uuid.uuid4, editable=False, unique=True, primary_key=True)
    scan_result = models.OneToOneField(ScanResult, on_delete=models.CASCADE, related_name='dynamic_analysis')
    
    # Sandbox execution
    sandbox_status = models.CharField(
        max_length=50,
        choices=[
            ('pending', 'Pending'),
            ('running', 'Running'),
            ('completed', 'Completed'),
            ('failed', 'Failed'),
            ('timeout', 'Timeout'),
        ],
        default='pending'
    )
    execution_time = models.FloatField(null=True, blank=True, help_text="Execution time in seconds")
    
    # Process monitoring
    processes_created = models.JSONField(default=list, help_text="Processes created during execution")
    child_processes = models.JSONField(default=list)
    
    # Filesystem monitoring
    files_created = models.JSONField(default=list)
    files_modified = models.JSONField(default=list)
    files_deleted = models.JSONField(default=list)
    
    # Registry monitoring (Windows)
    registry_keys_created = models.JSONField(default=list)
    registry_keys_modified = models.JSONField(default=list)
    registry_keys_deleted = models.JSONField(default=list)
    
    # Network monitoring
    network_connections = models.JSONField(default=list, help_text="Network connections made")
    dns_queries = models.JSONField(default=list)
    http_requests = models.JSONField(default=list)
    
    # Suspicious events
    anti_vm_detected = models.BooleanField(default=False)
    anti_debug_detected = models.BooleanField(default=False)
    injection_detected = models.BooleanField(default=False)
    evasion_attempts = models.JSONField(default=list)
    suspicious_api_calls = models.JSONField(default=list)
    
    # API tracing
    api_trace = models.JSONField(default=list, help_text="Traced API calls")
    
    # Memory analysis
    memory_dumps = models.JSONField(default=list, help_text="Memory dump file paths")
    memory_iocs = models.JSONField(default=list, help_text="IOCs extracted from memory")
    
    analyzed_at = models.DateTimeField(auto_now_add=True)
    techniques_used = models.ManyToManyField(AnalysisTechnique, blank=True, related_name='dynamic_analyses')
    
    class Meta:
        ordering = ['-analyzed_at']
    
    def __str__(self):
        return f"Dynamic Analysis for {self.scan_result.file.original_filename}"


class AnalysisReport(models.Model):
    """
    Model for comprehensive analysis reports.
    
    Combines all analysis results into exportable reports.
    """
    report_id = models.UUIDField(default=uuid.uuid4, editable=False, unique=True, primary_key=True)
    scan_result = models.ForeignKey(ScanResult, on_delete=models.CASCADE, related_name='reports')
    
    # Goals and techniques
    goals_met = models.ManyToManyField(AnalysisGoal, blank=True, related_name='reports')
    techniques_applied = models.ManyToManyField(AnalysisTechnique, blank=True, related_name='reports')
    
    # Classification
    malware_types = models.ManyToManyField(MalwareType, blank=True, related_name='reports')
    confidence_score = models.FloatField(default=0.0, help_text="Classification confidence (0-1)")
    
    # IOCs
    indicators_of_compromise = models.JSONField(default=dict, help_text="Extracted IOCs")
    
    # Report content
    executive_summary = models.TextField(blank=True)
    detailed_findings = models.TextField(blank=True)
    recommendations = models.TextField(blank=True)
    
    # Export
    report_format = models.CharField(
        max_length=20,
        choices=[('json', 'JSON'), ('html', 'HTML'), ('pdf', 'PDF')],
        default='json'
    )
    report_file = models.FileField(upload_to='analysis_reports/', blank=True, null=True)
    
    created_at = models.DateTimeField(auto_now_add=True)
    created_by = models.ForeignKey(User, on_delete=models.SET_NULL, null=True, related_name='analysis_reports')
    
    class Meta:
        ordering = ['-created_at']
    
    def __str__(self):
        return f"Report for {self.scan_result.file.original_filename} ({self.created_at.strftime('%Y-%m-%d')})"
