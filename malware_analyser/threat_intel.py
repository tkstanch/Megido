"""
Threat intelligence integration module.

Provides clients for VirusTotal, MalwareBazaar, AlienVault OTX, ThreatFox,
and a MITRE ATT&CK behaviour mapper.  All API keys are read from Django
settings; no credentials are hard-coded.

Response caching uses a simple in-process dict with a 24-hour TTL.
"""
import hashlib
import logging
import time
from typing import Any, Dict, List, Optional

logger = logging.getLogger(__name__)

try:
    import requests as _requests
    _HAS_REQUESTS = True
except ImportError:  # pragma: no cover
    _HAS_REQUESTS = False
    logger.warning("requests library not available; threat intel clients disabled")

# ---------------------------------------------------------------------------
# Helpers
# ---------------------------------------------------------------------------

_CACHE_TTL = 86_400  # 24 hours in seconds


class _TTLCache:
    """Minimal TTL-based in-memory cache (not thread-safe at scale)."""

    def __init__(self, ttl: int = _CACHE_TTL) -> None:
        self._ttl = ttl
        self._store: Dict[str, tuple] = {}  # key -> (value, expiry_ts)

    def get(self, key: str) -> Optional[Any]:
        entry = self._store.get(key)
        if entry is None:
            return None
        value, expiry = entry
        if time.time() > expiry:
            del self._store[key]
            return None
        return value

    def set(self, key: str, value: Any) -> None:
        self._store[key] = (value, time.time() + self._ttl)

    def clear(self) -> None:
        self._store.clear()


def _get_setting(name: str, default: Optional[str] = None) -> Optional[str]:
    """Safely read a value from Django settings, returning *default* on error."""
    try:
        from django.conf import settings as _settings  # type: ignore
        return getattr(_settings, name, default)
    except Exception:
        return default


def _make_request(
    method: str,
    url: str,
    timeout: int = 30,
    **kwargs: Any,
) -> Optional[Dict]:
    """Perform an HTTP request and return parsed JSON, or None on error."""
    if not _HAS_REQUESTS:
        return None
    try:
        resp = _requests.request(method, url, timeout=timeout, **kwargs)
        resp.raise_for_status()
        return resp.json()
    except Exception as exc:
        logger.warning("HTTP request to %s failed: %s", url, exc)
        return None


# ---------------------------------------------------------------------------
# VirusTotal
# ---------------------------------------------------------------------------

class VirusTotalClient:
    """
    Wrapper for the VirusTotal v3 public API.

    API key is read from ``settings.VIRUSTOTAL_API_KEY``.
    """

    _BASE = "https://www.virustotal.com/api/v3"

    def __init__(self) -> None:
        self._cache = _TTLCache()

    def _api_key(self) -> Optional[str]:
        return _get_setting("VIRUSTOTAL_API_KEY")

    def lookup_hash(self, file_hash: str) -> Dict:
        """
        Look up a file hash (MD5/SHA1/SHA256) on VirusTotal.

        Returns:
            Dict with keys ``detection_ratio``, ``total_engines``,
            ``vendor_detections``, ``malware_name``, and ``raw``.
        """
        cached = self._cache.get(f"vt:{file_hash}")
        if cached is not None:
            return cached

        api_key = self._api_key()
        if not api_key:
            logger.warning("VIRUSTOTAL_API_KEY not configured")
            return {}

        url = f"{self._BASE}/files/{file_hash}"
        data = _make_request("GET", url, headers={"x-apikey": api_key})
        if data is None:
            return {}

        result = self._parse_response(data)
        self._cache.set(f"vt:{file_hash}", result)
        return result

    @staticmethod
    def _parse_response(data: Dict) -> Dict:
        """Extract useful fields from a VT v3 file report."""
        try:
            attrs = data["data"]["attributes"]
            stats = attrs.get("last_analysis_stats", {})
            malicious = stats.get("malicious", 0)
            total = sum(stats.values()) if stats else 0
            vendors: Dict[str, str] = {}
            for engine, det in attrs.get("last_analysis_results", {}).items():
                if det.get("category") == "malicious":
                    vendors[engine] = det.get("result", "")
            name = attrs.get("meaningful_name") or attrs.get("name", "")
            return {
                "detection_ratio": f"{malicious}/{total}",
                "total_engines": total,
                "malicious_count": malicious,
                "vendor_detections": vendors,
                "malware_name": name,
                "raw": data,
            }
        except (KeyError, TypeError) as exc:
            logger.debug("VirusTotal parse error: %s", exc)
            return {}


# ---------------------------------------------------------------------------
# MalwareBazaar
# ---------------------------------------------------------------------------

class MalwareBazaarClient:
    """
    Wrapper for MalwareBazaar's public API (no API key required).
    """

    _BASE = "https://mb-api.abuse.ch/api/v1/"

    def __init__(self) -> None:
        self._cache = _TTLCache()

    def lookup_hash(self, file_hash: str) -> Dict:
        """
        Query MalwareBazaar for a file hash.

        Returns:
            Dict with keys ``tags``, ``malware_family``, ``first_seen``,
            ``file_type``, ``signature``, and ``raw``.
        """
        cached = self._cache.get(f"mb:{file_hash}")
        if cached is not None:
            return cached

        data = _make_request(
            "POST",
            self._BASE,
            data={"query": "get_info", "hash": file_hash},
        )
        if data is None or data.get("query_status") != "ok":
            return {}

        result = self._parse_response(data)
        self._cache.set(f"mb:{file_hash}", result)
        return result

    @staticmethod
    def _parse_response(data: Dict) -> Dict:
        try:
            sample = data["data"][0]
            return {
                "tags": sample.get("tags") or [],
                "malware_family": sample.get("signature", ""),
                "first_seen": sample.get("first_seen", ""),
                "file_type": sample.get("file_type", ""),
                "signature": sample.get("signature", ""),
                "raw": sample,
            }
        except (KeyError, IndexError, TypeError) as exc:
            logger.debug("MalwareBazaar parse error: %s", exc)
            return {}


# ---------------------------------------------------------------------------
# AlienVault OTX
# ---------------------------------------------------------------------------

class AlienVaultOTXClient:
    """
    Wrapper for the AlienVault OTX API.

    API key is read from ``settings.OTX_API_KEY``.
    """

    _BASE = "https://otx.alienvault.com/api/v1"

    def __init__(self) -> None:
        self._cache = _TTLCache()

    def _api_key(self) -> Optional[str]:
        return _get_setting("OTX_API_KEY")

    def _headers(self) -> Dict[str, str]:
        key = self._api_key()
        return {"X-OTX-API-KEY": key} if key else {}

    def lookup_hash(self, file_hash: str) -> Dict:
        """Query OTX pulses for a file hash."""
        return self._lookup("file", file_hash, "general")

    def lookup_ip(self, ip: str) -> Dict:
        """Query OTX pulses for an IP address."""
        return self._lookup("IPv4", ip, "general")

    def lookup_domain(self, domain: str) -> Dict:
        """Query OTX pulses for a domain."""
        return self._lookup("domain", domain, "general")

    def _lookup(self, indicator_type: str, indicator: str, section: str) -> Dict:
        cache_key = f"otx:{indicator_type}:{indicator}"
        cached = self._cache.get(cache_key)
        if cached is not None:
            return cached

        if not self._api_key():
            logger.warning("OTX_API_KEY not configured")
            return {}

        url = f"{self._BASE}/indicators/{indicator_type}/{indicator}/{section}"
        data = _make_request("GET", url, headers=self._headers())
        if data is None:
            return {}

        result = self._parse_response(data)
        self._cache.set(cache_key, result)
        return result

    @staticmethod
    def _parse_response(data: Dict) -> Dict:
        try:
            pulses = data.get("pulse_info", {}).get("pulses", [])
            return {
                "pulse_count": len(pulses),
                "pulse_names": [p.get("name", "") for p in pulses],
                "tags": list({tag for p in pulses for tag in p.get("tags", [])}),
                "malware_families": list(
                    {m.get("display_name", "") for p in pulses for m in p.get("malware_families", [])}
                ),
                "raw": data,
            }
        except (KeyError, TypeError) as exc:
            logger.debug("OTX parse error: %s", exc)
            return {}


# ---------------------------------------------------------------------------
# ThreatFox
# ---------------------------------------------------------------------------

class ThreatFoxClient:
    """
    Wrapper for ThreatFox's public API (no API key required).
    """

    _BASE = "https://threatfox-api.abuse.ch/api/v1/"

    def __init__(self) -> None:
        self._cache = _TTLCache()

    def lookup_ioc(self, ioc: str) -> Dict:
        """
        Search ThreatFox for any IOC value (hash, IP:port, domain, URL).

        Returns:
            Dict with keys ``threat_type``, ``malware``, ``confidence``,
            ``tags``, and ``raw``.
        """
        cached = self._cache.get(f"tf:{ioc}")
        if cached is not None:
            return cached

        data = _make_request("POST", self._BASE, json={"query": "search_ioc", "search_term": ioc})
        if data is None or data.get("query_status") not in ("ok", "no_result"):
            return {}

        result = self._parse_response(data)
        self._cache.set(f"tf:{ioc}", result)
        return result

    @staticmethod
    def _parse_response(data: Dict) -> Dict:
        try:
            if data.get("query_status") == "no_result":
                return {"found": False}
            items = data.get("data") or []
            if not items:
                return {"found": False}
            item = items[0]
            return {
                "found": True,
                "threat_type": item.get("threat_type", ""),
                "malware": item.get("malware", ""),
                "confidence": item.get("confidence_level", 0),
                "tags": item.get("tags") or [],
                "raw": item,
            }
        except (KeyError, IndexError, TypeError) as exc:
            logger.debug("ThreatFox parse error: %s", exc)
            return {}


# ---------------------------------------------------------------------------
# MITRE ATT&CK Mapper
# ---------------------------------------------------------------------------

# Maps behaviour keywords (lower-case) to ATT&CK technique IDs.
_ATTACK_MAPPINGS: Dict[str, str] = {
    # Execution
    "powershell": "T1059.001",
    "cmd.exe": "T1059.003",
    "wscript": "T1059.005",
    "cscript": "T1059.005",
    "mshta": "T1218.005",
    "regsvr32": "T1218.010",
    "rundll32": "T1218.011",
    "msiexec": "T1218.007",
    "wmi": "T1047",
    "scheduled task": "T1053.005",
    "schtasks": "T1053.005",
    # Persistence
    "registry run": "T1547.001",
    "startup folder": "T1547.001",
    "winlogon": "T1547.004",
    "lsass": "T1003.001",
    "service install": "T1543.003",
    # Defence evasion
    "process hollowing": "T1055.012",
    "dll injection": "T1055.001",
    "reflective dll": "T1620",
    "uac bypass": "T1548.002",
    "obfuscation": "T1027",
    "packed": "T1027.002",
    "anti-debug": "T1622",
    "virtualization check": "T1497.001",
    "sleep": "T1497.003",
    # Credential access
    "credential dumping": "T1003",
    "mimikatz": "T1003.001",
    "keylogger": "T1056.001",
    "clipboard": "T1115",
    "browser credentials": "T1555.003",
    # Discovery
    "process list": "T1057",
    "network scan": "T1046",
    "system information": "T1082",
    "whoami": "T1033",
    "ipconfig": "T1016",
    "netstat": "T1049",
    # Lateral movement
    "pass-the-hash": "T1550.002",
    "psexec": "T1021.002",
    "rdp": "T1021.001",
    # Collection
    "screen capture": "T1113",
    "audio capture": "T1123",
    "file collection": "T1005",
    # Exfiltration
    "data exfiltration": "T1041",
    "dns exfil": "T1048.003",
    # Command and control
    "http c2": "T1071.001",
    "https c2": "T1071.001",
    "dns c2": "T1071.004",
    "beaconing": "T1071",
    "cobalt strike": "T1219",
    "remote access tool": "T1219",
}


class MITREAttackMapper:
    """Map behaviour keywords to MITRE ATT&CK technique IDs."""

    def __init__(self) -> None:
        self._mappings = _ATTACK_MAPPINGS

    def map_behaviors(self, behaviors: List[str]) -> Dict[str, str]:
        """
        Return a dict mapping each matched keyword to its ATT&CK technique ID.

        Args:
            behaviors: List of behaviour strings (case-insensitive).
        """
        matched: Dict[str, str] = {}
        for behavior in behaviors:
            lower = behavior.lower()
            for keyword, technique in self._mappings.items():
                if keyword in lower:
                    matched[keyword] = technique
        return matched

    def get_techniques(self, behaviors: List[str]) -> List[str]:
        """Return unique ATT&CK technique IDs for the given behaviours."""
        return list(set(self.map_behaviors(behaviors).values()))


# ---------------------------------------------------------------------------
# Top-level aggregator
# ---------------------------------------------------------------------------

class ThreatIntelligence:
    """
    Aggregate threat intelligence from all available sources.

    Instantiate once and reuse; each underlying client maintains its own
    24-hour response cache.
    """

    def __init__(self) -> None:
        self.virustotal = VirusTotalClient()
        self.malware_bazaar = MalwareBazaarClient()
        self.otx = AlienVaultOTXClient()
        self.threatfox = ThreatFoxClient()
        self.mitre = MITREAttackMapper()

    def enrich_hash(self, file_hash: str) -> Dict:
        """
        Query all hash-based intel sources and merge results.

        Args:
            file_hash: MD5, SHA1, or SHA256 hex digest.

        Returns:
            Merged dict with keys ``virustotal``, ``malware_bazaar``,
            ``otx``, and ``threatfox``.
        """
        return {
            "virustotal": self.virustotal.lookup_hash(file_hash),
            "malware_bazaar": self.malware_bazaar.lookup_hash(file_hash),
            "otx": self.otx.lookup_hash(file_hash),
            "threatfox": self.threatfox.lookup_ioc(file_hash),
        }

    def enrich_ip(self, ip: str) -> Dict:
        """Query all IP-based intel sources."""
        return {
            "otx": self.otx.lookup_ip(ip),
            "threatfox": self.threatfox.lookup_ioc(ip),
        }

    def enrich_domain(self, domain: str) -> Dict:
        """Query all domain-based intel sources."""
        return {
            "otx": self.otx.lookup_domain(domain),
            "threatfox": self.threatfox.lookup_ioc(domain),
        }

    def map_techniques(self, behaviors: List[str]) -> Dict[str, str]:
        """Map behaviour keywords to ATT&CK technique IDs."""
        return self.mitre.map_behaviors(behaviors)
