"""
Advanced Visualization Module for Malware Analyzer

Generates interactive charts and graphs for malware analysis results.
"""

import json
from typing import Dict, List


def generate_entropy_chart_data(entropy_map: List[Dict]) -> str:
    """
    Generate Chart.js data for entropy visualization.
    
    Args:
        entropy_map: List of entropy data points
    
    Returns:
        JSON string for Chart.js
    """
    if not entropy_map:
        return json.dumps({'labels': [], 'data': []})
    
    labels = [f"0x{item['offset']:x}" for item in entropy_map]
    data = [item['entropy'] for item in entropy_map]
    
    chart_data = {
        'labels': labels,
        'datasets': [{
            'label': 'Entropy',
            'data': data,
            'borderColor': 'rgb(75, 192, 192)',
            'backgroundColor': 'rgba(75, 192, 192, 0.2)',
            'fill': True,
            'tension': 0.4
        }]
    }
    
    return json.dumps(chart_data)


def generate_pe_sections_chart(sections: List[Dict]) -> str:
    """
    Generate Chart.js data for PE sections visualization.
    
    Args:
        sections: List of PE section data
    
    Returns:
        JSON string for Chart.js
    """
    if not sections:
        return json.dumps({'labels': [], 'data': []})
    
    labels = [section['name'] for section in sections]
    entropy_data = [section.get('entropy', 0) for section in sections]
    size_data = [section.get('virtual_size', 0) / 1024 for section in sections]  # KB
    
    chart_data = {
        'labels': labels,
        'datasets': [
            {
                'label': 'Entropy',
                'data': entropy_data,
                'backgroundColor': 'rgba(255, 99, 132, 0.5)',
                'borderColor': 'rgb(255, 99, 132)',
                'yAxisID': 'y',
            },
            {
                'label': 'Size (KB)',
                'data': size_data,
                'backgroundColor': 'rgba(54, 162, 235, 0.5)',
                'borderColor': 'rgb(54, 162, 235)',
                'yAxisID': 'y1',
            }
        ]
    }
    
    return json.dumps(chart_data)


def generate_threat_score_gauge(threat_level: str, confidence: float = 0.0) -> Dict:
    """
    Generate gauge chart data for threat assessment.
    
    Args:
        threat_level: Threat level string (none, low, medium, high, critical)
        confidence: Confidence score (0-1)
    
    Returns:
        Dictionary with gauge configuration
    """
    threat_scores = {
        'none': 0,
        'low': 25,
        'medium': 50,
        'high': 75,
        'critical': 100
    }
    
    score = threat_scores.get(threat_level, 0)
    
    return {
        'score': score,
        'confidence': confidence * 100,
        'color': _get_threat_color(threat_level),
        'label': threat_level.upper()
    }


def generate_analysis_timeline(analysis_data: Dict) -> List[Dict]:
    """
    Generate timeline data for analysis steps.
    
    Args:
        analysis_data: Dictionary with analysis results and timestamps
    
    Returns:
        List of timeline events
    """
    timeline = []
    
    # File upload
    timeline.append({
        'event': 'File Uploaded',
        'icon': 'ðŸ“¤',
        'status': 'complete',
        'details': analysis_data.get('filename', 'Unknown')
    })
    
    # Basic scan
    if analysis_data.get('scan_completed'):
        timeline.append({
            'event': 'Initial Scan',
            'icon': 'ðŸ”',
            'status': 'complete',
            'details': f"Threat: {analysis_data.get('threat_level', 'Unknown')}"
        })
    
    # Static analysis
    if analysis_data.get('static_analysis'):
        timeline.append({
            'event': 'Static Analysis',
            'icon': 'ðŸ“„',
            'status': 'complete',
            'details': 'PE parsing, YARA scanning, ML prediction'
        })
    
    # Dynamic analysis
    if analysis_data.get('dynamic_analysis'):
        timeline.append({
            'event': 'Dynamic Analysis',
            'icon': 'â–¶ï¸',
            'status': 'complete',
            'details': 'Sandbox execution and monitoring'
        })
    
    # Report generation
    if analysis_data.get('report_generated'):
        timeline.append({
            'event': 'Report Generated',
            'icon': 'ðŸ“Š',
            'status': 'complete',
            'details': 'Analysis report available'
        })
    
    return timeline


def generate_detection_summary(scan_result) -> Dict:
    """
    Generate summary of all detection methods.
    
    Args:
        scan_result: ScanResult model instance
    
    Returns:
        Dictionary with detection summary
    """
    summary = {
        'total_detections': 0,
        'by_method': {
            'signature': 0,
            'heuristic': 0,
            'yara': 0,
            'ml': 0,
            'behavior': 0
        },
        'confidence': 0.0
    }
    
    # Check various detection methods
    if scan_result.matched_signatures.exists():
        summary['by_method']['signature'] = scan_result.matched_signatures.count()
        summary['total_detections'] += 1
    
    if hasattr(scan_result, 'static_analysis'):
        static = scan_result.static_analysis
        if static.yara_matches:
            summary['by_method']['yara'] = len(static.yara_matches)
            summary['total_detections'] += 1
    
    # ML detection
    if scan_result.scan_details.get('ml_prediction', {}).get('is_malicious'):
        summary['by_method']['ml'] = 1
        summary['total_detections'] += 1
        summary['confidence'] = scan_result.scan_details['ml_prediction'].get('confidence', 0)
    
    # Heuristic
    if scan_result.scan_details.get('heuristic_scan_completed'):
        if scan_result.scan_details.get('suspicious_indicators'):
            summary['by_method']['heuristic'] = len(scan_result.scan_details['suspicious_indicators'])
            if summary['by_method']['heuristic'] > 0:
                summary['total_detections'] += 1
    
    return summary


def generate_comparison_data(scan_results: List) -> Dict:
    """
    Generate data for comparing multiple samples.
    
    Args:
        scan_results: List of ScanResult instances
    
    Returns:
        Dictionary with comparison data
    """
    comparison = {
        'samples': [],
        'features': ['File Size', 'Entropy', 'YARA Matches', 'Threat Level']
    }
    
    for scan in scan_results[:10]:  # Limit to 10 samples
        sample_data = {
            'name': scan.file.original_filename[:30],
            'file_size': scan.file.file_size,
            'entropy': 0,
            'yara_matches': 0,
            'threat_score': _threat_to_score(scan.threat_level)
        }
        
        if hasattr(scan, 'static_analysis'):
            sample_data['entropy'] = scan.static_analysis.entropy or 0
            sample_data['yara_matches'] = len(scan.static_analysis.yara_matches) if scan.static_analysis.yara_matches else 0
        
        comparison['samples'].append(sample_data)
    
    return comparison


def _get_threat_color(threat_level: str) -> str:
    """Get color for threat level."""
    colors = {
        'none': '#10b981',  # green
        'low': '#3b82f6',   # blue
        'medium': '#f59e0b', # yellow
        'high': '#f97316',   # orange
        'critical': '#ef4444' # red
    }
    return colors.get(threat_level, '#6b7280')


def _threat_to_score(threat_level: str) -> int:
    """Convert threat level to numeric score."""
    scores = {
        'none': 0,
        'low': 25,
        'medium': 50,
        'high': 75,
        'critical': 100
    }
    return scores.get(threat_level, 0)
