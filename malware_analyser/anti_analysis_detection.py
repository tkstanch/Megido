"""
Advanced Anti-Analysis Detection Module

Detects sophisticated evasion techniques used by malware:
- Anti-debugging techniques
- Anti-VM techniques
- Process injection methods
- Encoding/encryption schemes
- Hook detection
- Persistence mechanisms
- Network behavior patterns

Based on techniques from "Practical Malware Analysis" and related textbooks.
"""

import re
from typing import Dict, List, Any, Optional


class AntiDebugDetector:
    """Detects anti-debugging techniques in malware"""
    
    # API calls commonly used for anti-debugging
    ANTI_DEBUG_APIS = {
        'IsDebuggerPresent': {
            'description': 'Basic debugger presence check',
            'risk': 'Medium',
            'mitigation': 'Patch return value to always return FALSE'
        },
        'CheckRemoteDebuggerPresent': {
            'description': 'Checks for remote debugger',
            'risk': 'Medium',
            'mitigation': 'Patch return value or hook the function'
        },
        'NtQueryInformationProcess': {
            'description': 'Queries process debug port (ProcessDebugPort)',
            'risk': 'High',
            'mitigation': 'Hook function to return non-debug values'
        },
        'OutputDebugString': {
            'description': 'Debug string trick - checks for errors',
            'risk': 'Low',
            'mitigation': 'Modify last error value'
        },
        'FindWindow': {
            'description': 'Searches for debugger windows',
            'risk': 'Low',
            'mitigation': 'Rename debugger windows'
        },
        'GetTickCount': {
            'description': 'Timing check to detect single-stepping',
            'risk': 'Medium',
            'mitigation': 'Use hardware breakpoints, hide debugger'
        },
        'QueryPerformanceCounter': {
            'description': 'High-resolution timing check',
            'risk': 'Medium',
            'mitigation': 'Manipulate timing functions'
        },
        'NtSetInformationThread': {
            'description': 'Hide thread from debugger (ThreadHideFromDebugger)',
            'risk': 'High',
            'mitigation': 'Hook or skip this call'
        },
        'CloseHandle': {
            'description': 'Invalid handle trick - causes exception in debugger',
            'risk': 'Low',
            'mitigation': 'Handle exception properly'
        }
    }
    
    # Debugger window names to search for
    DEBUGGER_WINDOWS = [
        'OllyDbg', 'x64dbg', 'IDA', 'WinDbg', 'Immunity Debugger',
        'OllyICE', 'SoftICE', 'Syser'
    ]
    
    @staticmethod
    def detect(file_content: bytes, imports: List[str]) -> Dict[str, Any]:
        """
        Detect anti-debugging techniques
        
        Args:
            file_content: Raw file bytes
            imports: List of imported functions
            
        Returns:
            Dictionary with detection results
        """
        detections = []
        
        # Check for anti-debug APIs
        for api, info in AntiDebugDetector.ANTI_DEBUG_APIS.items():
            if api in imports:
                detections.append({
                    'technique': f'API: {api}',
                    'description': info['description'],
                    'risk': info['risk'],
                    'mitigation': info['mitigation']
                })
        
        # Check for PEB structure access (BeingDebugged flag)
        # Pattern: mov eax, fs:[30h] (PEB access) then test byte ptr [eax+2], 1
        peb_patterns = [
            b'\x64\xa1\x30\x00\x00\x00',  # mov eax, fs:[30h]
            b'\x64\x8b\x15\x30\x00\x00\x00',  # mov edx, fs:[30h]
        ]
        
        for pattern in peb_patterns:
            if pattern in file_content:
                detections.append({
                    'technique': 'PEB.BeingDebugged check',
                    'description': 'Accesses PEB structure to check BeingDebugged flag',
                    'risk': 'High',
                    'mitigation': 'Patch PEB.BeingDebugged or modify flag'
                })
                break
        
        # Check for timing checks (RDTSC instruction)
        if b'\x0f\x31' in file_content:  # RDTSC opcode
            detections.append({
                'technique': 'RDTSC timing check',
                'description': 'Uses RDTSC instruction to detect debugger slowdown',
                'risk': 'Medium',
                'mitigation': 'Hide debugger to reduce timing delays'
            })
        
        # Check for INT scanning (searching for breakpoints)
        if b'\xcc' in file_content and file_content.count(b'\xcc') > 10:
            detections.append({
                'technique': 'INT 3 scanning',
                'description': 'Scans memory for INT 3 (0xCC) breakpoints',
                'risk': 'Medium',
                'mitigation': 'Use hardware breakpoints instead of software'
            })
        
        # Check for debugger window names
        for debugger in AntiDebugDetector.DEBUGGER_WINDOWS:
            if debugger.encode() in file_content:
                detections.append({
                    'technique': f'Debugger window check: {debugger}',
                    'description': f'Searches for window with name "{debugger}"',
                    'risk': 'Low',
                    'mitigation': 'Rename debugger window'
                })
        
        # Check for TLS callbacks (executed before main)
        # This is a common anti-debug trick
        if b'TLS' in file_content or b'.tls' in file_content:
            detections.append({
                'technique': 'TLS callbacks',
                'description': 'Uses TLS callbacks that execute before debugger breaks',
                'risk': 'High',
                'mitigation': 'Set breakpoint at TLS callbacks or use ScyllaHide'
            })
        
        # Check for exception-based anti-debug
        seh_apis = ['SetUnhandledExceptionFilter', 'AddVectoredExceptionHandler']
        for api in seh_apis:
            if api in imports:
                detections.append({
                    'technique': f'Exception-based: {api}',
                    'description': 'Uses exceptions to detect/evade debuggers',
                    'risk': 'High',
                    'mitigation': 'Pass exceptions to program, not debugger'
                })
        
        # Check for parent process validation
        if 'CreateToolhelp32Snapshot' in imports and 'Process32First' in imports:
            detections.append({
                'technique': 'Parent process check',
                'description': 'Validates parent process (should be explorer.exe)',
                'risk': 'Medium',
                'mitigation': 'Launch from explorer.exe or patch check'
            })
        
        return {
            'detected': len(detections) > 0,
            'count': len(detections),
            'techniques': detections
        }


class AntiVMDetector:
    """Detects anti-VM techniques in malware"""
    
    # VMware-specific artifacts
    VMWARE_ARTIFACTS = {
        'registry': [
            'VMware Tools', 'VMware SVGA', 'VMware SCSI',
            'VMware Pointing', 'HKEY_LOCAL_MACHINE\\SOFTWARE\\VMware'
        ],
        'files': [
            'vmware.exe', 'vmtoolsd.exe', 'vmacthlp.exe', 'vmdebug.dll',
            'vmGuestLib.dll', 'vmhgfs.dll', 'C:\\Program Files\\VMware'
        ],
        'processes': ['vmtoolsd.exe', 'vmacthlp.exe', 'vmwaretray.exe', 'vmwareuser.exe'],
        'services': ['VMTools', 'VMMEMCTL', 'vmware', 'vm3dservice'],
        'mac_prefixes': ['00:0C:29', '00:50:56', '00:05:69']
    }
    
    # VirtualBox-specific artifacts
    VBOX_ARTIFACTS = {
        'registry': ['VBoxGuest', 'VBoxVideo', 'VBoxMouse', 'VBOX'],
        'files': ['VBoxService.exe', 'VBoxTray.exe', 'VBoxGuest.sys', 'VBoxMouse.sys'],
        'processes': ['VBoxService.exe', 'VBoxTray.exe'],
        'devices': ['VBoxGuest', 'VBoxVideo']
    }
    
    # Hardware checks
    HARDWARE_CHECKS = {
        'cpu_brands': ['QEMU', 'VMware', 'VirtualBox', 'Xen', 'Bochs'],
        'bios_vendors': ['VMware', 'VirtualBox', 'Xen', 'QEMU', 'Bochs']
    }
    
    @staticmethod
    def detect(file_content: bytes, imports: List[str]) -> Dict[str, Any]:
        """
        Detect anti-VM techniques
        
        Args:
            file_content: Raw file bytes
            imports: List of imported functions
            
        Returns:
            Dictionary with detection results
        """
        detections = []
        confidence = 'Low'
        indicator_count = 0
        
        # Check for VMware artifacts
        for category, artifacts in AntiVMDetector.VMWARE_ARTIFACTS.items():
            for artifact in artifacts:
                if artifact.encode() in file_content:
                    detections.append({
                        'type': 'VMware artifact',
                        'category': category,
                        'artifact': artifact,
                        'description': f'Checks for VMware {category}: {artifact}'
                    })
                    indicator_count += 1
        
        # Check for VirtualBox artifacts
        for category, artifacts in AntiVMDetector.VBOX_ARTIFACTS.items():
            for artifact in artifacts:
                if artifact.encode() in file_content:
                    detections.append({
                        'type': 'VirtualBox artifact',
                        'category': category,
                        'artifact': artifact,
                        'description': f'Checks for VirtualBox {category}: {artifact}'
                    })
                    indicator_count += 1
        
        # Check for hardware/BIOS checks
        for brand in AntiVMDetector.HARDWARE_CHECKS['cpu_brands']:
            if brand.encode() in file_content:
                detections.append({
                    'type': 'Hardware check',
                    'category': 'CPU',
                    'artifact': brand,
                    'description': f'Checks CPU brand for "{brand}"'
                })
                indicator_count += 1
        
        # Check for CPUID instruction (used for VM detection)
        if b'\x0f\xa2' in file_content:  # CPUID opcode
            detections.append({
                'type': 'VM detection',
                'category': 'Instruction',
                'artifact': 'CPUID',
                'description': 'Uses CPUID to detect hypervisor presence'
            })
            indicator_count += 1
        
        # Check for Red Pill technique (SIDT instruction)
        if b'\x0f\x01' in file_content:  # SIDT/SLDT opcodes
            detections.append({
                'type': 'VM detection',
                'category': 'Red Pill',
                'artifact': 'SIDT/SLDT',
                'description': 'Uses SIDT or SLDT instruction (Red Pill technique)'
            })
            indicator_count += 2  # High confidence indicator
        
        # Check for I/O port communication (IN instruction)
        if b'\xed' in file_content or b'\xec' in file_content:  # IN opcodes
            detections.append({
                'type': 'VM detection',
                'category': 'I/O Port',
                'artifact': 'IN instruction',
                'description': 'Uses IN instruction to query VMware backdoor port'
            })
            indicator_count += 2
        
        # Check for registry query functions (often used for VM checks)
        reg_apis = ['RegOpenKeyEx', 'RegQueryValueEx', 'RegEnumKey']
        if any(api in imports for api in reg_apis):
            # This alone isn't conclusive, but combined with artifacts...
            if indicator_count > 0:
                detections.append({
                    'type': 'Registry check',
                    'category': 'API',
                    'artifact': 'Registry APIs',
                    'description': 'Uses registry APIs (likely checking VM artifacts)'
                })
        
        # Check for MAC address checks
        for mac_prefix in AntiVMDetector.VMWARE_ARTIFACTS['mac_prefixes']:
            if mac_prefix.encode() in file_content:
                detections.append({
                    'type': 'MAC address check',
                    'category': 'Network',
                    'artifact': mac_prefix,
                    'description': f'Checks for VMware MAC address prefix {mac_prefix}'
                })
                indicator_count += 1
        
        # Determine confidence level
        if indicator_count >= 5:
            confidence = 'High'
        elif indicator_count >= 2:
            confidence = 'Medium'
        else:
            confidence = 'Low'
        
        return {
            'detected': len(detections) > 0,
            'confidence': confidence,
            'indicator_count': indicator_count,
            'techniques': detections
        }


class ProcessInjectionDetector:
    """Detects process injection techniques"""
    
    INJECTION_APIS = {
        'CreateRemoteThread': {
            'method': 'Classic CreateRemoteThread',
            'description': 'Creates thread in remote process',
            'requires': ['VirtualAllocEx', 'WriteProcessMemory']
        },
        'VirtualAllocEx': {
            'method': 'Memory allocation in remote process',
            'description': 'Allocates memory in another process',
            'companion_apis': ['WriteProcessMemory', 'CreateRemoteThread']
        },
        'WriteProcessMemory': {
            'method': 'Write to remote process',
            'description': 'Writes data to another process memory',
            'companion_apis': ['VirtualAllocEx', 'CreateRemoteThread']
        },
        'SetThreadContext': {
            'method': 'Process Hollowing/RunPE',
            'description': 'Modifies thread context (used in process hollowing)',
            'companion_apis': ['NtUnmapViewOfSection', 'VirtualAllocEx']
        },
        'QueueUserAPC': {
            'method': 'APC Injection',
            'description': 'Queues APC to inject code into process',
            'companion_apis': ['VirtualAllocEx', 'WriteProcessMemory']
        },
        'SetWindowsHookEx': {
            'method': 'Hook Injection',
            'description': 'Installs hook to inject DLL',
            'companion_apis': ['LoadLibrary', 'GetProcAddress']
        },
        'NtCreateThreadEx': {
            'method': 'Native API Injection',
            'description': 'Creates thread using native API',
            'companion_apis': ['VirtualAllocEx', 'WriteProcessMemory']
        },
        'RtlCreateUserThread': {
            'method': 'Native API Injection',
            'description': 'Creates thread using undocumented API',
            'companion_apis': ['VirtualAllocEx', 'WriteProcessMemory']
        },
        'NtUnmapViewOfSection': {
            'method': 'Process Hollowing',
            'description': 'Unmaps section (process hollowing technique)',
            'companion_apis': ['VirtualAllocEx', 'SetThreadContext']
        }
    }
    
    @staticmethod
    def detect(imports: List[str]) -> Dict[str, Any]:
        """
        Detect process injection techniques
        
        Args:
            imports: List of imported functions
            
        Returns:
            Dictionary with detection results
        """
        detections = []
        detected_apis = []
        
        # Check for injection APIs
        for api, info in ProcessInjectionDetector.INJECTION_APIS.items():
            if api in imports:
                detected_apis.append(api)
                
                # Check if companion APIs are also present
                companion_count = 0
                companion_list = info.get('companion_apis', [])
                found_companions = []
                
                for companion in companion_list:
                    if companion in imports:
                        companion_count += 1
                        found_companions.append(companion)
                
                risk = 'Critical' if companion_count >= 2 else 'High' if companion_count == 1 else 'Medium'
                
                detections.append({
                    'api': api,
                    'method': info['method'],
                    'description': info['description'],
                    'risk': risk,
                    'companion_apis_found': found_companions
                })
        
        # Detect common injection patterns
        patterns = []
        
        # Classic injection pattern
        if all(api in imports for api in ['VirtualAllocEx', 'WriteProcessMemory', 'CreateRemoteThread']):
            patterns.append({
                'pattern': 'Classic DLL Injection',
                'apis': ['VirtualAllocEx', 'WriteProcessMemory', 'CreateRemoteThread'],
                'description': 'Complete classic injection pattern detected',
                'risk': 'Critical'
            })
        
        # Process hollowing pattern
        if all(api in imports for api in ['NtUnmapViewOfSection', 'VirtualAllocEx', 'SetThreadContext']):
            patterns.append({
                'pattern': 'Process Hollowing',
                'apis': ['NtUnmapViewOfSection', 'VirtualAllocEx', 'SetThreadContext'],
                'description': 'Process replacement/hollowing pattern detected',
                'risk': 'Critical'
            })
        
        # APC injection pattern
        if all(api in imports for api in ['QueueUserAPC', 'VirtualAllocEx', 'WriteProcessMemory']):
            patterns.append({
                'pattern': 'APC Injection',
                'apis': ['QueueUserAPC', 'VirtualAllocEx', 'WriteProcessMemory'],
                'description': 'APC-based injection pattern detected',
                'risk': 'Critical'
            })
        
        return {
            'detected': len(detections) > 0,
            'count': len(detections),
            'techniques': detections,
            'patterns': patterns
        }


class EncodingDetector:
    """Detects encoding and encryption schemes"""
    
    # Cryptographic constants
    CRYPTO_CONSTANTS = {
        'AES': {
            'constants': [0x63, 0x7C, 0x77, 0x7B],  # AES S-box start
            'description': 'AES encryption (S-box detected)',
            'key_sizes': [128, 192, 256]
        },
        'DES': {
            'constants': [0x01010400, 0x00000000, 0x00010000],
            'description': 'DES encryption (Initial Permutation)',
            'key_sizes': [56]
        },
        'RC4': {
            'apis': ['CryptCreateHash', 'CryptDeriveKey'],
            'description': 'RC4 stream cipher',
            'key_sizes': [40, 56, 128]
        },
        'MD5': {
            'constants': [0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476],
            'description': 'MD5 hash algorithm',
            'type': 'hash'
        },
        'SHA1': {
            'constants': [0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476, 0xC3D2E1F0],
            'description': 'SHA-1 hash algorithm',
            'type': 'hash'
        },
        'SHA256': {
            'constants': [0x6A09E667, 0xBB67AE85, 0x3C6EF372, 0xA54FF53A],
            'description': 'SHA-256 hash algorithm',
            'type': 'hash'
        }
    }
    
    @staticmethod
    def detect(file_content: bytes, imports: List[str]) -> Dict[str, Any]:
        """
        Detect encoding and encryption schemes
        
        Args:
            file_content: Raw file bytes
            imports: List of imported functions
            
        Returns:
            Dictionary with detection results
        """
        detections = []
        
        # Check for Base64 encoding
        base64_pattern = rb'[A-Za-z0-9+/]{20,}={0,2}'
        if re.search(base64_pattern, file_content):
            detections.append({
                'algorithm': 'Base64',
                'type': 'Encoding',
                'description': 'Base64 encoded strings detected',
                'confidence': 'Medium'
            })
        
        # Check for XOR operations (common in malware)
        if b'\x31' in file_content or b'\x35' in file_content:  # XOR opcodes
            xor_count = file_content.count(b'\x31') + file_content.count(b'\x35')
            if xor_count > 5:
                detections.append({
                    'algorithm': 'XOR',
                    'type': 'Encryption',
                    'description': f'Multiple XOR operations detected ({xor_count})',
                    'confidence': 'Medium'
                })
        
        # Check for cryptographic constants
        for algo, info in EncodingDetector.CRYPTO_CONSTANTS.items():
            if 'constants' in info:
                # Convert constants to bytes and search
                for const in info['constants']:
                    const_bytes = const.to_bytes(4, 'little')
                    if const_bytes in file_content:
                        detections.append({
                            'algorithm': algo,
                            'type': info.get('type', 'Encryption'),
                            'description': info['description'],
                            'confidence': 'High',
                            'constant': hex(const)
                        })
                        break
        
        # Check for crypto APIs
        crypto_apis = {
            'CryptAcquireContext': 'CryptoAPI initialization',
            'CryptEncrypt': 'CryptoAPI encryption',
            'CryptDecrypt': 'CryptoAPI decryption',
            'CryptCreateHash': 'CryptoAPI hashing',
            'BCryptEncrypt': 'BCrypt encryption (Windows)',
            'BCryptDecrypt': 'BCrypt decryption (Windows)'
        }
        
        for api, desc in crypto_apis.items():
            if api in imports:
                detections.append({
                    'algorithm': 'CryptoAPI',
                    'type': 'API',
                    'description': desc,
                    'api': api,
                    'confidence': 'High'
                })
        
        # Check for OpenSSL
        openssl_funcs = ['EVP_EncryptInit', 'EVP_DecryptInit', 'SSL_connect']
        if any(func.encode() in file_content for func in openssl_funcs):
            detections.append({
                'algorithm': 'OpenSSL',
                'type': 'Library',
                'description': 'OpenSSL library detected',
                'confidence': 'High'
            })
        
        # Detect high-entropy blocks (encrypted/compressed data)
        entropy_blocks = EncodingDetector._find_high_entropy_blocks(file_content)
        
        return {
            'detected': len(detections) > 0,
            'count': len(detections),
            'algorithms': detections,
            'high_entropy_blocks': len(entropy_blocks),
            'entropy_blocks': entropy_blocks[:5]  # Limit to first 5
        }
    
    @staticmethod
    def _find_high_entropy_blocks(data: bytes, block_size: int = 1024, threshold: float = 7.5) -> List[Dict]:
        """Find high-entropy blocks in data"""
        import math
        from collections import Counter
        
        blocks = []
        for i in range(0, len(data), block_size):
            block = data[i:i+block_size]
            if len(block) < block_size // 2:
                continue
            
            # Calculate Shannon entropy
            counter = Counter(block)
            entropy = 0
            for count in counter.values():
                prob = count / len(block)
                entropy -= prob * math.log2(prob)
            
            if entropy >= threshold:
                blocks.append({
                    'offset': hex(i),
                    'size': len(block),
                    'entropy': round(entropy, 2)
                })
        
        return blocks


class HookDetector:
    """Detects hooking techniques"""
    
    HOOK_APIS = {
        'SetWindowsHookEx': {
            'type': 'Message Hook',
            'description': 'Installs Windows message hook (global or thread-specific)',
            'hook_types': ['WH_KEYBOARD', 'WH_MOUSE', 'WH_CBT', 'WH_SHELL']
        },
        'GetProcAddress': {
            'type': 'IAT Hook Setup',
            'description': 'Gets function address (commonly used for IAT hooking)',
            'companion': ['VirtualProtect', 'WriteProcessMemory']
        },
        'VirtualProtect': {
            'type': 'Memory Protection',
            'description': 'Changes memory protection (used for inline hooking)',
            'companion': ['WriteProcessMemory']
        }
    }
    
    @staticmethod
    def detect(imports: List[str]) -> Dict[str, Any]:
        """
        Detect hooking techniques
        
        Args:
            imports: List of imported functions
            
        Returns:
            Dictionary with detection results
        """
        detections = []
        
        # Check for hook APIs
        for api, info in HookDetector.HOOK_APIS.items():
            if api in imports:
                detections.append({
                    'api': api,
                    'type': info['type'],
                    'description': info['description'],
                    'risk': 'High'
                })
        
        # Detect IAT hooking pattern
        if all(api in imports for api in ['GetProcAddress', 'VirtualProtect']):
            detections.append({
                'pattern': 'IAT Hooking',
                'description': 'Import Address Table hooking pattern detected',
                'apis': ['GetProcAddress', 'VirtualProtect'],
                'risk': 'Critical'
            })
        
        # Detect inline hooking pattern
        if all(api in imports for api in ['VirtualProtect', 'WriteProcessMemory']):
            detections.append({
                'pattern': 'Inline Hooking',
                'description': 'Inline function hooking pattern detected',
                'apis': ['VirtualProtect', 'WriteProcessMemory'],
                'risk': 'Critical'
            })
        
        return {
            'detected': len(detections) > 0,
            'count': len(detections),
            'techniques': detections
        }


class PersistenceDetector:
    """Detects persistence mechanisms"""
    
    PERSISTENCE_MECHANISMS = {
        'RegSetValueEx': {
            'method': 'Registry Modification',
            'keys': ['Run', 'RunOnce', 'RunServices', 'Winlogon', 'AppInit_DLLs'],
            'description': 'Modifies registry for autostart',
            'removal_difficulty': 'Easy'
        },
        'CreateService': {
            'method': 'Windows Service',
            'description': 'Creates Windows service for persistence',
            'removal_difficulty': 'Medium',
            'requires_admin': True
        },
        'ChangeServiceConfig': {
            'method': 'Service Modification',
            'description': 'Modifies existing service configuration',
            'removal_difficulty': 'Medium',
            'requires_admin': True
        },
        'CreateFile': {
            'method': 'Startup Folder',
            'paths': ['Startup', 'Start Menu'],
            'description': 'Creates file in startup folder',
            'removal_difficulty': 'Easy'
        },
        'CryptInstallOIDFunctionAddress': {
            'method': 'DLL Injection',
            'description': 'Registers DLL for automatic loading',
            'removal_difficulty': 'Hard',
            'stealth': 'High'
        }
    }
    
    @staticmethod
    def detect(file_content: bytes, imports: List[str]) -> Dict[str, Any]:
        """
        Detect persistence mechanisms
        
        Args:
            file_content: Raw file bytes
            imports: List of imported functions
            
        Returns:
            Dictionary with detection results
        """
        detections = []
        
        # Check for persistence APIs
        for api, info in PersistenceDetector.PERSISTENCE_MECHANISMS.items():
            if api in imports:
                detections.append({
                    'api': api,
                    'method': info['method'],
                    'description': info['description'],
                    'removal_difficulty': info['removal_difficulty'],
                    'requires_admin': info.get('requires_admin', False)
                })
        
        # Check for registry persistence keys
        reg_keys = [
            b'Software\\Microsoft\\Windows\\CurrentVersion\\Run',
            b'Software\\Microsoft\\Windows\\CurrentVersion\\RunOnce',
            b'Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon',
            b'AppInit_DLLs',
            b'Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders'
        ]
        
        for key in reg_keys:
            if key in file_content:
                detections.append({
                    'method': 'Registry Persistence',
                    'key': key.decode('utf-8', errors='ignore'),
                    'description': 'References autostart registry key',
                    'risk': 'High'
                })
        
        # Check for scheduled task APIs
        sched_apis = ['NetScheduleJobAdd', 'ITaskScheduler']
        for api in sched_apis:
            if api in imports or api.encode() in file_content:
                detections.append({
                    'method': 'Scheduled Task',
                    'api': api,
                    'description': 'Creates scheduled task for persistence',
                    'risk': 'High'
                })
        
        # Check for startup folder references
        if b'Startup' in file_content or b'Start Menu\\Programs\\Startup' in file_content:
            detections.append({
                'method': 'Startup Folder',
                'description': 'References Startup folder',
                'risk': 'Medium'
            })
        
        return {
            'detected': len(detections) > 0,
            'count': len(detections),
            'mechanisms': detections
        }


class NetworkBehaviorDetector:
    """Detects network behavior patterns"""
    
    C2_PATTERNS = {
        'socket': 'Berkeley sockets (raw socket communication)',
        'connect': 'Socket connection (potential C2)',
        'send': 'Data transmission',
        'recv': 'Data reception',
        'InternetOpen': 'WinINet initialization',
        'InternetConnect': 'HTTP/FTP connection',
        'HttpSendRequest': 'HTTP request (potential C2)',
        'HttpOpenRequest': 'HTTP request preparation',
        'URLDownloadToFile': 'File download',
        'URLDownloadToFileEx': 'File download (extended)',
        'InternetReadFile': 'Download data from URL',
        'WSAStartup': 'Winsock initialization',
        'gethostbyname': 'DNS resolution',
        'getaddrinfo': 'Address resolution'
    }
    
    @staticmethod
    def detect(file_content: bytes, imports: List[str]) -> Dict[str, Any]:
        """
        Detect network behavior patterns
        
        Args:
            file_content: Raw file bytes
            imports: List of imported functions
            
        Returns:
            Dictionary with detection results
        """
        detections = []
        
        # Check for network APIs
        for api, desc in NetworkBehaviorDetector.C2_PATTERNS.items():
            if api in imports:
                detections.append({
                    'api': api,
                    'description': desc,
                    'category': 'Network Communication'
                })
        
        # Extract potential URLs/IPs
        url_pattern = rb'https?://[a-zA-Z0-9\-\.]+(?:\.[a-zA-Z]{2,})+(?:[/\w\-\.]*)*'
        urls = re.findall(url_pattern, file_content)
        
        ip_pattern = rb'\b(?:[0-9]{1,3}\.){3}[0-9]{1,3}\b'
        ips = re.findall(ip_pattern, file_content)
        
        # Detect IRC commands (common in botnets)
        irc_commands = [b'NICK', b'USER', b'JOIN', b'PRIVMSG', b'PART']
        irc_detected = any(cmd in file_content for cmd in irc_commands)
        
        if irc_detected:
            detections.append({
                'category': 'IRC Protocol',
                'description': 'IRC commands detected (potential botnet)',
                'risk': 'High'
            })
        
        # Detect HTTP User-Agent strings
        if b'User-Agent:' in file_content or b'Mozilla/' in file_content:
            detections.append({
                'category': 'HTTP Communication',
                'description': 'HTTP User-Agent detected',
                'risk': 'Medium'
            })
        
        return {
            'detected': len(detections) > 0,
            'count': len(detections),
            'apis': detections,
            'urls_found': len(urls),
            'ips_found': len(ips),
            'irc_detected': irc_detected
        }


def perform_anti_analysis_detection(file_content: bytes, imports: List[str]) -> Dict[str, Any]:
    """
    Perform comprehensive anti-analysis detection
    
    Args:
        file_content: Raw file bytes
        imports: List of imported functions
        
    Returns:
        Dictionary with all detection results
    """
    results = {
        'anti_debug': AntiDebugDetector.detect(file_content, imports),
        'anti_vm': AntiVMDetector.detect(file_content, imports),
        'process_injection': ProcessInjectionDetector.detect(imports),
        'encoding': EncodingDetector.detect(file_content, imports),
        'hooks': HookDetector.detect(imports),
        'persistence': PersistenceDetector.detect(file_content, imports),
        'network_behavior': NetworkBehaviorDetector.detect(file_content, imports)
    }
    
    # Calculate overall evasion score
    evasion_score = 0
    if results['anti_debug']['detected']:
        evasion_score += results['anti_debug']['count'] * 10
    if results['anti_vm']['detected']:
        confidence_map = {'High': 30, 'Medium': 20, 'Low': 10}
        evasion_score += confidence_map.get(results['anti_vm']['confidence'], 10)
    if results['process_injection']['detected']:
        evasion_score += results['process_injection']['count'] * 15
    
    results['evasion_score'] = min(evasion_score, 100)
    results['evasion_level'] = 'High' if evasion_score >= 50 else 'Medium' if evasion_score >= 20 else 'Low'
    
    return results
