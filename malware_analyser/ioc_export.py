"""
IOC export module.

Exports indicators of compromise in multiple formats:
  - STIX 2.1 JSON bundle
  - OpenIOC XML
  - YARA rules
  - Sigma rules
  - MISP event JSON
"""
import hashlib
import json
import logging
import re
import uuid
from dataclasses import dataclass, field
from datetime import datetime, timezone
from typing import Any, Dict, List, Optional

logger = logging.getLogger(__name__)

try:
    import stix2 as _stix2  # type: ignore
    _HAS_STIX2 = True
except ImportError:
    _stix2 = None  # type: ignore
    _HAS_STIX2 = False
    logger.info("stix2 library not available; falling back to manual STIX JSON generation")


# ---------------------------------------------------------------------------
# IOCBundle dataclass
# ---------------------------------------------------------------------------

@dataclass
class IOCBundle:
    """Container for all IOCs extracted from a malware sample."""

    sample_name: str = ""
    sample_sha256: str = ""
    malware_family: str = ""
    analysis_date: str = field(
        default_factory=lambda: datetime.now(timezone.utc).isoformat()
    )
    ips: List[str] = field(default_factory=list)
    domains: List[str] = field(default_factory=list)
    urls: List[str] = field(default_factory=list)
    md5_hashes: List[str] = field(default_factory=list)
    sha1_hashes: List[str] = field(default_factory=list)
    sha256_hashes: List[str] = field(default_factory=list)
    file_paths: List[str] = field(default_factory=list)
    registry_keys: List[str] = field(default_factory=list)
    mutexes: List[str] = field(default_factory=list)
    email_addresses: List[str] = field(default_factory=list)
    tags: List[str] = field(default_factory=list)
    byte_patterns: List[bytes] = field(default_factory=list)
    behavioral_iocs: List[str] = field(default_factory=list)

    def all_hashes(self) -> List[str]:
        """Return all hash IOCs combined."""
        return self.md5_hashes + self.sha1_hashes + self.sha256_hashes


# ---------------------------------------------------------------------------
# STIX 2.1 Exporter
# ---------------------------------------------------------------------------

class STIXExporter:
    """Generate STIX 2.1 JSON bundles from an :class:`IOCBundle`."""

    def export(self, bundle: IOCBundle) -> str:
        """
        Build a STIX 2.1 bundle and return it as a JSON string.

        Uses the ``stix2`` library when available; otherwise falls back to
        manual JSON construction.
        """
        if _HAS_STIX2:
            return self._export_with_stix2(bundle)
        return self._export_manual(bundle)

    # ------------------------------------------------------------------
    def _export_with_stix2(self, bundle: IOCBundle) -> str:
        objects: List[Any] = []

        # Malware SDO
        malware = _stix2.Malware(
            name=bundle.malware_family or bundle.sample_name or "unknown",
            is_family=False,
            labels=bundle.tags or ["malware"],
        )
        objects.append(malware)

        # Indicator SDOs
        for ip in bundle.ips:
            try:
                indicator = _stix2.Indicator(
                    name=f"Malicious IP: {ip}",
                    indicator_types=["malicious-activity"],
                    pattern=f"[network-traffic:dst_ref.type = 'ipv4-addr' AND network-traffic:dst_ref.value = '{ip}']",
                    pattern_type="stix",
                    valid_from=bundle.analysis_date,
                )
                objects.append(indicator)
                objects.append(_stix2.Relationship(
                    relationship_type="indicates",
                    source_ref=indicator.id,
                    target_ref=malware.id,
                ))
            except Exception as exc:
                logger.debug("STIX IP indicator error: %s", exc)

        for domain in bundle.domains:
            try:
                indicator = _stix2.Indicator(
                    name=f"Malicious domain: {domain}",
                    indicator_types=["malicious-activity"],
                    pattern=f"[domain-name:value = '{domain}']",
                    pattern_type="stix",
                    valid_from=bundle.analysis_date,
                )
                objects.append(indicator)
                objects.append(_stix2.Relationship(
                    relationship_type="indicates",
                    source_ref=indicator.id,
                    target_ref=malware.id,
                ))
            except Exception as exc:
                logger.debug("STIX domain indicator error: %s", exc)

        for url in bundle.urls:
            try:
                safe_url = url.replace("'", "\\'")
                indicator = _stix2.Indicator(
                    name=f"Malicious URL: {url[:60]}",
                    indicator_types=["malicious-activity"],
                    pattern=f"[url:value = '{safe_url}']",
                    pattern_type="stix",
                    valid_from=bundle.analysis_date,
                )
                objects.append(indicator)
                objects.append(_stix2.Relationship(
                    relationship_type="indicates",
                    source_ref=indicator.id,
                    target_ref=malware.id,
                ))
            except Exception as exc:
                logger.debug("STIX URL indicator error: %s", exc)

        stix_bundle = _stix2.Bundle(objects=objects, allow_custom=True)
        return stix_bundle.serialize(pretty=True)

    # ------------------------------------------------------------------
    def _export_manual(self, bundle: IOCBundle) -> str:
        """Build a minimal STIX 2.1 bundle without the stix2 library."""
        now = bundle.analysis_date
        malware_id = f"malware--{uuid.uuid4()}"
        objects: List[Dict] = [
            {
                "type": "malware",
                "spec_version": "2.1",
                "id": malware_id,
                "created": now,
                "modified": now,
                "name": bundle.malware_family or bundle.sample_name or "unknown",
                "is_family": False,
                "labels": bundle.tags or ["malware"],
            }
        ]

        def _add_indicator(name: str, pattern: str) -> None:
            ind_id = f"indicator--{uuid.uuid4()}"
            rel_id = f"relationship--{uuid.uuid4()}"
            objects.append({
                "type": "indicator",
                "spec_version": "2.1",
                "id": ind_id,
                "created": now,
                "modified": now,
                "name": name,
                "indicator_types": ["malicious-activity"],
                "pattern": pattern,
                "pattern_type": "stix",
                "valid_from": now,
            })
            objects.append({
                "type": "relationship",
                "spec_version": "2.1",
                "id": rel_id,
                "created": now,
                "modified": now,
                "relationship_type": "indicates",
                "source_ref": ind_id,
                "target_ref": malware_id,
            })

        for ip in bundle.ips:
            _add_indicator(
                f"Malicious IP: {ip}",
                f"[network-traffic:dst_ref.type = 'ipv4-addr' AND network-traffic:dst_ref.value = '{ip}']",
            )
        for domain in bundle.domains:
            _add_indicator(f"Malicious domain: {domain}", f"[domain-name:value = '{domain}']")
        for url in bundle.urls:
            safe = url.replace("'", "\\'")
            _add_indicator(f"Malicious URL: {url[:60]}", f"[url:value = '{safe}']")

        stix_bundle = {
            "type": "bundle",
            "id": f"bundle--{uuid.uuid4()}",
            "objects": objects,
        }
        return json.dumps(stix_bundle, indent=2)


# ---------------------------------------------------------------------------
# OpenIOC Exporter
# ---------------------------------------------------------------------------

class OpenIOCExporter:
    """Generate OpenIOC XML from an :class:`IOCBundle`."""

    def export(self, bundle: IOCBundle) -> str:
        """Return an OpenIOC 1.1 XML document as a string."""
        ioc_id = str(uuid.uuid4())
        now = bundle.analysis_date

        indicators_xml = self._build_indicators(bundle)

        return (
            '<?xml version="1.0" encoding="utf-8"?>\n'
            f'<ioc xmlns="http://schemas.mandiant.com/2010/ioc" id="{ioc_id}" '
            f'last-modified="{now}" created="{now}">\n'
            f'  <short_description>{bundle.malware_family or bundle.sample_name}</short_description>\n'
            "  <definition>\n"
            '    <Indicator operator="OR" id="' + str(uuid.uuid4()) + '">\n'
            + indicators_xml
            + "    </Indicator>\n"
            "  </definition>\n"
            "</ioc>"
        )

    @staticmethod
    def _item(context_document: str, context_search: str, content_type: str, value: str) -> str:
        item_id = str(uuid.uuid4())
        safe_val = value.replace("&", "&amp;").replace("<", "&lt;").replace(">", "&gt;")
        return (
            f'      <IndicatorItem id="{item_id}" condition="contains">\n'
            f'        <Context document="{context_document}" search="{context_search}" type="mir"/>\n'
            f'        <Content type="{content_type}">{safe_val}</Content>\n'
            "      </IndicatorItem>\n"
        )

    def _build_indicators(self, bundle: IOCBundle) -> str:
        xml = ""
        for ip in bundle.ips:
            xml += self._item("Network", "Network/DNS", "string", ip)
        for domain in bundle.domains:
            xml += self._item("Network", "Network/DNS", "string", domain)
        for url in bundle.urls:
            xml += self._item("Network", "Network/URI", "string", url)
        for h in bundle.md5_hashes:
            xml += self._item("FileItem", "FileItem/Md5sum", "md5", h)
        for h in bundle.sha256_hashes:
            xml += self._item("FileItem", "FileItem/Sha256sum", "sha256", h)
        for path in bundle.file_paths:
            xml += self._item("FileItem", "FileItem/FullPath", "string", path)
        for reg in bundle.registry_keys:
            xml += self._item("RegistryItem", "RegistryItem/KeyPath", "string", reg)
        for mutex in bundle.mutexes:
            xml += self._item("ProcessItem", "ProcessItem/HandleList/Handle/Name", "string", mutex)
        return xml


# ---------------------------------------------------------------------------
# YARA Rule Generator
# ---------------------------------------------------------------------------

class YARARuleGenerator:
    """Auto-generate YARA rules from byte patterns found in a sample."""

    def generate(self, bundle: IOCBundle) -> str:
        """
        Build a YARA rule string from the bundle's byte_patterns and IOCs.
        """
        rule_name = re.sub(r"[^a-zA-Z0-9_]", "_", bundle.malware_family or "malware")
        strings_section = ""
        condition_parts: List[str] = []

        for i, pattern in enumerate(bundle.byte_patterns[:20]):  # limit to 20
            hex_str = " ".join(f"{b:02x}" for b in pattern)
            strings_section += f'        $byte_{i} = {{ {hex_str} }}\n'
            condition_parts.append(f"$byte_{i}")

        for i, domain in enumerate(bundle.domains[:10]):
            safe = domain.replace('"', '\\"')
            strings_section += f'        $domain_{i} = "{safe}" ascii wide nocase\n'
            condition_parts.append(f"$domain_{i}")

        for i, url in enumerate(bundle.urls[:10]):
            safe = url.replace('"', '\\"')
            strings_section += f'        $url_{i} = "{safe}" ascii wide\n'
            condition_parts.append(f"$url_{i}")

        for i, mutex in enumerate(bundle.mutexes[:5]):
            safe = mutex.replace('"', '\\"')
            strings_section += f'        $mutex_{i} = "{safe}" ascii wide\n'
            condition_parts.append(f"$mutex_{i}")

        if not strings_section:
            return f"// No patterns available to generate YARA rule for {rule_name}"

        condition = " or ".join(condition_parts) if condition_parts else "false"
        meta = (
            f'        description = "Auto-generated rule for {bundle.malware_family or bundle.sample_name}"\n'
            f'        hash = "{bundle.sample_sha256}"\n'
            f'        date = "{bundle.analysis_date[:10]}"\n'
            '        author = "Megido Auto-YARA"\n'
        )

        return (
            f"rule {rule_name} {{\n"
            f"    meta:\n{meta}"
            f"    strings:\n{strings_section}"
            f"    condition:\n        {condition}\n"
            "}"
        )


# ---------------------------------------------------------------------------
# Sigma Rule Generator
# ---------------------------------------------------------------------------

class SigmaRuleGenerator:
    """Auto-generate Sigma rules from behavioural IOCs."""

    def generate(self, bundle: IOCBundle) -> str:
        """Return a Sigma YAML rule as a string."""
        title = f"Malware Activity - {bundle.malware_family or bundle.sample_name or 'Unknown'}"
        detection_keywords: List[str] = []

        detection_keywords.extend(bundle.mutexes[:5])
        detection_keywords.extend(bundle.registry_keys[:5])
        detection_keywords.extend(bundle.behavioral_iocs[:10])

        if not detection_keywords:
            return f"# No behavioural IOCs available for Sigma rule: {title}"

        keywords_yaml = "\n".join(f"            - '{kw}'" for kw in detection_keywords)

        return (
            f"title: {title}\n"
            "status: experimental\n"
            f"description: Auto-generated Sigma rule for {bundle.malware_family}\n"
            "author: Megido Auto-Sigma\n"
            f"date: {bundle.analysis_date[:10]}\n"
            "logsource:\n"
            "    category: process_creation\n"
            "    product: windows\n"
            "detection:\n"
            "    keywords:\n"
            f"{keywords_yaml}\n"
            "    condition: keywords\n"
            "falsepositives:\n"
            "    - Unknown\n"
            "level: high\n"
        )


# ---------------------------------------------------------------------------
# MISP Exporter
# ---------------------------------------------------------------------------

class MISPExporter:
    """Generate a MISP-compatible event JSON from an :class:`IOCBundle`."""

    def export(self, bundle: IOCBundle) -> str:
        """Return a MISP event as a JSON string."""
        attributes: List[Dict] = []

        def _attr(category: str, attr_type: str, value: str, comment: str = "") -> Dict:
            return {
                "category": category,
                "type": attr_type,
                "value": value,
                "comment": comment,
                "to_ids": True,
            }

        for ip in bundle.ips:
            attributes.append(_attr("Network activity", "ip-dst", ip))
        for domain in bundle.domains:
            attributes.append(_attr("Network activity", "domain", domain))
        for url in bundle.urls:
            attributes.append(_attr("Network activity", "url", url))
        for h in bundle.md5_hashes:
            attributes.append(_attr("Payload delivery", "md5", h))
        for h in bundle.sha1_hashes:
            attributes.append(_attr("Payload delivery", "sha1", h))
        for h in bundle.sha256_hashes:
            attributes.append(_attr("Payload delivery", "sha256", h))
        for path in bundle.file_paths:
            attributes.append(_attr("Artifacts dropped", "filename", path))
        for reg in bundle.registry_keys:
            attributes.append(_attr("Persistence mechanism", "regkey", reg))
        for mutex in bundle.mutexes:
            attributes.append(_attr("Artifacts dropped", "mutex", mutex))

        event = {
            "Event": {
                "info": f"Malware analysis: {bundle.malware_family or bundle.sample_name}",
                "date": bundle.analysis_date[:10],
                "threat_level_id": "2",
                "analysis": "2",
                "distribution": "0",
                "Attribute": attributes,
                "Tag": [{"name": tag} for tag in bundle.tags],
            }
        }
        return json.dumps(event, indent=2)


# ---------------------------------------------------------------------------
# Top-level IOCExporter
# ---------------------------------------------------------------------------

class IOCExporter:
    """
    Orchestrate IOC export in all supported formats.

    Usage::

        exporter = IOCExporter()
        results = exporter.export_all(bundle)
        # results["stix"], results["openioc"], results["yara"], ...
    """

    def __init__(self) -> None:
        self.stix = STIXExporter()
        self.openioc = OpenIOCExporter()
        self.yara = YARARuleGenerator()
        self.sigma = SigmaRuleGenerator()
        self.misp = MISPExporter()

    def export_all(self, bundle: IOCBundle) -> Dict[str, str]:
        """
        Export the :class:`IOCBundle` in all formats.

        Returns:
            Dict with keys ``stix``, ``openioc``, ``yara``, ``sigma``,
            ``misp``.  Each value is the export as a string.
        """
        results: Dict[str, str] = {}
        _exporters = [
            ("stix", self.stix, "export"),
            ("openioc", self.openioc, "export"),
            ("yara", self.yara, "generate"),
            ("sigma", self.sigma, "generate"),
            ("misp", self.misp, "export"),
        ]
        for fmt, exporter, method in _exporters:
            try:
                results[fmt] = getattr(exporter, method)(bundle)
            except Exception as exc:
                logger.exception("IOC export failed for format %s: %s", fmt, exc)
                results[fmt] = f"// Export error: {exc}"
        return results
