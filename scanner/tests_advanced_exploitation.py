"""
Tests for Advanced Exploitation Modules

This test suite validates the advanced exploitation confirmation features:
- Browser-based XSS exploitation with real JavaScript execution
- Advanced information disclosure exploitation with stack trace parsing
- Out-of-Band (OOB) exploitation framework for multiple vulnerability types
"""

import unittest
from unittest.mock import Mock, MagicMock, patch, call
import json
import base64
from typing import Dict, Any


class TestAdvancedBrowserExploit(unittest.TestCase):
    """Test cases for advanced browser-based XSS exploitation"""
    
    def setUp(self):
        """Set up test environment"""
        from scanner.plugins.advanced_browser_exploit import AdvancedBrowserExploit
        self.exploit = AdvancedBrowserExploit(use_playwright=False, headless=True)
    
    def tearDown(self):
        """Clean up resources"""
        if hasattr(self, 'exploit'):
            self.exploit.cleanup()
    
    def test_context_payload_generation(self):
        """Test context-aware payload generation"""
        from scanner.plugins.advanced_browser_exploit import AdvancedBrowserExploit
        
        # Test HTML context payloads
        html_payloads = AdvancedBrowserExploit.generate_context_aware_payloads('html')
        self.assertIsInstance(html_payloads, list)
        self.assertTrue(len(html_payloads) > 0)
        self.assertTrue(any('script' in p.lower() for p in html_payloads))
        
        # Test attribute context payloads
        attr_payloads = AdvancedBrowserExploit.generate_context_aware_payloads('attribute')
        self.assertIsInstance(attr_payloads, list)
        self.assertTrue(len(attr_payloads) > 0)
        self.assertTrue(any('onload' in p.lower() or 'onerror' in p.lower() for p in attr_payloads))
        
        # Test JavaScript context payloads
        js_payloads = AdvancedBrowserExploit.generate_context_aware_payloads('javascript')
        self.assertIsInstance(js_payloads, list)
        self.assertTrue(len(js_payloads) > 0)
        
        # Test SVG context payloads
        svg_payloads = AdvancedBrowserExploit.generate_context_aware_payloads('svg')
        self.assertIsInstance(svg_payloads, list)
        self.assertTrue(any('svg' in p.lower() for p in svg_payloads))
    
    def test_injection_context_detection(self):
        """Test injection context detection in HTML responses"""
        from scanner.plugins.advanced_browser_exploit import AdvancedBrowserExploit
        
        # Test HTML context
        html_response = '<html><body>Hello XSS_TEST_MARKER world</body></html>'
        context = AdvancedBrowserExploit.detect_injection_context(html_response, 'XSS_TEST_MARKER')
        self.assertEqual(context, 'html')
        
        # Test JavaScript context
        js_response = '<script>var x = "XSS_TEST_MARKER";</script>'
        context = AdvancedBrowserExploit.detect_injection_context(js_response, 'XSS_TEST_MARKER')
        self.assertEqual(context, 'javascript')
        
        # Test attribute context
        attr_response = '<img src="test" alt="XSS_TEST_MARKER">'
        context = AdvancedBrowserExploit.detect_injection_context(attr_response, 'XSS_TEST_MARKER')
        self.assertEqual(context, 'attribute')
        
        # Test SVG context
        svg_response = '<svg><text>XSS_TEST_MARKER</text></svg>'
        context = AdvancedBrowserExploit.detect_injection_context(svg_response, 'XSS_TEST_MARKER')
        self.assertEqual(context, 'svg')
    
    def test_exploit_url_building(self):
        """Test building exploit URLs with payloads"""
        url = 'https://example.com/search'
        parameter = 'q'
        payload = '<script>alert(1)</script>'
        
        result_url = self.exploit._build_exploit_url(url, parameter, payload, 'GET', {})
        
        self.assertIn('example.com', result_url)
        self.assertIn('q=', result_url)
        # Check if payload is encoded or raw
        self.assertTrue('%3Cscript%3E' in result_url or '<script>' in result_url)
    
    @patch('scanner.plugins.advanced_browser_exploit.HAS_PLAYWRIGHT', False)
    @patch('scanner.plugins.advanced_browser_exploit.HAS_SELENIUM', False)
    def test_no_browser_library_fallback(self):
        """Test graceful handling when no browser library is available"""
        result = self.exploit.attempt_xss_exploitation(
            url='https://example.com/test',
            parameter='q',
            timeout=5
        )
        
        self.assertFalse(result['success'])
        self.assertIn('error', result)
        self.assertIn('browser', result['error'].lower())


class TestAdvancedInfoDisclosureExploit(unittest.TestCase):
    """Test cases for advanced information disclosure exploitation"""
    
    def setUp(self):
        """Set up test environment"""
        from scanner.plugins.advanced_info_disclosure_exploit import AdvancedInfoDisclosureExploit
        self.exploit = AdvancedInfoDisclosureExploit(verify_ssl=False, timeout=5)
    
    def test_stack_trace_parsing(self):
        """Test stack trace parsing from responses"""
        from scanner.plugins.advanced_info_disclosure_exploit import AdvancedInfoDisclosureExploit
        
        # Test Python stack trace
        python_trace = '''
        Traceback (most recent call last):
          File "/app/views.py", line 42, in index
            process_data()
          File "/app/utils.py", line 10, in process_data
            raise ValueError("Invalid input")
        ValueError: Invalid input
        '''
        result = AdvancedInfoDisclosureExploit.parse_stack_trace(python_trace)
        
        self.assertTrue(result['found'])
        self.assertEqual(result['language'], 'Python')
        self.assertTrue(len(result['files']) > 0)
        self.assertTrue(len(result['line_numbers']) > 0)
        self.assertIn('/app/views.py', result['files'])
        
        # Test Java stack trace
        java_trace = '''
        Exception in thread "main" java.lang.NullPointerException
            at com.example.MyClass.myMethod(MyClass.java:123)
            at com.example.Main.main(Main.java:45)
        '''
        result = AdvancedInfoDisclosureExploit.parse_stack_trace(java_trace)
        
        self.assertTrue(result['found'])
        self.assertEqual(result['language'], 'Java')
        self.assertTrue(len(result['functions']) > 0)
        
        # Test PHP stack trace
        php_trace = 'Fatal error: Call to undefined function in /var/www/index.php on line 15'
        result = AdvancedInfoDisclosureExploit.parse_stack_trace(php_trace)
        
        self.assertTrue(result['found'])
        self.assertEqual(result['language'], 'PHP')
    
    def test_sensitive_pattern_detection(self):
        """Test detection of sensitive patterns in responses"""
        # Test API key detection
        response_with_api_key = {
            'headers': {},
            'body': 'API_KEY=abc123def456ghi789jkl012mno345pqr'
        }
        
        findings = self.exploit._analyze_response(response_with_api_key, 'https://example.com')
        
        api_key_findings = [f for f in findings if f['category'] == 'api_keys']
        self.assertTrue(len(api_key_findings) > 0)
        
        # Test AWS credentials detection
        response_with_aws = {
            'headers': {},
            'body': 'AWS_ACCESS_KEY_ID=AKIAIOSFODNN7EXAMPLE'
        }
        
        findings = self.exploit._analyze_response(response_with_aws, 'https://example.com')
        aws_findings = [f for f in findings if f['category'] == 'aws_credentials']
        self.assertTrue(len(aws_findings) > 0)
        
        # Test stack trace detection
        response_with_trace = {
            'headers': {},
            'body': 'Traceback (most recent call last): File "/app/main.py", line 10'
        }
        
        findings = self.exploit._analyze_response(response_with_trace, 'https://example.com')
        trace_findings = [f for f in findings if f['category'] == 'stack_trace']
        self.assertTrue(len(trace_findings) > 0)
    
    def test_severity_calculation(self):
        """Test severity calculation based on findings"""
        # Critical findings
        critical_findings = [
            {'category': 'private_keys', 'severity': 'critical'},
            {'category': 'api_keys', 'severity': 'critical'}
        ]
        severity = self.exploit._calculate_severity(critical_findings)
        self.assertEqual(severity, 'critical')
        
        # Mixed severity findings
        mixed_findings = [
            {'category': 'email_addresses', 'severity': 'low'},
            {'category': 'stack_trace', 'severity': 'high'}
        ]
        severity = self.exploit._calculate_severity(mixed_findings)
        self.assertEqual(severity, 'high')
        
        # No findings
        severity = self.exploit._calculate_severity([])
        self.assertEqual(severity, 'info')
    
    def test_error_trigger_payloads(self):
        """Test error trigger payload generation"""
        from scanner.plugins.advanced_info_disclosure_exploit import AdvancedInfoDisclosureExploit
        
        # Check SQL error payloads
        self.assertIn('sql_errors', AdvancedInfoDisclosureExploit.ERROR_TRIGGER_PAYLOADS)
        sql_payloads = AdvancedInfoDisclosureExploit.ERROR_TRIGGER_PAYLOADS['sql_errors']
        self.assertTrue(len(sql_payloads) > 0)
        self.assertTrue(any("'" in p for p in sql_payloads))
        
        # Check path traversal payloads
        self.assertIn('path_traversal', AdvancedInfoDisclosureExploit.ERROR_TRIGGER_PAYLOADS)
        path_payloads = AdvancedInfoDisclosureExploit.ERROR_TRIGGER_PAYLOADS['path_traversal']
        self.assertTrue(any('../' in p for p in path_payloads))


class TestOOBExploitationFramework(unittest.TestCase):
    """Test cases for Out-of-Band exploitation framework"""
    
    def setUp(self):
        """Set up test environment"""
        from scanner.plugins.oob_exploitation_framework import OOBExploitationFramework
        # Use localhost without ngrok for tests
        self.framework = OOBExploitationFramework(
            callback_url='http://localhost:8888',
            use_ngrok=False,
            timeout=5
        )
    
    def tearDown(self):
        """Clean up resources"""
        if hasattr(self, 'framework'):
            self.framework.cleanup()
    
    def test_oob_payload_generation_xss(self):
        """Test OOB payload generation for XSS"""
        payload, payload_id = self.framework.generate_oob_payload('xss')
        
        self.assertIsInstance(payload, str)
        self.assertIsInstance(payload_id, str)
        self.assertIn('localhost', payload)
        self.assertIn('xss', payload)
        self.assertIn(payload_id, payload)
        
        # Check that payload is tracked
        self.assertIn(payload_id, self.framework.pending_payloads)
        self.assertEqual(self.framework.pending_payloads[payload_id]['vuln_type'], 'xss')
    
    def test_oob_payload_generation_ssrf(self):
        """Test OOB payload generation for SSRF"""
        payload, payload_id = self.framework.generate_oob_payload('ssrf')
        
        self.assertIsInstance(payload, str)
        self.assertIn('localhost', payload)
        self.assertIn('ssrf', payload)
        self.assertIn(payload_id, payload)
    
    def test_oob_payload_generation_rce(self):
        """Test OOB payload generation for RCE"""
        payload, payload_id = self.framework.generate_oob_payload('rce', template_name='curl')
        
        self.assertIsInstance(payload, str)
        self.assertIn('curl', payload)
        self.assertIn('localhost', payload)
        self.assertIn('rce', payload)
    
    def test_oob_payload_generation_xxe(self):
        """Test OOB payload generation for XXE"""
        payload, payload_id = self.framework.generate_oob_payload('xxe')
        
        self.assertIsInstance(payload, str)
        # Check if payload contains XXE markers
        self.assertTrue('<!DOCTYPE' in payload or '<!ENTITY' in payload)
        self.assertIn('localhost', payload)
        self.assertIn('xxe', payload)
    
    def test_multiple_payload_generation(self):
        """Test generating multiple payloads for a vulnerability type"""
        payloads = self.framework.generate_multiple_payloads('xss')
        
        self.assertIsInstance(payloads, list)
        self.assertTrue(len(payloads) > 0)
        
        # All payloads should have unique IDs
        payload_ids = [pid for _, pid in payloads]
        self.assertEqual(len(payload_ids), len(set(payload_ids)))
    
    def test_payload_verification_no_callback(self):
        """Test payload verification when no callback is received"""
        payload, payload_id = self.framework.generate_oob_payload('xss')
        
        # Verify without waiting (should return False immediately)
        verified, interactions = self.framework.verify_oob_callback(payload_id, wait=False)
        
        self.assertFalse(verified)
        self.assertEqual(len(interactions), 0)
    
    def test_statistics_tracking(self):
        """Test exploitation statistics tracking"""
        # Generate some payloads
        self.framework.generate_oob_payload('xss')
        self.framework.generate_oob_payload('ssrf')
        self.framework.generate_oob_payload('rce')
        
        stats = self.framework.get_statistics()
        
        self.assertIn('total_payloads', stats)
        self.assertIn('verified_callbacks', stats)
        self.assertIn('pending_callbacks', stats)
        self.assertIn('success_rate', stats)
        self.assertIn('by_vuln_type', stats)
        
        self.assertEqual(stats['total_payloads'], 3)
        self.assertEqual(stats['verified_callbacks'], 0)
        self.assertEqual(stats['pending_callbacks'], 3)
    
    def test_pending_and_verified_payload_lists(self):
        """Test getting pending and verified payload lists"""
        # Generate payloads
        payload1, pid1 = self.framework.generate_oob_payload('xss')
        payload2, pid2 = self.framework.generate_oob_payload('ssrf')
        
        # All should be pending initially
        pending = self.framework.get_pending_payloads()
        self.assertEqual(len(pending), 2)
        
        verified = self.framework.get_verified_payloads()
        self.assertEqual(len(verified), 0)
        
        # Simulate verification
        self.framework.pending_payloads[pid1]['verified'] = True
        self.framework.confirmed_callbacks[pid1] = [{'test': 'data'}]
        
        pending = self.framework.get_pending_payloads()
        verified = self.framework.get_verified_payloads()
        
        self.assertEqual(len(pending), 1)
        self.assertEqual(len(verified), 1)
    
    def test_unsupported_vulnerability_type(self):
        """Test handling of unsupported vulnerability types"""
        with self.assertRaises(ValueError):
            self.framework.generate_oob_payload('unsupported_type')


class TestOOBPayloadBuilder(unittest.TestCase):
    """Test cases for OOB payload builder helper"""
    
    def test_build_xss_callback_basic(self):
        """Test building basic XSS callback payload"""
        from scanner.plugins.oob_exploitation_framework import OOBPayloadBuilder
        
        payload = OOBPayloadBuilder.build_xss_callback(
            'http://callback.example.com',
            'test123',
            exfiltrate_cookies=False,
            exfiltrate_dom=False
        )
        
        self.assertIn('<script>', payload)
        self.assertIn('fetch', payload)
        self.assertIn('callback.example.com', payload)
        self.assertIn('test123', payload)
    
    def test_build_xss_callback_with_exfiltration(self):
        """Test building XSS callback with data exfiltration"""
        from scanner.plugins.oob_exploitation_framework import OOBPayloadBuilder
        
        payload = OOBPayloadBuilder.build_xss_callback(
            'http://callback.example.com',
            'test123',
            exfiltrate_cookies=True,
            exfiltrate_dom=True
        )
        
        self.assertIn('cookies=', payload)
        self.assertIn('dom=', payload)
        self.assertIn('encodeURIComponent', payload)
    
    def test_build_ssrf_callback_protocols(self):
        """Test building SSRF callbacks with different protocols"""
        from scanner.plugins.oob_exploitation_framework import OOBPayloadBuilder
        
        # HTTP
        http_payload = OOBPayloadBuilder.build_ssrf_callback(
            'http://callback.example.com', 'test123', 'http'
        )
        self.assertIn('http://', http_payload)
        
        # File protocol
        file_payload = OOBPayloadBuilder.build_ssrf_callback(
            'http://callback.example.com', 'test123', 'file'
        )
        self.assertIn('file://', file_payload)
        
        # Gopher protocol
        gopher_payload = OOBPayloadBuilder.build_ssrf_callback(
            'http://callback.example.com', 'test123', 'gopher'
        )
        self.assertIn('gopher://', gopher_payload)
    
    def test_build_rce_callback_commands(self):
        """Test building RCE callbacks with different commands"""
        from scanner.plugins.oob_exploitation_framework import OOBPayloadBuilder
        
        # Curl
        curl_payload = OOBPayloadBuilder.build_rce_callback(
            'http://callback.example.com', 'test123', 'curl'
        )
        self.assertIn('curl', curl_payload)
        
        # Curl with exfiltration
        curl_exfil = OOBPayloadBuilder.build_rce_callback(
            'http://callback.example.com', 'test123', 'curl', 'whoami'
        )
        self.assertIn('curl', curl_exfil)
        self.assertIn('whoami', curl_exfil)
        self.assertIn('-d', curl_exfil)
        
        # Wget
        wget_payload = OOBPayloadBuilder.build_rce_callback(
            'http://callback.example.com', 'test123', 'wget'
        )
        self.assertIn('wget', wget_payload)
        
        # PowerShell
        ps_payload = OOBPayloadBuilder.build_rce_callback(
            'http://callback.example.com', 'test123', 'powershell'
        )
        self.assertIn('powershell', ps_payload)
        self.assertIn('Invoke-WebRequest', ps_payload)


# Run tests
if __name__ == '__main__':
    unittest.main()
