"""
Tests for exploit integration functionality
"""

from django.test import TestCase, Client
from django.contrib.auth.models import User
from rest_framework.authtoken.models import Token
from scanner.models import ScanTarget, Scan, Vulnerability
from scanner.exploit_integration import (
    exploit_all_vulnerabilities,
    exploit_selected_vulnerabilities,
    format_exploit_result
)
from unittest.mock import patch, MagicMock


class ExploitIntegrationTestCase(TestCase):
    """Test cases for exploit integration"""

    def setUp(self):
        """Set up test data"""
        # Create a user and token for authenticated requests
        self.user = User.objects.create_user(
            username='testuser',
            password='testpass123'
        )
        self.token = Token.objects.create(user=self.user)
        self.client = Client()

        # Create test scan target and scan
        self.target = ScanTarget.objects.create(
            url='https://example.com',
            name='Test Target'
        )
        self.scan = Scan.objects.create(
            target=self.target,
            status='completed'
        )

        # Create test vulnerabilities
        self.vuln1 = Vulnerability.objects.create(
            scan=self.scan,
            vulnerability_type='sqli',
            severity='high',
            url='https://example.com/page1',
            parameter='id',
            description='SQL Injection vulnerability',
            evidence='Error message in response'
        )
        self.vuln2 = Vulnerability.objects.create(
            scan=self.scan,
            vulnerability_type='xss',
            severity='medium',
            url='https://example.com/page2',
            parameter='search',
            description='XSS vulnerability',
            evidence='Script tag reflected'
        )

    def test_vulnerability_model_fields(self):
        """Test that vulnerability model has exploit-related fields"""
        vuln = Vulnerability.objects.get(id=self.vuln1.id)
        self.assertFalse(vuln.exploited)
        self.assertEqual(vuln.exploit_status, 'not_attempted')
        self.assertIsNone(vuln.exploit_result)
        self.assertIsNone(vuln.exploit_attempted_at)

    def test_format_exploit_result_success(self):
        """Test formatting successful exploit results"""
        result = {
            'success': True,
            'plugin_used': 'SQL Injection Plugin',
            'evidence': 'Database version: MySQL 5.7',
            'findings': ['Table: users', 'Table: posts'],
            'data': {'version': 'MySQL 5.7'}
        }
        formatted = format_exploit_result(result)
        self.assertIn('Plugin: SQL Injection Plugin', formatted)
        self.assertIn('Status: SUCCESS', formatted)
        self.assertIn('Evidence:', formatted)

    def test_format_exploit_result_failure(self):
        """Test formatting failed exploit results"""
        result = {
            'success': False,
            'plugin_used': 'XSS Plugin',
            'error': 'Connection timeout'
        }
        formatted = format_exploit_result(result)
        self.assertIn('Plugin: XSS Plugin', formatted)
        self.assertIn('Status: FAILED', formatted)
        self.assertIn('Error: Connection timeout', formatted)

    @patch('scanner.exploit_integration.exploit_vulnerability')
    def test_exploit_all_vulnerabilities(self, mock_exploit):
        """Test exploiting all vulnerabilities in a scan"""
        # Mock successful exploitation
        mock_exploit.return_value = {
            'success': True,
            'plugin_used': 'Test Plugin',
            'evidence': 'Test evidence',
            'findings': ['Finding 1'],
            'data': {}
        }

        results = exploit_all_vulnerabilities(self.scan.id)

        # Check results summary
        self.assertEqual(results['total'], 2)
        self.assertEqual(results['exploited'], 2)
        self.assertEqual(results['failed'], 0)
        self.assertEqual(results['no_plugin'], 0)
        self.assertEqual(len(results['results']), 2)

        # Verify vulnerabilities were updated
        vuln1 = Vulnerability.objects.get(id=self.vuln1.id)
        self.assertTrue(vuln1.exploited)
        self.assertEqual(vuln1.exploit_status, 'success')
        self.assertIsNotNone(vuln1.exploit_result)
        self.assertIsNotNone(vuln1.exploit_attempted_at)

    @patch('scanner.exploit_integration.exploit_vulnerability')
    def test_exploit_selected_vulnerabilities(self, mock_exploit):
        """Test exploiting only selected vulnerabilities"""
        # Mock successful exploitation
        mock_exploit.return_value = {
            'success': True,
            'plugin_used': 'Test Plugin',
            'evidence': 'Test evidence',
            'findings': [],
            'data': {}
        }

        # Only exploit the first vulnerability
        results = exploit_selected_vulnerabilities([self.vuln1.id])

        # Check results
        self.assertEqual(results['total'], 1)
        self.assertEqual(results['exploited'], 1)

        # Verify only selected vulnerability was updated
        vuln1 = Vulnerability.objects.get(id=self.vuln1.id)
        vuln2 = Vulnerability.objects.get(id=self.vuln2.id)
        self.assertTrue(vuln1.exploited)
        self.assertFalse(vuln2.exploited)

    @patch('scanner.exploit_integration.exploit_vulnerability')
    def test_exploit_with_no_plugin(self, mock_exploit):
        """Test exploitation when no plugin is available"""
        # Mock no plugin available
        mock_exploit.return_value = {
            'success': False,
            'plugin_used': None,
            'error': 'No exploit plugin available',
            'findings': [],
            'data': {}
        }

        results = exploit_all_vulnerabilities(self.scan.id)

        # Check that vulnerabilities are marked as no_plugin
        self.assertEqual(results['no_plugin'], 2)
        
        vuln1 = Vulnerability.objects.get(id=self.vuln1.id)
        self.assertEqual(vuln1.exploit_status, 'no_plugin')

    @patch('scanner.exploit_integration.exploit_vulnerability')
    def test_exploit_with_failure(self, mock_exploit):
        """Test exploitation when plugin exists but fails"""
        # Mock exploitation failure
        mock_exploit.return_value = {
            'success': False,
            'plugin_used': 'Test Plugin',
            'error': 'Connection refused',
            'findings': [],
            'data': {}
        }

        results = exploit_all_vulnerabilities(self.scan.id)

        # Check that vulnerabilities are marked as failed
        self.assertEqual(results['failed'], 2)
        
        vuln1 = Vulnerability.objects.get(id=self.vuln1.id)
        self.assertEqual(vuln1.exploit_status, 'failed')

    def test_exploit_api_endpoint_requires_auth(self):
        """Test that exploit endpoint requires authentication"""
        response = self.client.post(
            f'/scanner/api/scans/{self.scan.id}/exploit/',
            data={'action': 'all'},
            content_type='application/json'
        )
        # Should return 401 Unauthorized without authentication
        self.assertEqual(response.status_code, 401)

    @patch('scanner.tasks.async_exploit_all_vulnerabilities.delay')
    def test_exploit_api_endpoint_all(self, mock_task_delay):
        """Test exploit API endpoint with 'all' action"""
        # Mock Celery task returning a task ID
        mock_result = MagicMock()
        mock_result.id = 'test-task-id'
        mock_task_delay.return_value = mock_result

        # Make authenticated request
        response = self.client.post(
            f'/scanner/api/scans/{self.scan.id}/exploit/',
            data={'action': 'all'},
            content_type='application/json',
            HTTP_AUTHORIZATION=f'Token {self.token.key}'
        )

        # Now returns 202 (Accepted) with task_id instead of 200 with results
        self.assertEqual(response.status_code, 202)
        data = response.json()
        self.assertIn('task_id', data)
        self.assertEqual(data['task_id'], 'test-task-id')
        self.assertIn('status_url', data)

    @patch('scanner.tasks.async_exploit_selected_vulnerabilities.delay')
    def test_exploit_api_endpoint_selected(self, mock_task_delay):
        """Test exploit API endpoint with 'selected' action"""
        # Mock Celery task returning a task ID
        mock_result = MagicMock()
        mock_result.id = 'test-task-id-2'
        mock_task_delay.return_value = mock_result

        # Make authenticated request with selected IDs
        response = self.client.post(
            f'/scanner/api/scans/{self.scan.id}/exploit/',
            data={
                'action': 'selected',
                'vulnerability_ids': [self.vuln1.id]
            },
            content_type='application/json',
            HTTP_AUTHORIZATION=f'Token {self.token.key}'
        )

        # Now returns 202 (Accepted) with task_id instead of 200 with results
        self.assertEqual(response.status_code, 202)
        data = response.json()
        self.assertIn('task_id', data)
        self.assertEqual(data['task_id'], 'test-task-id-2')

    def test_exploit_api_endpoint_invalid_action(self):
        """Test exploit API endpoint with invalid action"""
        response = self.client.post(
            f'/scanner/api/scans/{self.scan.id}/exploit/',
            data={'action': 'invalid'},
            content_type='application/json',
            HTTP_AUTHORIZATION=f'Token {self.token.key}'
        )

        self.assertEqual(response.status_code, 400)
        self.assertIn('error', response.json())

    def test_exploit_api_endpoint_selected_without_ids(self):
        """Test exploit API endpoint with 'selected' but no IDs"""
        response = self.client.post(
            f'/scanner/api/scans/{self.scan.id}/exploit/',
            data={'action': 'selected'},
            content_type='application/json',
            HTTP_AUTHORIZATION=f'Token {self.token.key}'
        )

        self.assertEqual(response.status_code, 400)
        self.assertIn('error', response.json())

    def test_exploit_api_endpoint_invalid_scan_id(self):
        """Test exploit API endpoint with invalid scan ID"""
        response = self.client.post(
            '/scanner/api/scans/99999/exploit/',
            data={'action': 'all'},
            content_type='application/json',
            HTTP_AUTHORIZATION=f'Token {self.token.key}'
        )

        self.assertEqual(response.status_code, 404)

    def test_scan_results_include_exploit_data(self):
        """Test that scan results include exploit status"""
        response = self.client.get(
            f'/scanner/api/scans/{self.scan.id}/results/'
        )

        self.assertEqual(response.status_code, 200)
        data = response.json()
        
        # Check that vulnerability data includes exploit fields
        vuln_data = data['vulnerabilities'][0]
        self.assertIn('exploited', vuln_data)
        self.assertIn('exploit_status', vuln_data)
        self.assertIn('exploit_result', vuln_data)

    @patch('scanner.exploit_integration.HAS_REQUESTS', True)
    @patch('scanner.exploit_integration.requests')
    def test_context_aware_header_injection(self, mock_requests):
        """Test context-aware header injection attack"""
        from scanner.exploit_integration import exploit_vulnerability
        
        # Create vulnerability with 'header' in description
        vuln = Vulnerability.objects.create(
            scan=self.scan,
            vulnerability_type='other',
            severity='medium',
            url='https://example.com/test',
            parameter='redirect',
            description='Potential header injection vulnerability',
            evidence='User input reflected in HTTP headers'
        )
        
        # Mock response with injected header
        mock_response = type('Response', (), {
            'headers': {'X-Injected-Header': 'true', 'Content-Type': 'text/html'},
            'text': 'Response text',
        })()
        mock_requests.get.return_value = mock_response
        mock_requests.post.return_value = mock_response
        
        result = exploit_vulnerability(vuln)
        
        # Should succeed with context-aware header injection
        self.assertTrue(result['success'])
        self.assertIn('Context-Aware', result['plugin_used'])
        self.assertIn('Header', result['plugin_used'])
        self.assertIn('CRLF', result['evidence'])
        
    @patch('scanner.exploit_integration.HAS_REQUESTS', True)
    @patch('scanner.exploit_integration.requests')
    def test_context_aware_xss_attack(self, mock_requests):
        """Test context-aware XSS attack"""
        from scanner.exploit_integration import exploit_vulnerability
        
        # Create vulnerability with 'input' in description
        vuln = Vulnerability.objects.create(
            scan=self.scan,
            vulnerability_type='other',
            severity='high',
            url='https://example.com/search',
            parameter='q',
            description='User input reflected in search results',
            evidence='Form input not properly sanitized'
        )
        
        # Mock response with reflected XSS payload
        mock_response = type('Response', (), {
            'text': '<html><body><script>alert(1)</script></body></html>',
            'headers': {},
        })()
        mock_requests.get.return_value = mock_response
        mock_requests.post.return_value = mock_response
        
        result = exploit_vulnerability(vuln)
        
        # Should succeed with context-aware XSS
        self.assertTrue(result['success'])
        self.assertIn('Context-Aware', result['plugin_used'])
        self.assertIn('XSS', result['plugin_used'])
        self.assertIn('XSS', result['evidence'])
        
    @patch('scanner.exploit_integration.HAS_REQUESTS', True)
    @patch('scanner.exploit_integration.requests')
    def test_context_aware_no_match(self, mock_requests):
        """Test context-aware attack when no context matches"""
        from scanner.exploit_integration import exploit_vulnerability
        
        # Create vulnerability without matching keywords
        vuln = Vulnerability.objects.create(
            scan=self.scan,
            vulnerability_type='other',
            severity='low',
            url='https://example.com/api',
            parameter='id',
            description='Generic vulnerability',
            evidence='No specific indicators'
        )
        
        # Mock unsuccessful response
        mock_response = type('Response', (), {
            'text': 'Normal response text',
            'headers': {'Content-Type': 'text/html'},
        })()
        mock_requests.get.return_value = mock_response
        mock_requests.post.return_value = mock_response
        
        result = exploit_vulnerability(vuln)
        
        # Should fail with appropriate error
        self.assertFalse(result['success'])
        self.assertIn('Context-Aware', result['plugin_used'])
        self.assertIn('not successful', result['error'])
        
    @patch('scanner.exploit_integration.HAS_REQUESTS', False)
    def test_context_aware_without_requests_library(self):
        """Test context-aware attack when requests library is not available"""
        from scanner.exploit_integration import exploit_vulnerability
        
        # Create vulnerability with 'header' in description
        vuln = Vulnerability.objects.create(
            scan=self.scan,
            vulnerability_type='other',
            severity='medium',
            url='https://example.com/test',
            parameter='redirect',
            description='Potential header injection vulnerability',
            evidence='User input reflected in HTTP headers'
        )
        
        result = exploit_vulnerability(vuln)
        
        # Should fail with library not available error
        self.assertFalse(result['success'])
        self.assertIn('requests library not available', result['error'])
