"""
Tests for exploit plugin enhancements

This module tests the new adaptive exploit features, payload mutations,
configuration system, and fallback strategies.
"""

from django.test import TestCase
from scanner.plugins.adaptive_exploit_mixin import AdaptiveExploitMixin
from scanner.plugins.payload_mutator import PayloadMutator
from scanner.plugins.exploit_config import ExploitConfig, get_default_config
from scanner.plugins.exploits.last_resort_plugin import LastResortExploitPlugin
from scanner.exploit_integration import _merge_partial_evidence
from unittest.mock import Mock, patch
import re


class AdaptiveExploitMixinTestCase(TestCase):
    """Test cases for AdaptiveExploitMixin"""
    
    def setUp(self):
        """Set up test fixtures"""
        self.mixin = AdaptiveExploitMixin()
    
    def test_is_transient_error(self):
        """Test transient error detection"""
        # Transient errors
        timeout_error = Exception("Connection timeout")
        self.assertTrue(self.mixin._is_transient_error(timeout_error))
        
        rate_limit_error = Exception("Too many requests")
        self.assertTrue(self.mixin._is_transient_error(rate_limit_error))
        
        # Non-transient error
        normal_error = Exception("Invalid input")
        self.assertFalse(self.mixin._is_transient_error(normal_error))
    
    def test_detect_error_evidence(self):
        """Test error evidence detection"""
        # PHP error
        php_error = "Fatal error: Call to undefined function in /var/www/index.php on line 42"
        has_evidence, description = self.mixin._detect_error_evidence(php_error, 500)
        self.assertTrue(has_evidence)
        self.assertIn("Fatal error", description)
        
        # SQL error
        sql_error = "mysql_query() error: You have an error in your SQL syntax"
        has_evidence, description = self.mixin._detect_error_evidence(sql_error, 500)
        self.assertTrue(has_evidence)
        
        # No evidence
        normal_response = "Welcome to our website"
        has_evidence, description = self.mixin._detect_error_evidence(normal_response, 200)
        self.assertFalse(has_evidence)
    
    def test_get_adaptive_config_defaults(self):
        """Test default adaptive configuration"""
        config = self.mixin.get_adaptive_config_defaults()
        
        self.assertEqual(config['max_retries'], 3)
        self.assertEqual(config['timeout'], 10)
        self.assertFalse(config['verify_ssl'])
        self.assertEqual(config['http_methods'], ['GET', 'POST'])
        self.assertFalse(config['parallel_execution'])
        self.assertTrue(config['detect_partial_evidence'])


class PayloadMutatorTestCase(TestCase):
    """Test cases for PayloadMutator"""
    
    def test_generate_case_variations(self):
        """Test case variation generation"""
        variations = PayloadMutator.generate_case_variations('Config.php')
        
        self.assertIn('Config.php', variations)
        self.assertIn('config.php', variations)
        self.assertIn('CONFIG.PHP', variations)
        self.assertGreaterEqual(len(variations), 3)
    
    def test_generate_encoding_variations(self):
        """Test encoding variation generation"""
        variations = PayloadMutator.generate_encoding_variations('/etc/passwd')
        
        self.assertIn('/etc/passwd', variations)
        # Check for URL encoding
        self.assertTrue(any('%' in v for v in variations))
        # Should have multiple variations
        self.assertGreaterEqual(len(variations), 3)
    
    def test_generate_path_variations(self):
        """Test path variation generation"""
        variations = PayloadMutator.generate_path_variations('/etc/passwd')
        
        self.assertIn('/etc/passwd', variations)
        self.assertIn('etc/passwd', variations)  # Without leading slash
        # Check for slash conversions
        self.assertTrue(any('\\' in v for v in variations))
    
    def test_generate_extension_variations(self):
        """Test extension variation generation"""
        variations = PayloadMutator.generate_extension_variations('config.php')
        
        self.assertIn('config.php', variations)
        self.assertIn('config.php.bak', variations)
        self.assertIn('config.php.old', variations)
        # Should have multiple backup extensions
        self.assertGreaterEqual(len(variations), 5)
    
    def test_generate_traversal_variations(self):
        """Test traversal variation generation"""
        variations = PayloadMutator.generate_traversal_variations('etc/passwd')
        
        # Check for various traversal depths
        self.assertTrue(any('../etc/passwd' in v for v in variations))
        self.assertTrue(any('../../etc/passwd' in v for v in variations))
        # Check for encoded variations
        self.assertTrue(any('%2e%2e' in v for v in variations))
        # Should have many variations
        self.assertGreaterEqual(len(variations), 10)
    
    def test_mutate_payload_list(self):
        """Test payload list mutation"""
        base_payloads = ['config.php', '/etc/passwd']
        mutated = PayloadMutator.mutate_payload_list(
            base_payloads,
            mutation_types=['case', 'encoding']
        )
        
        # Should have more payloads than original
        self.assertGreater(len(mutated), len(base_payloads))
        # Original payloads should be included
        self.assertIn('config.php', mutated)
        self.assertIn('/etc/passwd', mutated)
    
    def test_generate_xxe_entity_variations(self):
        """Test XXE entity variation generation"""
        variations = PayloadMutator.generate_xxe_entity_variations(
            '/etc/passwd',
            'attacker.com'
        )
        
        # Should generate multiple XXE payloads
        self.assertGreaterEqual(len(variations), 3)
        # Check for XML structure
        for payload in variations:
            self.assertIn('<?xml', payload)
            self.assertIn('<!DOCTYPE', payload)


class ExploitConfigTestCase(TestCase):
    """Test cases for ExploitConfig"""
    
    def test_default_config(self):
        """Test default configuration"""
        config = ExploitConfig()
        
        self.assertEqual(config.get_intensity(), 'medium')
        self.assertIsInstance(config.get_config(), dict)
    
    def test_intensity_presets(self):
        """Test all intensity presets"""
        for intensity in ['low', 'medium', 'high', 'aggressive']:
            config = ExploitConfig(intensity=intensity)
            
            self.assertEqual(config.get_intensity(), intensity)
            cfg = config.get_config()
            
            # Check required keys exist
            self.assertIn('max_retries', cfg)
            self.assertIn('timeout', cfg)
            self.assertIn('parallel_execution', cfg)
            self.assertIn('enable_fallback', cfg)
    
    def test_intensity_comparison(self):
        """Test intensity level differences"""
        low = ExploitConfig('low').get_config()
        high = ExploitConfig('high').get_config()
        
        # High should have more retries
        self.assertGreater(high['max_retries'], low['max_retries'])
        # High should have longer timeout
        self.assertGreater(high['timeout'], low['timeout'])
        # High should enable parallel
        self.assertTrue(high['parallel_execution'])
        # Low should not enable fallback
        self.assertFalse(low['enable_fallback'])
    
    def test_custom_config_override(self):
        """Test custom configuration override"""
        config = ExploitConfig(
            intensity='medium',
            custom_config={'timeout': 99, 'custom_key': 'value'}
        )
        
        cfg = config.get_config()
        self.assertEqual(cfg['timeout'], 99)  # Overridden
        self.assertEqual(cfg['custom_key'], 'value')  # Added
        # Other settings should still be from preset
        self.assertIn('max_retries', cfg)
    
    def test_get_set_methods(self):
        """Test configuration get/set methods"""
        config = ExploitConfig()
        
        # Test get
        timeout = config.get('timeout')
        self.assertIsNotNone(timeout)
        
        # Test set
        config.set('timeout', 123)
        self.assertEqual(config.get('timeout'), 123)
        
        # Test get with default
        self.assertEqual(config.get('nonexistent', 'default'), 'default')
    
    def test_update_method(self):
        """Test configuration update method"""
        config = ExploitConfig()
        
        config.update({
            'timeout': 456,
            'new_setting': 'value'
        })
        
        self.assertEqual(config.get('timeout'), 456)
        self.assertEqual(config.get('new_setting'), 'value')
    
    def test_set_intensity(self):
        """Test changing intensity level"""
        config = ExploitConfig('low')
        self.assertEqual(config.get_intensity(), 'low')
        
        config.set_intensity('high')
        self.assertEqual(config.get_intensity(), 'high')
        
        # Config should be updated to high preset
        self.assertGreater(config.get('max_retries'), 1)
    
    def test_from_dict(self):
        """Test creating config from dictionary"""
        config_dict = {
            'intensity': 'high',
            'timeout': 789
        }
        
        config = ExploitConfig.from_dict(config_dict)
        
        self.assertEqual(config.get_intensity(), 'high')
        self.assertEqual(config.get('timeout'), 789)
    
    def test_to_dict(self):
        """Test exporting config to dictionary"""
        config = ExploitConfig('medium')
        config_dict = config.to_dict()
        
        self.assertIn('intensity', config_dict)
        self.assertEqual(config_dict['intensity'], 'medium')
        self.assertIn('max_retries', config_dict)


class LastResortPluginTestCase(TestCase):
    """Test cases for LastResortExploitPlugin"""
    
    def setUp(self):
        """Set up test fixtures"""
        self.plugin = LastResortExploitPlugin()
    
    def test_plugin_properties(self):
        """Test plugin basic properties"""
        self.assertEqual(self.plugin.vulnerability_type, 'last_resort')
        self.assertEqual(self.plugin.name, 'Last Resort Exploit')
        self.assertIsNotNone(self.plugin.description)
    
    def test_generate_payloads_files(self):
        """Test file discovery payload generation"""
        payloads = self.plugin.generate_payloads({'attack_type': 'files'})
        
        self.assertIsInstance(payloads, list)
        self.assertGreater(len(payloads), 0)
        # Check for common files
        self.assertTrue(any('.env' in p for p in payloads))
        self.assertTrue(any('config' in p for p in payloads))
    
    def test_generate_payloads_dirs(self):
        """Test directory discovery payload generation"""
        payloads = self.plugin.generate_payloads({'attack_type': 'dirs'})
        
        self.assertIsInstance(payloads, list)
        self.assertGreater(len(payloads), 0)
        # Check for common directories
        self.assertIn('admin', payloads)
        self.assertIn('backup', payloads)
    
    def test_generate_payloads_auth(self):
        """Test auth bypass payload generation"""
        payloads = self.plugin.generate_payloads({'attack_type': 'auth'})
        
        self.assertIsInstance(payloads, list)
        self.assertGreater(len(payloads), 0)
        # Check for SQL injection patterns
        self.assertTrue(any("'" in p for p in payloads))
    
    def test_generate_payloads_creds(self):
        """Test credential payload generation"""
        payloads = self.plugin.generate_payloads({'attack_type': 'creds'})
        
        self.assertIsInstance(payloads, list)
        self.assertGreater(len(payloads), 0)
        # Check for user:pass format
        self.assertTrue(any(':' in p for p in payloads))


class HelperFunctionTestCase(TestCase):
    """Test cases for helper functions"""
    
    def test_merge_partial_evidence_empty(self):
        """Test merging empty evidence"""
        result = _merge_partial_evidence(None, None)
        self.assertEqual(result, [])
    
    def test_merge_partial_evidence_lists(self):
        """Test merging lists"""
        list1 = ['evidence1', 'evidence2']
        list2 = ['evidence3']
        
        result = _merge_partial_evidence(list1, list2)
        
        self.assertEqual(len(result), 3)
        self.assertIn('evidence1', result)
        self.assertIn('evidence2', result)
        self.assertIn('evidence3', result)
    
    def test_merge_partial_evidence_items(self):
        """Test merging individual items"""
        item1 = 'evidence1'
        item2 = 'evidence2'
        
        result = _merge_partial_evidence(item1, item2)
        
        self.assertEqual(len(result), 2)
        self.assertIn('evidence1', result)
        self.assertIn('evidence2', result)
    
    def test_merge_partial_evidence_mixed(self):
        """Test merging mixed lists and items"""
        list1 = ['evidence1', 'evidence2']
        item1 = 'evidence3'
        
        result = _merge_partial_evidence(list1, item1, None)
        
        self.assertEqual(len(result), 3)
        self.assertIn('evidence1', result)
        self.assertIn('evidence2', result)
        self.assertIn('evidence3', result)


class IntegrationTestCase(TestCase):
    """Integration tests for complete exploit flow"""
    
    def test_exploit_config_integration(self):
        """Test config integration with exploitation"""
        # Create config for high intensity
        config = ExploitConfig(intensity='high')
        cfg = config.get_config()
        
        # Verify it has all required settings for exploitation
        self.assertIn('max_retries', cfg)
        self.assertIn('timeout', cfg)
        self.assertIn('enable_fallback', cfg)
        self.assertIn('parallel_execution', cfg)
        self.assertIn('http_methods', cfg)
        
        # Verify fallback is enabled for high intensity
        self.assertTrue(cfg['enable_fallback'])
    
    def test_default_config_singleton(self):
        """Test default config singleton"""
        config1 = get_default_config()
        config2 = get_default_config()
        
        # Should return same instance
        self.assertIs(config1, config2)
