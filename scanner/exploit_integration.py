"""
Scanner Integration Example

This module shows how to integrate the exploit plugin system with the
Megido scanner to automatically exploit discovered vulnerabilities.
"""

from typing import Dict, Any, Optional
import logging

from scanner.plugins import get_registry
from scanner.models import Vulnerability

logger = logging.getLogger(__name__)


def exploit_vulnerability(vulnerability: Vulnerability, 
                         config: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
    """
    Attempt to exploit a discovered vulnerability using the appropriate plugin.
    
    This function:
    1. Gets the plugin registry
    2. Finds the appropriate plugin for the vulnerability type
    3. Executes the exploit attack
    4. Returns the results
    
    Args:
        vulnerability: A Vulnerability model instance from the scanner
        config: Optional configuration for the attack:
               - timeout: Request timeout (default: 30)
               - verify_ssl: Whether to verify SSL certificates (default: False)
               - enable_error_based: Enable error-based detection (for SQLi)
               - enable_time_based: Enable time-based detection (for SQLi)
               - enable_exploitation: Enable exploitation phase (default: True)
    
    Returns:
        Dictionary containing:
        - success: Boolean indicating if vulnerability was exploited
        - findings: List of exploitation findings
        - data: Any extracted data
        - evidence: Evidence of exploitation
        - error: Error message if exploitation failed
        - plugin_used: Name of the plugin that was used
    
    Example:
        >>> from scanner.models import Vulnerability
        >>> vuln = Vulnerability.objects.get(id=1)
        >>> result = exploit_vulnerability(vuln)
        >>> if result['success']:
        ...     print(f"Successfully exploited: {result['evidence']}")
    """
    config = config or {}
    
    # Get the plugin registry
    registry = get_registry()
    
    # Check if a plugin exists for this vulnerability type
    if not registry.has_plugin(vulnerability.vulnerability_type):
        return {
            'success': False,
            'findings': [],
            'data': {},
            'evidence': '',
            'error': f'No exploit plugin available for {vulnerability.vulnerability_type}',
            'plugin_used': None,
        }
    
    # Get the appropriate plugin
    plugin = registry.get_plugin(vulnerability.vulnerability_type)
    
    logger.info(
        f"Attempting to exploit {vulnerability.vulnerability_type} vulnerability "
        f"at {vulnerability.url} using plugin: {plugin.name}"
    )
    
    # Prepare vulnerability data for the plugin
    # Try to detect method from vulnerability evidence, default to GET if not found
    method = 'GET'
    if vulnerability.evidence and 'POST' in vulnerability.evidence.upper():
        method = 'POST'
    
    vulnerability_data = {
        'parameter': vulnerability.parameter,
        'method': method,
        'params': {vulnerability.parameter: 'test'} if vulnerability.parameter and method == 'GET' else {},
        'data': {vulnerability.parameter: 'test'} if vulnerability.parameter and method == 'POST' else {},
        'url': vulnerability.url,
    }
    
    # Execute the attack
    try:
        result = plugin.execute_attack(
            target_url=vulnerability.url,
            vulnerability_data=vulnerability_data,
            config=config
        )
        
        result['plugin_used'] = plugin.name
        
        if result['success']:
            logger.info(
                f"Successfully exploited {vulnerability.vulnerability_type} at {vulnerability.url}"
            )
        else:
            logger.warning(
                f"Exploitation attempt failed: {result.get('error', 'Unknown error')}"
            )
        
        return result
        
    except Exception as e:
        logger.error(f"Error during exploitation: {e}")
        return {
            'success': False,
            'findings': [],
            'data': {},
            'evidence': '',
            'error': str(e),
            'plugin_used': plugin.name,
        }


def get_payloads_for_vulnerability(vulnerability: Vulnerability,
                                   context: Optional[Dict[str, Any]] = None) -> list:
    """
    Get appropriate payloads for testing a vulnerability.
    
    Args:
        vulnerability: A Vulnerability model instance
        context: Optional context for payload generation:
                - database_type: Database type for SQL injection
                - injection_type: Type of injection
                - Any other relevant context
    
    Returns:
        List of payload strings
    
    Example:
        >>> from scanner.models import Vulnerability
        >>> vuln = Vulnerability.objects.filter(vulnerability_type='sqli').first()
        >>> payloads = get_payloads_for_vulnerability(vuln, {'database_type': 'mysql'})
        >>> print(f"Got {len(payloads)} payloads for testing")
    """
    registry = get_registry()
    
    # Check if a plugin exists for this vulnerability type
    if not registry.has_plugin(vulnerability.vulnerability_type):
        logger.warning(
            f"No plugin available for {vulnerability.vulnerability_type}, "
            f"using payload generator directly"
        )
        from scanner.plugins import get_payload_generator
        generator = get_payload_generator()
        return generator.get_payloads(vulnerability.vulnerability_type, context)
    
    # Get the plugin and generate payloads
    plugin = registry.get_plugin(vulnerability.vulnerability_type)
    payloads = plugin.generate_payloads(context)
    
    logger.info(
        f"Generated {len(payloads)} payloads for {vulnerability.vulnerability_type} "
        f"using plugin: {plugin.name}"
    )
    
    return payloads


def get_remediation_for_vulnerability(vulnerability: Vulnerability) -> str:
    """
    Get remediation advice for a vulnerability.
    
    Args:
        vulnerability: A Vulnerability model instance
    
    Returns:
        String containing remediation advice
    
    Example:
        >>> from scanner.models import Vulnerability
        >>> vuln = Vulnerability.objects.get(id=1)
        >>> advice = get_remediation_for_vulnerability(vuln)
        >>> print(advice)
    """
    registry = get_registry()
    
    if not registry.has_plugin(vulnerability.vulnerability_type):
        return "No specific remediation advice available. Implement general security best practices."
    
    plugin = registry.get_plugin(vulnerability.vulnerability_type)
    return plugin.get_remediation_advice()


def list_available_exploit_plugins() -> list:
    """
    List all available exploit plugins.
    
    Returns:
        List of dictionaries containing plugin information
    
    Example:
        >>> plugins = list_available_exploit_plugins()
        >>> for plugin in plugins:
        ...     print(f"{plugin['name']}: {plugin['description']}")
    """
    registry = get_registry()
    return registry.list_plugins()


# Example usage in a Django view or management command
def example_usage():
    """
    Example showing how to use the integration functions.
    """
    from scanner.models import Vulnerability, Scan
    
    # Get a scan with vulnerabilities
    scan = Scan.objects.filter(status='completed').first()
    
    if not scan:
        print("No completed scans found")
        return
    
    # Get all vulnerabilities from the scan
    vulnerabilities = scan.vulnerabilities.all()
    
    print(f"Found {vulnerabilities.count()} vulnerabilities in scan {scan.id}")
    
    # List available plugins
    plugins = list_available_exploit_plugins()
    print(f"\nAvailable exploit plugins: {len(plugins)}")
    for plugin in plugins:
        print(f"  - {plugin['name']} ({plugin['vulnerability_type']})")
    
    # Attempt to exploit each vulnerability
    for vuln in vulnerabilities:
        print(f"\n{'=' * 80}")
        print(f"Vulnerability: {vuln.get_vulnerability_type_display()}")
        print(f"URL: {vuln.url}")
        print(f"Severity: {vuln.severity}")
        
        # Get remediation advice
        advice = get_remediation_for_vulnerability(vuln)
        print(f"Remediation: {advice[:100]}...")
        
        # Get sample payloads
        payloads = get_payloads_for_vulnerability(vuln)
        print(f"Available payloads: {len(payloads)}")
        
        # Attempt exploitation (be careful with this in production!)
        # Only enable if you have explicit permission to test the target
        ENABLE_EXPLOITATION = False  # Set to True only for authorized testing
        
        if ENABLE_EXPLOITATION:
            result = exploit_vulnerability(vuln, config={'verify_ssl': False})
            
            if result['success']:
                print(f"✓ Exploitation successful!")
                print(f"  Evidence: {result['evidence']}")
                print(f"  Findings: {len(result['findings'])}")
            else:
                print(f"✗ Exploitation failed: {result['error']}")
        else:
            print("Exploitation disabled (set ENABLE_EXPLOITATION=True to enable)")


if __name__ == '__main__':
    # This is just an example and won't work standalone without Django setup
    print("This is an integration example. Import these functions into your Django views or management commands.")
    print("\nExample functions:")
    print("  - exploit_vulnerability(vulnerability, config)")
    print("  - get_payloads_for_vulnerability(vulnerability, context)")
    print("  - get_remediation_for_vulnerability(vulnerability)")
    print("  - list_available_exploit_plugins()")
