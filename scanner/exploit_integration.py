"""
Scanner Integration Example

This module shows how to integrate the exploit plugin system with the
Megido scanner to automatically exploit discovered vulnerabilities.

SECURITY NOTE: This module is part of a penetration testing framework and 
intentionally makes HTTP requests to potentially malicious or vulnerable URLs.
It should only be used in authorized testing environments with explicit permission.
The SSRF warnings from static analysis tools are expected and intentional for this
security testing context.
"""

from typing import Dict, Any, Optional
import logging
import re
import json
from datetime import datetime

from scanner.plugins import get_registry
from scanner.models import Vulnerability

try:
    import requests
    HAS_REQUESTS = True
except ImportError:
    HAS_REQUESTS = False

# Import advanced scanner features
try:
    from discover.sensitive_scanner_advanced import (
        RiskScoringEngine,
        FalsePositiveManager,
        ComplianceMapper,
        RemediationEngine
    )
    HAS_ADVANCED_SCANNER = True
except ImportError:
    HAS_ADVANCED_SCANNER = False
    logging.warning("Advanced scanner features not available")

logger = logging.getLogger(__name__)


def _attempt_header_injection(vulnerability: Vulnerability, config: Dict[str, Any]) -> Dict[str, Any]:
    """
    Attempt CRLF/header injection attack on the vulnerability.
    
    Security Note: This function intentionally makes HTTP requests to user-provided URLs
    as part of security testing/exploitation. This is expected behavior in a penetration
    testing framework. The URLs come from Vulnerability objects that are created during
    scanning and should be used only in authorized testing environments.
    
    Args:
        vulnerability: Vulnerability instance
        config: Configuration dictionary
        
    Returns:
        Dictionary with attack results
    """
    if not HAS_REQUESTS:
        return {
            'success': False,
            'findings': [],
            'data': {},
            'evidence': '',
            'error': 'requests library not available',
        }
    
    timeout = config.get('timeout', 30)
    verify_ssl = config.get('verify_ssl', False)
    findings = []
    
    # CRLF injection payloads
    crlf_payloads = [
        '\r\nX-Injected-Header: true',
        '\r\n\r\nHTTP/1.1 200 OK\r\nX-Injected: true',
        '%0d%0aX-Injected-Header: true',
        '%0D%0AX-Injected-Header: true',
        '\nX-Injected-Header: true',
        '%0aX-Injected-Header: true',
    ]
    
    try:
        for payload in crlf_payloads:
            # Determine method
            method = 'GET'
            if vulnerability.evidence and 'POST' in vulnerability.evidence.upper():
                method = 'POST'
            
            # Prepare request
            url = vulnerability.url
            if vulnerability.parameter:
                if method == 'GET':
                    # Add payload to parameter in URL
                    from urllib.parse import urlencode, urlparse, parse_qs, urlunparse
                    parsed = urlparse(url)
                    params = parse_qs(parsed.query)
                    params[vulnerability.parameter] = [payload]
                    new_query = urlencode(params, doseq=True)
                    url = urlunparse((parsed.scheme, parsed.netloc, parsed.path, 
                                    parsed.params, new_query, parsed.fragment))
                    
                    response = requests.get(url, timeout=timeout, verify=verify_ssl, 
                                           allow_redirects=False)
                else:
                    data = {vulnerability.parameter: payload}
                    response = requests.post(url, data=data, timeout=timeout, 
                                           verify=verify_ssl, allow_redirects=False)
            else:
                # Try in URL path
                if '?' not in url:
                    url = url + '?test=' + payload
                response = requests.get(url, timeout=timeout, verify=verify_ssl, 
                                       allow_redirects=False)
            
            # Check for header injection
            injected_header_found = False
            for header_name, header_value in response.headers.items():
                if 'injected' in header_name.lower() or 'injected' in str(header_value).lower():
                    injected_header_found = True
                    findings.append(f'Injected header detected: {header_name}: {header_value}')
                    break
            
            if injected_header_found:
                return {
                    'success': True,
                    'findings': findings,
                    'data': {'injected_headers': findings},
                    'evidence': f'CRLF injection successful with payload: {payload[:50]}...',
                    'error': '',
                }
                
    except Exception as e:
        logger.debug(f"Header injection attempt failed: {e}")
    
    return {
        'success': False,
        'findings': findings,
        'data': {},
        'evidence': '',
        'error': 'Header injection attempts were not successful',
    }


def _attempt_xss_attack(vulnerability: Vulnerability, config: Dict[str, Any]) -> Dict[str, Any]:
    """
    Attempt reflected XSS attack on the vulnerability.
    
    Security Note: This function intentionally makes HTTP requests to user-provided URLs
    as part of security testing/exploitation. This is expected behavior in a penetration
    testing framework. The URLs come from Vulnerability objects that are created during
    scanning and should be used only in authorized testing environments.
    
    Args:
        vulnerability: Vulnerability instance
        config: Configuration dictionary
        
    Returns:
        Dictionary with attack results
    """
    if not HAS_REQUESTS:
        return {
            'success': False,
            'findings': [],
            'data': {},
            'evidence': '',
            'error': 'requests library not available',
        }
    
    timeout = config.get('timeout', 30)
    verify_ssl = config.get('verify_ssl', False)
    findings = []
    
    # XSS payloads
    xss_payloads = [
        '<script>alert(1)</script>',
        '<img src=x onerror=alert(1)>',
        '<svg/onload=alert(1)>',
        '"><script>alert(1)</script>',
        '\'><script>alert(1)</script>',
        '<iframe src="javascript:alert(1)">',
    ]
    
    # Threshold for determining likely exploitable XSS
    # We check for presence of dangerous characters/keywords that would enable XSS
    # If at least 3 are present unescaped, the reflection is likely exploitable
    MIN_DANGEROUS_CHARS_FOR_XSS = 3
    dangerous_chars = ['<', '>', '"', "'", 'script', 'onerror', 'onload']
    
    try:
        for payload in xss_payloads:
            # Determine method
            method = 'GET'
            if vulnerability.evidence and 'POST' in vulnerability.evidence.upper():
                method = 'POST'
            
            # Prepare request
            url = vulnerability.url
            if vulnerability.parameter:
                if method == 'GET':
                    from urllib.parse import urlencode, urlparse, parse_qs, urlunparse
                    parsed = urlparse(url)
                    params = parse_qs(parsed.query)
                    params[vulnerability.parameter] = [payload]
                    new_query = urlencode(params, doseq=True)
                    url = urlunparse((parsed.scheme, parsed.netloc, parsed.path, 
                                    parsed.params, new_query, parsed.fragment))
                    
                    response = requests.get(url, timeout=timeout, verify=verify_ssl)
                else:
                    data = {vulnerability.parameter: payload}
                    response = requests.post(url, data=data, timeout=timeout, verify=verify_ssl)
            else:
                # Try in URL parameter
                if '?' not in url:
                    url = url + '?test=' + payload
                response = requests.get(url, timeout=timeout, verify=verify_ssl)
            
            # Check if payload is reflected in response
            if payload in response.text:
                findings.append(f'XSS payload reflected: {payload}')
                
                # Additional checks for unescaped reflection
                unescaped_count = sum(1 for char in dangerous_chars if char in response.text)
                
                if unescaped_count >= MIN_DANGEROUS_CHARS_FOR_XSS:  # Likely exploitable
                    return {
                        'success': True,
                        'findings': findings,
                        'data': {'reflected_payload': payload, 'url': url},
                        'evidence': f'XSS payload reflected unescaped: {payload}',
                        'error': '',
                    }
    
    except Exception as e:
        logger.debug(f"XSS attack attempt failed: {e}")
    
    if findings:
        return {
            'success': True,
            'findings': findings,
            'data': {'reflected_payloads': findings},
            'evidence': 'XSS payloads reflected but may be escaped',
            'error': '',
        }
    
    return {
        'success': False,
        'findings': findings,
        'data': {},
        'evidence': '',
        'error': 'XSS attempts were not successful',
    }


def _attempt_context_aware_attack(vulnerability: Vulnerability, 
                                   config: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
    """
    Attempt context-aware attacks based on vulnerability description.
    
    Args:
        vulnerability: Vulnerability instance
        config: Optional configuration dictionary
        
    Returns:
        Dictionary with attack results
    """
    config = config or {}
    description_lower = (vulnerability.description or '').lower()
    evidence_lower = (vulnerability.evidence or '').lower()
    combined_text = description_lower + ' ' + evidence_lower
    
    logger.info(
        f"Attempting context-aware attack for {vulnerability.vulnerability_type} "
        f"at {vulnerability.url}"
    )
    
    # Check for header-related vulnerabilities
    if 'header' in combined_text:
        logger.info("Detected header-related context, attempting header injection")
        result = _attempt_header_injection(vulnerability, config)
        if result['success']:
            result['plugin_used'] = 'Context-Aware: Header Injection'
            return result
    
    # Check for input/form-related vulnerabilities
    if 'input' in combined_text or 'form' in combined_text:
        logger.info("Detected input/form-related context, attempting XSS")
        result = _attempt_xss_attack(vulnerability, config)
        if result['success']:
            result['plugin_used'] = 'Context-Aware: XSS'
            return result
    
    # If no context matched or attacks failed
    return {
        'success': False,
        'findings': [],
        'data': {},
        'evidence': '',
        'error': f'No exploit plugin available for {vulnerability.vulnerability_type} and context-aware attacks were not successful',
        'plugin_used': 'Context-Aware Fallback',
    }


def exploit_vulnerability(vulnerability: Vulnerability, 
                         config: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
    """
    Attempt to exploit a discovered vulnerability using the appropriate plugin.
    
    This function:
    1. Gets the plugin registry
    2. Finds the appropriate plugin for the vulnerability type
    3. If no plugin exists, attempts context-aware attacks based on vulnerability description:
       - Header injection for vulnerabilities mentioning 'header'
       - XSS attacks for vulnerabilities mentioning 'input' or 'form'
    4. Executes the exploit attack
    5. Returns the results
    
    Args:
        vulnerability: A Vulnerability model instance from the scanner
        config: Optional configuration for the attack:
               - timeout: Request timeout (default: 30)
               - verify_ssl: Whether to verify SSL certificates (default: False)
               - enable_error_based: Enable error-based detection (for SQLi)
               - enable_time_based: Enable time-based detection (for SQLi)
               - enable_exploitation: Enable exploitation phase (default: True)
    
    Returns:
        Dictionary containing:
        - success: Boolean indicating if vulnerability was exploited
        - findings: List of exploitation findings
        - data: Any extracted data
        - evidence: Evidence of exploitation
        - error: Error message if exploitation failed
        - plugin_used: Name of the plugin that was used (or 'Context-Aware: <type>')
    
    Example:
        >>> from scanner.models import Vulnerability
        >>> vuln = Vulnerability.objects.get(id=1)
        >>> result = exploit_vulnerability(vuln)
        >>> if result['success']:
        ...     print(f"Successfully exploited: {result['evidence']}")
    """
    config = config or {}
    
    # Get the plugin registry
    registry = get_registry()
    
    # Check if a plugin exists for this vulnerability type
    if not registry.has_plugin(vulnerability.vulnerability_type):
        # Attempt context-aware attack as fallback
        logger.info(
            f"No plugin available for {vulnerability.vulnerability_type}, "
            f"attempting context-aware fallback attack"
        )
        return _attempt_context_aware_attack(vulnerability, config)
    
    # Get the appropriate plugin
    plugin = registry.get_plugin(vulnerability.vulnerability_type)
    
    logger.info(
        f"Attempting to exploit {vulnerability.vulnerability_type} vulnerability "
        f"at {vulnerability.url} using plugin: {plugin.name}"
    )
    
    # Prepare vulnerability data for the plugin
    # Try to detect method from vulnerability evidence, default to GET if not found
    method = 'GET'
    if vulnerability.evidence and 'POST' in vulnerability.evidence.upper():
        method = 'POST'
    
    vulnerability_data = {
        'parameter': vulnerability.parameter,
        'method': method,
        'params': {vulnerability.parameter: 'test'} if vulnerability.parameter and method == 'GET' else {},
        'data': {vulnerability.parameter: 'test'} if vulnerability.parameter and method == 'POST' else {},
        'url': vulnerability.url,
    }
    
    # Execute the attack
    try:
        result = plugin.execute_attack(
            target_url=vulnerability.url,
            vulnerability_data=vulnerability_data,
            config=config
        )
        
        result['plugin_used'] = plugin.name
        
        if result['success']:
            logger.info(
                f"Successfully exploited {vulnerability.vulnerability_type} at {vulnerability.url}"
            )
        else:
            logger.warning(
                f"Exploitation attempt failed: {result.get('error', 'Unknown error')}"
            )
        
        return result
        
    except Exception as e:
        logger.error(f"Error during exploitation: {e}")
        return {
            'success': False,
            'findings': [],
            'data': {},
            'evidence': '',
            'error': str(e),
            'plugin_used': plugin.name,
        }


def get_payloads_for_vulnerability(vulnerability: Vulnerability,
                                   context: Optional[Dict[str, Any]] = None) -> list:
    """
    Get appropriate payloads for testing a vulnerability.
    
    Args:
        vulnerability: A Vulnerability model instance
        context: Optional context for payload generation:
                - database_type: Database type for SQL injection
                - injection_type: Type of injection
                - Any other relevant context
    
    Returns:
        List of payload strings
    
    Example:
        >>> from scanner.models import Vulnerability
        >>> vuln = Vulnerability.objects.filter(vulnerability_type='sqli').first()
        >>> payloads = get_payloads_for_vulnerability(vuln, {'database_type': 'mysql'})
        >>> print(f"Got {len(payloads)} payloads for testing")
    """
    registry = get_registry()
    
    # Check if a plugin exists for this vulnerability type
    if not registry.has_plugin(vulnerability.vulnerability_type):
        logger.warning(
            f"No plugin available for {vulnerability.vulnerability_type}, "
            f"using payload generator directly"
        )
        from scanner.plugins import get_payload_generator
        generator = get_payload_generator()
        return generator.get_payloads(vulnerability.vulnerability_type, context)
    
    # Get the plugin and generate payloads
    plugin = registry.get_plugin(vulnerability.vulnerability_type)
    payloads = plugin.generate_payloads(context)
    
    logger.info(
        f"Generated {len(payloads)} payloads for {vulnerability.vulnerability_type} "
        f"using plugin: {plugin.name}"
    )
    
    return payloads


def get_remediation_for_vulnerability(vulnerability: Vulnerability) -> str:
    """
    Get remediation advice for a vulnerability.
    
    Args:
        vulnerability: A Vulnerability model instance
    
    Returns:
        String containing remediation advice
    
    Example:
        >>> from scanner.models import Vulnerability
        >>> vuln = Vulnerability.objects.get(id=1)
        >>> advice = get_remediation_for_vulnerability(vuln)
        >>> print(advice)
    """
    registry = get_registry()
    
    if not registry.has_plugin(vulnerability.vulnerability_type):
        return "No specific remediation advice available. Implement general security best practices."
    
    plugin = registry.get_plugin(vulnerability.vulnerability_type)
    return plugin.get_remediation_advice()


def list_available_exploit_plugins() -> list:
    """
    List all available exploit plugins.
    
    Returns:
        List of dictionaries containing plugin information
    
    Example:
        >>> plugins = list_available_exploit_plugins()
        >>> for plugin in plugins:
        ...     print(f"{plugin['name']}: {plugin['description']}")
    """
    registry = get_registry()
    return registry.list_plugins()


def _exploit_vulnerability_and_update(vuln, config: Optional[Dict[str, Any]], results: Dict[str, Any]) -> None:
    """
    Helper function to exploit a single vulnerability and update tracking results.
    
    Args:
        vuln: Vulnerability instance to exploit
        config: Optional configuration for attacks
        results: Dictionary to update with results (modified in place)
    """
    from django.utils import timezone
    
    # Mark as in progress
    vuln.exploit_status = 'in_progress'
    vuln.save()
    
    # Attempt exploitation
    result = exploit_vulnerability(vuln, config)
    
    # Update vulnerability with results
    vuln.exploit_attempted_at = timezone.now()
    
    if result['success']:
        vuln.exploited = True
        vuln.exploit_status = 'success'
        vuln.verified = True  # Mark as verified with real exploitation
        results['exploited'] += 1
        
        # Store proof of impact with detailed evidence
        proof_parts = []
        if result.get('evidence'):
            proof_parts.append(f"Evidence: {result['evidence']}")
        if result.get('data'):
            proof_parts.append(f"Extracted Data: {json.dumps(result['data'], indent=2)}")
        if result.get('findings'):
            proof_parts.append(f"Findings: {'; '.join(str(f) for f in result['findings'][:5])}")
        vuln.proof_of_impact = '\n\n'.join(proof_parts) if proof_parts else result.get('evidence', '')
        
        # Capture visual proof of exploitation if enabled
        capture_config = config.get('visual_proof', {}) if config else {}
        if capture_config.get('enabled', True):  # Enabled by default
            _capture_visual_proof(vuln, result, capture_config)
        
        # Increase confidence score for verified vulnerabilities
        vuln.confidence_score = min(1.0, vuln.confidence_score + 0.3)
        
    elif result.get('plugin_used') is None:
        vuln.exploit_status = 'no_plugin'
        results['no_plugin'] += 1
    else:
        vuln.exploit_status = 'failed'
        results['failed'] += 1
    
    # Store detailed results
    vuln.exploit_result = format_exploit_result(result)
    
    # Apply risk scoring if available
    if HAS_ADVANCED_SCANNER:
        apply_risk_scoring(vuln)
        apply_compliance_mapping(vuln)
        apply_remediation_advice(vuln)
    
    vuln.save()
    
    # Add to results list
    results['results'].append({
        'vulnerability_id': vuln.id,
        'vulnerability_type': vuln.get_vulnerability_type_display(),
        'url': vuln.url,
        'success': result['success'],
        'verified': vuln.verified,
        'risk_score': vuln.risk_score,
        'plugin_used': result.get('plugin_used'),
        'evidence': result.get('evidence', ''),
        'error': result.get('error', ''),
    })
    
    logger.info(
        f"Exploit attempt for vulnerability {vuln.id} ({vuln.vulnerability_type}): "
        f"{'SUCCESS' if result['success'] else 'FAILED'} - Risk Score: {vuln.risk_score:.1f}"
    )


def exploit_all_vulnerabilities(scan_id: int, config: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
    """
    Attempt to exploit all vulnerabilities in a scan that have compatible plugins.
    
    Args:
        scan_id: The scan ID to process
        config: Optional configuration for attacks
    
    Returns:
        Dictionary containing:
        - total: Total number of vulnerabilities
        - exploited: Number successfully exploited
        - failed: Number that failed
        - no_plugin: Number with no compatible plugin
        - results: List of individual exploit results
    """
    from scanner.models import Scan
    
    try:
        scan = Scan.objects.get(id=scan_id)
    except Scan.DoesNotExist:
        return {
            'error': f'Scan {scan_id} not found',
            'total': 0,
            'exploited': 0,
            'failed': 0,
            'no_plugin': 0,
            'results': []
        }
    
    vulnerabilities = scan.vulnerabilities.all()
    results = {
        'total': vulnerabilities.count(),
        'exploited': 0,
        'failed': 0,
        'no_plugin': 0,
        'results': []
    }
    
    for vuln in vulnerabilities:
        _exploit_vulnerability_and_update(vuln, config, results)
    
    return results


def exploit_selected_vulnerabilities(vulnerability_ids: list, config: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
    """
    Attempt to exploit specific vulnerabilities by ID.
    
    Args:
        vulnerability_ids: List of vulnerability IDs to exploit
        config: Optional configuration for attacks
    
    Returns:
        Dictionary containing:
        - total: Total number of vulnerabilities processed
        - exploited: Number successfully exploited
        - failed: Number that failed
        - no_plugin: Number with no compatible plugin
        - results: List of individual exploit results
    """
    from scanner.models import Vulnerability
    
    vulnerabilities = Vulnerability.objects.filter(id__in=vulnerability_ids)
    
    results = {
        'total': vulnerabilities.count(),
        'exploited': 0,
        'failed': 0,
        'no_plugin': 0,
        'results': []
    }
    
    for vuln in vulnerabilities:
        _exploit_vulnerability_and_update(vuln, config, results)
    
    return results


def _capture_visual_proof(vuln: Vulnerability, result: Dict[str, Any], 
                          capture_config: Dict[str, Any]) -> None:
    """
    Capture visual proof (screenshot or GIF) of successful exploitation.
    
    Args:
        vuln: Vulnerability instance
        result: Exploitation result dictionary
        capture_config: Visual proof configuration
    """
    try:
        # Import visual proof capture module
        from scanner.visual_proof_capture import get_visual_proof_capture
        
        # Get capture instance
        capture = get_visual_proof_capture()
        if not capture:
            logger.info("Visual proof capture not available (missing dependencies)")
            return
        
        # Determine capture type based on vulnerability type
        # Dynamic vulnerabilities get GIFs, static get screenshots
        dynamic_types = ['xss', 'csrf', 'clickjacking']
        capture_type = 'gif' if vuln.vulnerability_type in dynamic_types else 'screenshot'
        
        # Override with config if specified
        capture_type = capture_config.get('type', capture_type)
        duration = capture_config.get('duration', 3.0)
        
        # Capture visual proof
        logger.info(f"Capturing visual proof for {vuln.vulnerability_type} vulnerability {vuln.id}")
        proof_data = capture.capture_exploit_proof(
            vuln_type=vuln.vulnerability_type,
            vuln_id=vuln.id,
            url=vuln.url,
            capture_type=capture_type,
            duration=duration
        )
        
        if proof_data:
            # Update vulnerability with visual proof info
            vuln.visual_proof_path = proof_data['path']
            vuln.visual_proof_type = proof_data['type']
            vuln.visual_proof_size = proof_data['size']
            
            logger.info(
                f"Visual proof captured: {proof_data['type']} "
                f"({proof_data['size']} bytes) at {proof_data['path']}"
            )
        else:
            logger.warning(f"Failed to capture visual proof for vulnerability {vuln.id}")
            
    except Exception as e:
        # Don't fail exploitation if visual capture fails
        logger.error(f"Visual proof capture error: {e}", exc_info=True)


def format_exploit_result(result: Dict[str, Any]) -> str:
    """
    Format exploit result for storage.
    
    Args:
        result: Dictionary containing exploit results
    
    Returns:
        Formatted string representation of the results
    """
    lines = []
    
    if result.get('plugin_used'):
        lines.append(f"Plugin: {result['plugin_used']}")
    
    if result['success']:
        lines.append("Status: SUCCESS")
        if result.get('evidence'):
            lines.append(f"Evidence: {result['evidence']}")
        if result.get('findings'):
            lines.append(f"Findings: {len(result['findings'])} items found")
            for i, finding in enumerate(result['findings'][:5], 1):  # Show first 5
                lines.append(f"  {i}. {finding}")
        if result.get('data'):
            lines.append("Data extracted:")
            for key, value in list(result['data'].items())[:5]:  # Show first 5
                lines.append(f"  {key}: {value}")
    else:
        lines.append("Status: FAILED")
        if result.get('error'):
            lines.append(f"Error: {result['error']}")
    
    return '\n'.join(lines)


def apply_risk_scoring(vuln: Vulnerability) -> None:
    """
    Apply risk scoring to a vulnerability using the advanced scanner's risk engine.
    
    Args:
        vuln: Vulnerability instance to score
    """
    if not HAS_ADVANCED_SCANNER:
        # Basic fallback scoring
        severity_scores = {'critical': 90, 'high': 70, 'medium': 50, 'low': 30}
        vuln.risk_score = severity_scores.get(vuln.severity, 50)
        vuln.risk_level = vuln.severity
        return
    
    try:
        # Create risk scoring engine
        risk_engine = RiskScoringEngine()
        
        # Determine exposure level based on evidence
        exposure_level = 'medium'
        if vuln.verified:
            exposure_level = 'high'
        elif vuln.confidence_score < 0.3:
            exposure_level = 'low'
        
        # Calculate risk score
        risk_score = risk_engine.calculate_risk_score({
            'type': vuln.vulnerability_type,
            'severity': vuln.severity,
            'source': vuln.url,
            'confidence': vuln.confidence_score,
            'verified': vuln.verified,
        }, exposure_level=exposure_level)
        
        # Update vulnerability fields
        vuln.risk_score = risk_score.composite_score
        vuln.risk_level = risk_score.risk_level
        
        logger.info(f"Applied risk score {vuln.risk_score:.1f} ({vuln.risk_level}) to vulnerability {vuln.id}")
        
    except Exception as e:
        logger.error(f"Error applying risk scoring: {e}")
        # Fallback to basic scoring
        severity_scores = {'critical': 90, 'high': 70, 'medium': 50, 'low': 30}
        vuln.risk_score = severity_scores.get(vuln.severity, 50)
        vuln.risk_level = vuln.severity


def apply_compliance_mapping(vuln: Vulnerability) -> None:
    """
    Map vulnerability to compliance frameworks.
    
    Args:
        vuln: Vulnerability instance
    """
    if not HAS_ADVANCED_SCANNER:
        return
    
    try:
        compliance_mapper = ComplianceMapper()
        
        # Map to compliance frameworks
        violations = compliance_mapper.map_finding_to_compliance({
            'type': vuln.vulnerability_type,
            'severity': vuln.severity,
            'category': vuln.vulnerability_type,
        })
        
        # Store as JSON
        vuln.compliance_violations = violations if violations else {}
        
        logger.info(f"Mapped vulnerability {vuln.id} to {len(violations)} compliance frameworks")
        
    except Exception as e:
        logger.error(f"Error applying compliance mapping: {e}")


def apply_remediation_advice(vuln: Vulnerability) -> None:
    """
    Generate and apply remediation advice to vulnerability.
    
    Args:
        vuln: Vulnerability instance
    """
    if not HAS_ADVANCED_SCANNER:
        # Use plugin remediation if available
        registry = get_registry()
        if registry.has_plugin(vuln.vulnerability_type):
            plugin = registry.get_plugin(vuln.vulnerability_type)
            vuln.remediation = plugin.get_remediation_advice()
        return
    
    try:
        remediation_engine = RemediationEngine()
        
        # Generate remediation
        remediation = remediation_engine.generate_remediation({
            'type': vuln.vulnerability_type,
            'severity': vuln.severity,
            'source': vuln.url,
            'risk_score': {'composite_score': vuln.risk_score},
        })
        
        # Update fields
        if not vuln.remediation:  # Don't override existing remediation
            vuln.remediation = remediation['action']
        vuln.remediation_priority = remediation['priority']
        vuln.remediation_effort = remediation['effort_estimate']
        
        logger.info(f"Applied remediation advice to vulnerability {vuln.id}")
        
    except Exception as e:
        logger.error(f"Error applying remediation advice: {e}")


def filter_false_positives(vulnerabilities, fp_manager=None) -> list:
    """
    Filter out known false positives from a list of vulnerabilities.
    
    Args:
        vulnerabilities: QuerySet or list of Vulnerability instances
        fp_manager: Optional FalsePositiveManager instance
    
    Returns:
        Filtered list of vulnerabilities
    """
    if not HAS_ADVANCED_SCANNER or not fp_manager:
        # Basic filtering - just filter out marked false positives
        return [v for v in vulnerabilities if v.false_positive_status != 'false_positive']
    
    try:
        # Use advanced false positive manager
        filtered = []
        for vuln in vulnerabilities:
            finding_dict = {
                'type': vuln.vulnerability_type,
                'source': vuln.url,
                'line': 0,
                'match': vuln.evidence or '',
            }
            
            # Check if it's a false positive
            if not fp_manager.is_false_positive(finding_dict):
                filtered.append(vuln)
            else:
                # Mark as false positive if not already marked
                if vuln.false_positive_status == 'unknown':
                    vuln.false_positive_status = 'false_positive'
                    vuln.false_positive_reason = 'Automatically identified by FalsePositiveManager'
                    vuln.save()
        
        logger.info(f"Filtered {len(vulnerabilities) - len(filtered)} false positives")
        return filtered
        
    except Exception as e:
        logger.error(f"Error filtering false positives: {e}")
        return list(vulnerabilities)


def apply_advanced_features_to_scan(scan_id: int) -> Dict[str, Any]:
    """
    Apply all advanced scanner features to vulnerabilities in a scan.
    
    This includes:
    - Risk scoring
    - False positive filtering
    - Compliance mapping
    - Remediation suggestions
    
    Args:
        scan_id: Scan ID to process
    
    Returns:
        Dictionary with results
    """
    from scanner.models import Scan
    
    try:
        scan = Scan.objects.get(id=scan_id)
    except Scan.DoesNotExist:
        return {'error': f'Scan {scan_id} not found'}
    
    vulnerabilities = scan.vulnerabilities.all()
    
    results = {
        'total_vulnerabilities': vulnerabilities.count(),
        'processed': 0,
        'false_positives_identified': 0,
        'risk_scored': 0,
        'compliance_mapped': 0,
    }
    
    # Initialize managers if available
    fp_manager = None
    if HAS_ADVANCED_SCANNER:
        try:
            fp_manager = FalsePositiveManager()
        except Exception as e:
            logger.warning(f"Could not initialize FalsePositiveManager: {e}")
    
    for vuln in vulnerabilities:
        # Apply risk scoring
        try:
            apply_risk_scoring(vuln)
            results['risk_scored'] += 1
        except Exception as e:
            logger.error(f"Error applying risk scoring to vuln {vuln.id}: {e}")
        
        # Apply compliance mapping
        try:
            apply_compliance_mapping(vuln)
            results['compliance_mapped'] += 1
        except Exception as e:
            logger.error(f"Error applying compliance mapping to vuln {vuln.id}: {e}")
        
        # Apply remediation advice
        try:
            apply_remediation_advice(vuln)
        except Exception as e:
            logger.error(f"Error applying remediation advice to vuln {vuln.id}: {e}")
        
        # Check for false positives
        if fp_manager and vuln.false_positive_status == 'unknown':
            finding_dict = {
                'type': vuln.vulnerability_type,
                'source': vuln.url,
                'line': 0,
                'match': vuln.evidence or '',
            }
            
            if fp_manager.is_false_positive(finding_dict):
                vuln.false_positive_status = 'false_positive'
                vuln.false_positive_reason = 'Automatically identified by FalsePositiveManager'
                results['false_positives_identified'] += 1
        
        vuln.save()
        results['processed'] += 1
    
    logger.info(
        f"Applied advanced features to scan {scan_id}: "
        f"{results['processed']} processed, {results['false_positives_identified']} false positives"
    )
    
    return results


# Example usage in a Django view or management command
def example_usage():
    """
    Example showing how to use the integration functions.
    """
    from scanner.models import Vulnerability, Scan
    
    # Get a scan with vulnerabilities
    scan = Scan.objects.filter(status='completed').first()
    
    if not scan:
        print("No completed scans found")
        return
    
    # Get all vulnerabilities from the scan
    vulnerabilities = scan.vulnerabilities.all()
    
    print(f"Found {vulnerabilities.count()} vulnerabilities in scan {scan.id}")
    
    # List available plugins
    plugins = list_available_exploit_plugins()
    print(f"\nAvailable exploit plugins: {len(plugins)}")
    for plugin in plugins:
        print(f"  - {plugin['name']} ({plugin['vulnerability_type']})")
    
    # Attempt to exploit each vulnerability
    for vuln in vulnerabilities:
        print(f"\n{'=' * 80}")
        print(f"Vulnerability: {vuln.get_vulnerability_type_display()}")
        print(f"URL: {vuln.url}")
        print(f"Severity: {vuln.severity}")
        
        # Get remediation advice
        advice = get_remediation_for_vulnerability(vuln)
        print(f"Remediation: {advice[:100]}...")
        
        # Get sample payloads
        payloads = get_payloads_for_vulnerability(vuln)
        print(f"Available payloads: {len(payloads)}")
        
        # Attempt exploitation (be careful with this in production!)
        # Only enable if you have explicit permission to test the target
        ENABLE_EXPLOITATION = False  # Set to True only for authorized testing
        
        if ENABLE_EXPLOITATION:
            result = exploit_vulnerability(vuln, config={'verify_ssl': False})
            
            if result['success']:
                print(f"✓ Exploitation successful!")
                print(f"  Evidence: {result['evidence']}")
                print(f"  Findings: {len(result['findings'])}")
            else:
                print(f"✗ Exploitation failed: {result['error']}")
        else:
            print("Exploitation disabled (set ENABLE_EXPLOITATION=True to enable)")


if __name__ == '__main__':
    # This is just an example and won't work standalone without Django setup
    print("This is an integration example. Import these functions into your Django views or management commands.")
    print("\nExample functions:")
    print("  - exploit_vulnerability(vulnerability, config)")
    print("  - get_payloads_for_vulnerability(vulnerability, context)")
    print("  - get_remediation_for_vulnerability(vulnerability)")
    print("  - list_available_exploit_plugins()")
