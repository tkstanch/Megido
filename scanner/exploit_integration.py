"""
Scanner Integration Example

This module shows how to integrate the exploit plugin system with the
Megido scanner to automatically exploit discovered vulnerabilities.
"""

from typing import Dict, Any, Optional
import logging

from scanner.plugins import get_registry
from scanner.models import Vulnerability

logger = logging.getLogger(__name__)


def exploit_vulnerability(vulnerability: Vulnerability, 
                         config: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
    """
    Attempt to exploit a discovered vulnerability using the appropriate plugin.
    
    This function:
    1. Gets the plugin registry
    2. Finds the appropriate plugin for the vulnerability type
    3. Executes the exploit attack
    4. Returns the results
    
    Args:
        vulnerability: A Vulnerability model instance from the scanner
        config: Optional configuration for the attack:
               - timeout: Request timeout (default: 30)
               - verify_ssl: Whether to verify SSL certificates (default: False)
               - enable_error_based: Enable error-based detection (for SQLi)
               - enable_time_based: Enable time-based detection (for SQLi)
               - enable_exploitation: Enable exploitation phase (default: True)
    
    Returns:
        Dictionary containing:
        - success: Boolean indicating if vulnerability was exploited
        - findings: List of exploitation findings
        - data: Any extracted data
        - evidence: Evidence of exploitation
        - error: Error message if exploitation failed
        - plugin_used: Name of the plugin that was used
    
    Example:
        >>> from scanner.models import Vulnerability
        >>> vuln = Vulnerability.objects.get(id=1)
        >>> result = exploit_vulnerability(vuln)
        >>> if result['success']:
        ...     print(f"Successfully exploited: {result['evidence']}")
    """
    config = config or {}
    
    # Get the plugin registry
    registry = get_registry()
    
    # Check if a plugin exists for this vulnerability type
    if not registry.has_plugin(vulnerability.vulnerability_type):
        return {
            'success': False,
            'findings': [],
            'data': {},
            'evidence': '',
            'error': f'No exploit plugin available for {vulnerability.vulnerability_type}',
            'plugin_used': None,
        }
    
    # Get the appropriate plugin
    plugin = registry.get_plugin(vulnerability.vulnerability_type)
    
    logger.info(
        f"Attempting to exploit {vulnerability.vulnerability_type} vulnerability "
        f"at {vulnerability.url} using plugin: {plugin.name}"
    )
    
    # Prepare vulnerability data for the plugin
    # Try to detect method from vulnerability evidence, default to GET if not found
    method = 'GET'
    if vulnerability.evidence and 'POST' in vulnerability.evidence.upper():
        method = 'POST'
    
    vulnerability_data = {
        'parameter': vulnerability.parameter,
        'method': method,
        'params': {vulnerability.parameter: 'test'} if vulnerability.parameter and method == 'GET' else {},
        'data': {vulnerability.parameter: 'test'} if vulnerability.parameter and method == 'POST' else {},
        'url': vulnerability.url,
    }
    
    # Execute the attack
    try:
        result = plugin.execute_attack(
            target_url=vulnerability.url,
            vulnerability_data=vulnerability_data,
            config=config
        )
        
        result['plugin_used'] = plugin.name
        
        if result['success']:
            logger.info(
                f"Successfully exploited {vulnerability.vulnerability_type} at {vulnerability.url}"
            )
        else:
            logger.warning(
                f"Exploitation attempt failed: {result.get('error', 'Unknown error')}"
            )
        
        return result
        
    except Exception as e:
        logger.error(f"Error during exploitation: {e}")
        return {
            'success': False,
            'findings': [],
            'data': {},
            'evidence': '',
            'error': str(e),
            'plugin_used': plugin.name,
        }


def get_payloads_for_vulnerability(vulnerability: Vulnerability,
                                   context: Optional[Dict[str, Any]] = None) -> list:
    """
    Get appropriate payloads for testing a vulnerability.
    
    Args:
        vulnerability: A Vulnerability model instance
        context: Optional context for payload generation:
                - database_type: Database type for SQL injection
                - injection_type: Type of injection
                - Any other relevant context
    
    Returns:
        List of payload strings
    
    Example:
        >>> from scanner.models import Vulnerability
        >>> vuln = Vulnerability.objects.filter(vulnerability_type='sqli').first()
        >>> payloads = get_payloads_for_vulnerability(vuln, {'database_type': 'mysql'})
        >>> print(f"Got {len(payloads)} payloads for testing")
    """
    registry = get_registry()
    
    # Check if a plugin exists for this vulnerability type
    if not registry.has_plugin(vulnerability.vulnerability_type):
        logger.warning(
            f"No plugin available for {vulnerability.vulnerability_type}, "
            f"using payload generator directly"
        )
        from scanner.plugins import get_payload_generator
        generator = get_payload_generator()
        return generator.get_payloads(vulnerability.vulnerability_type, context)
    
    # Get the plugin and generate payloads
    plugin = registry.get_plugin(vulnerability.vulnerability_type)
    payloads = plugin.generate_payloads(context)
    
    logger.info(
        f"Generated {len(payloads)} payloads for {vulnerability.vulnerability_type} "
        f"using plugin: {plugin.name}"
    )
    
    return payloads


def get_remediation_for_vulnerability(vulnerability: Vulnerability) -> str:
    """
    Get remediation advice for a vulnerability.
    
    Args:
        vulnerability: A Vulnerability model instance
    
    Returns:
        String containing remediation advice
    
    Example:
        >>> from scanner.models import Vulnerability
        >>> vuln = Vulnerability.objects.get(id=1)
        >>> advice = get_remediation_for_vulnerability(vuln)
        >>> print(advice)
    """
    registry = get_registry()
    
    if not registry.has_plugin(vulnerability.vulnerability_type):
        return "No specific remediation advice available. Implement general security best practices."
    
    plugin = registry.get_plugin(vulnerability.vulnerability_type)
    return plugin.get_remediation_advice()


def list_available_exploit_plugins() -> list:
    """
    List all available exploit plugins.
    
    Returns:
        List of dictionaries containing plugin information
    
    Example:
        >>> plugins = list_available_exploit_plugins()
        >>> for plugin in plugins:
        ...     print(f"{plugin['name']}: {plugin['description']}")
    """
    registry = get_registry()
    return registry.list_plugins()


def exploit_all_vulnerabilities(scan_id: int, config: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
    """
    Attempt to exploit all vulnerabilities in a scan that have compatible plugins.
    
    Args:
        scan_id: The scan ID to process
        config: Optional configuration for attacks
    
    Returns:
        Dictionary containing:
        - total: Total number of vulnerabilities
        - exploited: Number successfully exploited
        - failed: Number that failed
        - no_plugin: Number with no compatible plugin
        - results: List of individual exploit results
    """
    from scanner.models import Scan
    from django.utils import timezone
    
    try:
        scan = Scan.objects.get(id=scan_id)
    except Scan.DoesNotExist:
        return {
            'error': f'Scan {scan_id} not found',
            'total': 0,
            'exploited': 0,
            'failed': 0,
            'no_plugin': 0,
            'results': []
        }
    
    vulnerabilities = scan.vulnerabilities.all()
    results = {
        'total': vulnerabilities.count(),
        'exploited': 0,
        'failed': 0,
        'no_plugin': 0,
        'results': []
    }
    
    for vuln in vulnerabilities:
        # Mark as in progress
        vuln.exploit_status = 'in_progress'
        vuln.save()
        
        # Attempt exploitation
        result = exploit_vulnerability(vuln, config)
        
        # Update vulnerability with results
        vuln.exploit_attempted_at = timezone.now()
        
        if result['success']:
            vuln.exploited = True
            vuln.exploit_status = 'success'
            results['exploited'] += 1
        elif result.get('plugin_used') is None:
            vuln.exploit_status = 'no_plugin'
            results['no_plugin'] += 1
        else:
            vuln.exploit_status = 'failed'
            results['failed'] += 1
        
        # Store detailed results
        vuln.exploit_result = format_exploit_result(result)
        vuln.save()
        
        # Add to results list
        results['results'].append({
            'vulnerability_id': vuln.id,
            'vulnerability_type': vuln.get_vulnerability_type_display(),
            'url': vuln.url,
            'success': result['success'],
            'plugin_used': result.get('plugin_used'),
            'evidence': result.get('evidence', ''),
            'error': result.get('error', ''),
        })
        
        logger.info(
            f"Exploit attempt for vulnerability {vuln.id} ({vuln.vulnerability_type}): "
            f"{'SUCCESS' if result['success'] else 'FAILED'}"
        )
    
    return results


def exploit_selected_vulnerabilities(vulnerability_ids: list, config: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
    """
    Attempt to exploit specific vulnerabilities by ID.
    
    Args:
        vulnerability_ids: List of vulnerability IDs to exploit
        config: Optional configuration for attacks
    
    Returns:
        Dictionary containing:
        - total: Total number of vulnerabilities processed
        - exploited: Number successfully exploited
        - failed: Number that failed
        - no_plugin: Number with no compatible plugin
        - results: List of individual exploit results
    """
    from scanner.models import Vulnerability
    from django.utils import timezone
    
    vulnerabilities = Vulnerability.objects.filter(id__in=vulnerability_ids)
    
    results = {
        'total': vulnerabilities.count(),
        'exploited': 0,
        'failed': 0,
        'no_plugin': 0,
        'results': []
    }
    
    for vuln in vulnerabilities:
        # Mark as in progress
        vuln.exploit_status = 'in_progress'
        vuln.save()
        
        # Attempt exploitation
        result = exploit_vulnerability(vuln, config)
        
        # Update vulnerability with results
        vuln.exploit_attempted_at = timezone.now()
        
        if result['success']:
            vuln.exploited = True
            vuln.exploit_status = 'success'
            results['exploited'] += 1
        elif result.get('plugin_used') is None:
            vuln.exploit_status = 'no_plugin'
            results['no_plugin'] += 1
        else:
            vuln.exploit_status = 'failed'
            results['failed'] += 1
        
        # Store detailed results
        vuln.exploit_result = format_exploit_result(result)
        vuln.save()
        
        # Add to results list
        results['results'].append({
            'vulnerability_id': vuln.id,
            'vulnerability_type': vuln.get_vulnerability_type_display(),
            'url': vuln.url,
            'success': result['success'],
            'plugin_used': result.get('plugin_used'),
            'evidence': result.get('evidence', ''),
            'error': result.get('error', ''),
        })
        
        logger.info(
            f"Exploit attempt for vulnerability {vuln.id} ({vuln.vulnerability_type}): "
            f"{'SUCCESS' if result['success'] else 'FAILED'}"
        )
    
    return results


def format_exploit_result(result: Dict[str, Any]) -> str:
    """
    Format exploit result for storage.
    
    Args:
        result: Dictionary containing exploit results
    
    Returns:
        Formatted string representation of the results
    """
    lines = []
    
    if result.get('plugin_used'):
        lines.append(f"Plugin: {result['plugin_used']}")
    
    if result['success']:
        lines.append("Status: SUCCESS")
        if result.get('evidence'):
            lines.append(f"Evidence: {result['evidence']}")
        if result.get('findings'):
            lines.append(f"Findings: {len(result['findings'])} items found")
            for i, finding in enumerate(result['findings'][:5], 1):  # Show first 5
                lines.append(f"  {i}. {finding}")
        if result.get('data'):
            lines.append("Data extracted:")
            for key, value in list(result['data'].items())[:5]:  # Show first 5
                lines.append(f"  {key}: {value}")
    else:
        lines.append("Status: FAILED")
        if result.get('error'):
            lines.append(f"Error: {result['error']}")
    
    return '\n'.join(lines)


# Example usage in a Django view or management command
def example_usage():
    """
    Example showing how to use the integration functions.
    """
    from scanner.models import Vulnerability, Scan
    
    # Get a scan with vulnerabilities
    scan = Scan.objects.filter(status='completed').first()
    
    if not scan:
        print("No completed scans found")
        return
    
    # Get all vulnerabilities from the scan
    vulnerabilities = scan.vulnerabilities.all()
    
    print(f"Found {vulnerabilities.count()} vulnerabilities in scan {scan.id}")
    
    # List available plugins
    plugins = list_available_exploit_plugins()
    print(f"\nAvailable exploit plugins: {len(plugins)}")
    for plugin in plugins:
        print(f"  - {plugin['name']} ({plugin['vulnerability_type']})")
    
    # Attempt to exploit each vulnerability
    for vuln in vulnerabilities:
        print(f"\n{'=' * 80}")
        print(f"Vulnerability: {vuln.get_vulnerability_type_display()}")
        print(f"URL: {vuln.url}")
        print(f"Severity: {vuln.severity}")
        
        # Get remediation advice
        advice = get_remediation_for_vulnerability(vuln)
        print(f"Remediation: {advice[:100]}...")
        
        # Get sample payloads
        payloads = get_payloads_for_vulnerability(vuln)
        print(f"Available payloads: {len(payloads)}")
        
        # Attempt exploitation (be careful with this in production!)
        # Only enable if you have explicit permission to test the target
        ENABLE_EXPLOITATION = False  # Set to True only for authorized testing
        
        if ENABLE_EXPLOITATION:
            result = exploit_vulnerability(vuln, config={'verify_ssl': False})
            
            if result['success']:
                print(f"✓ Exploitation successful!")
                print(f"  Evidence: {result['evidence']}")
                print(f"  Findings: {len(result['findings'])}")
            else:
                print(f"✗ Exploitation failed: {result['error']}")
        else:
            print("Exploitation disabled (set ENABLE_EXPLOITATION=True to enable)")


if __name__ == '__main__':
    # This is just an example and won't work standalone without Django setup
    print("This is an integration example. Import these functions into your Django views or management commands.")
    print("\nExample functions:")
    print("  - exploit_vulnerability(vulnerability, config)")
    print("  - get_payloads_for_vulnerability(vulnerability, context)")
    print("  - get_remediation_for_vulnerability(vulnerability)")
    print("  - list_available_exploit_plugins()")
