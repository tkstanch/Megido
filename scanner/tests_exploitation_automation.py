"""
Tests for Exploitation Automation Controller

Tests the new exploitation automation features including:
- ExploitationConfig validation
- ExploitationAutomationController initialization
- Plugin integration
- Exploitation routing
- Report generation
"""

import unittest
from unittest.mock import Mock, patch, MagicMock
import sys
import os

# Add parent directory to path
sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from scanner.plugins.exploitation_automation_controller import (
    ExploitationConfig,
    ExploitationResult,
    ExploitationAutomationController
)


class TestExploitationConfig(unittest.TestCase):
    """Test ExploitationConfig validation and defaults."""
    
    def test_default_config(self):
        """Test default configuration."""
        config = ExploitationConfig()
        
        # Check defaults
        self.assertTrue(config.enable_xss_exploitation)
        self.assertTrue(config.enable_info_disclosure_exploitation)
        self.assertTrue(config.enable_security_misconfiguration_exploitation)
        self.assertTrue(config.enable_xxe_exploitation)
        self.assertTrue(config.enable_mixed_content_detection)
        self.assertEqual(config.browser_automation_engine, 'playwright')
        self.assertTrue(config.browser_headless)
    
    def test_config_validation_success(self):
        """Test successful configuration validation."""
        config = ExploitationConfig(
            browser_automation_engine='playwright',
            oob_endpoint_base_url='https://callback.example.com',
            oob_timeout=30,
            exploitation_timeout=30
        )
        
        is_valid, error = config.validate()
        self.assertTrue(is_valid)
        self.assertIsNone(error)
    
    def test_config_validation_invalid_browser_engine(self):
        """Test validation failure for invalid browser engine."""
        config = ExploitationConfig(browser_automation_engine='invalid')
        
        is_valid, error = config.validate()
        self.assertFalse(is_valid)
        self.assertIn('Invalid browser_automation_engine', error)
    
    def test_config_validation_invalid_oob_url(self):
        """Test validation failure for invalid OOB URL."""
        config = ExploitationConfig(oob_endpoint_base_url='not-a-url')
        
        is_valid, error = config.validate()
        self.assertFalse(is_valid)
        self.assertIn('Invalid OOB endpoint URL', error)
    
    def test_config_validation_invalid_timeout(self):
        """Test validation failure for invalid timeout."""
        config = ExploitationConfig(oob_timeout=2)
        
        is_valid, error = config.validate()
        self.assertFalse(is_valid)
        self.assertIn('timeout must be at least 5 seconds', error)


class TestExploitationResult(unittest.TestCase):
    """Test ExploitationResult dataclass."""
    
    def test_result_creation(self):
        """Test creating an exploitation result."""
        result = ExploitationResult(
            vulnerability_type='xss',
            success=True,
            verified=True,
            evidence={'payload': '<script>alert(1)</script>'},
            proof_of_exploit={'screenshot': '/tmp/screenshot.png'}
        )
        
        self.assertEqual(result.vulnerability_type, 'xss')
        self.assertTrue(result.success)
        self.assertTrue(result.verified)
        self.assertIn('payload', result.evidence)
        self.assertIn('screenshot', result.proof_of_exploit)
    
    def test_result_to_dict(self):
        """Test converting result to dictionary."""
        result = ExploitationResult(
            vulnerability_type='xxe',
            success=True,
            verified=False
        )
        
        result_dict = result.to_dict()
        
        self.assertEqual(result_dict['vulnerability_type'], 'xxe')
        self.assertTrue(result_dict['success'])
        self.assertFalse(result_dict['verified'])
        self.assertIn('timestamp', result_dict)


class TestExploitationAutomationController(unittest.TestCase):
    """Test ExploitationAutomationController."""
    
    def test_controller_initialization(self):
        """Test controller initialization with default config."""
        controller = ExploitationAutomationController()
        
        self.assertIsNotNone(controller.config)
        self.assertEqual(controller.exploitation_stats['total_attempts'], 0)
        self.assertEqual(controller.exploitation_stats['successful_exploits'], 0)
    
    def test_controller_initialization_with_config(self):
        """Test controller initialization with custom config."""
        config = ExploitationConfig(
            enable_xss_exploitation=False,
            browser_automation_enabled=False
        )
        
        controller = ExploitationAutomationController(config)
        
        self.assertFalse(controller.config.enable_xss_exploitation)
        self.assertFalse(controller.config.browser_automation_enabled)
    
    def test_controller_initialization_invalid_config(self):
        """Test controller initialization with invalid config."""
        config = ExploitationConfig(browser_automation_engine='invalid')
        
        with self.assertRaises(ValueError) as context:
            ExploitationAutomationController(config)
        
        self.assertIn('Invalid configuration', str(context.exception))
    
    @patch('scanner.plugins.exploitation_automation_controller.XSSPlugin')
    def test_exploit_xss_disabled(self, mock_xss_plugin):
        """Test XSS exploitation when disabled."""
        config = ExploitationConfig(enable_xss_exploitation=False)
        controller = ExploitationAutomationController(config)
        
        result = controller.exploit_xss('http://example.com', {})
        
        self.assertFalse(result.success)
        self.assertIn('disabled', result.error.lower())
        mock_xss_plugin.assert_not_called()
    
    @patch('scanner.plugins.exploits.xss_plugin.XSSPlugin')
    def test_exploit_xss_success(self, mock_xss_plugin_class):
        """Test successful XSS exploitation."""
        # Setup mock
        mock_plugin = Mock()
        mock_plugin.execute_attack.return_value = {
            'success': True,
            'verified': True,
            'evidence': {'payload': '<script>alert(1)</script>'},
            'proof_of_exploit': {'screenshot': '/tmp/test.png'}
        }
        mock_xss_plugin_class.return_value = mock_plugin
        
        controller = ExploitationAutomationController()
        result = controller.exploit_xss('http://example.com', {'parameter': 'q'})
        
        self.assertTrue(result.success)
        self.assertTrue(result.verified)
        self.assertEqual(result.vulnerability_type, 'xss')
        self.assertEqual(controller.exploitation_stats['successful_exploits'], 1)
        self.assertEqual(controller.exploitation_stats['verified_exploits'], 1)
    
    @patch('scanner.plugins.exploits.xss_plugin.XSSPlugin')
    def test_exploit_xss_failure(self, mock_xss_plugin_class):
        """Test failed XSS exploitation."""
        # Setup mock
        mock_plugin = Mock()
        mock_plugin.execute_attack.return_value = {
            'success': False,
            'error': 'No XSS found'
        }
        mock_xss_plugin_class.return_value = mock_plugin
        
        controller = ExploitationAutomationController()
        result = controller.exploit_xss('http://example.com', {})
        
        self.assertFalse(result.success)
        self.assertEqual(controller.exploitation_stats['failed_attempts'], 1)
    
    def test_exploit_info_disclosure_disabled(self):
        """Test info disclosure exploitation when disabled."""
        config = ExploitationConfig(enable_info_disclosure_exploitation=False)
        controller = ExploitationAutomationController(config)
        
        result = controller.exploit_info_disclosure('http://example.com', {})
        
        self.assertFalse(result.success)
        self.assertIn('disabled', result.error.lower())
    
    @patch('scanner.plugins.exploits.info_disclosure_plugin.InfoDisclosurePlugin')
    def test_exploit_info_disclosure_success(self, mock_plugin_class):
        """Test successful info disclosure exploitation."""
        # Setup mock
        mock_plugin = Mock()
        mock_plugin.execute_attack.return_value = {
            'success': True,
            'verified': True,
            'evidence': {'file': '.env'},
            'data': {'content': 'DB_PASSWORD=secret'}
        }
        mock_plugin_class.return_value = mock_plugin
        
        controller = ExploitationAutomationController()
        result = controller.exploit_info_disclosure('http://example.com', {})
        
        self.assertTrue(result.success)
        self.assertEqual(result.vulnerability_type, 'info_disclosure')
    
    def test_exploit_security_misconfiguration_disabled(self):
        """Test security misconfiguration when disabled."""
        config = ExploitationConfig(enable_security_misconfiguration_exploitation=False)
        controller = ExploitationAutomationController(config)
        
        result = controller.exploit_security_misconfiguration('http://example.com', {})
        
        self.assertFalse(result.success)
        self.assertIn('disabled', result.error.lower())
    
    @patch('scanner.plugins.exploits.security_misconfiguration_plugin.SecurityMisconfigurationPlugin')
    def test_exploit_security_misconfiguration_success(self, mock_plugin_class):
        """Test successful security misconfiguration exploitation."""
        # Setup mock
        mock_plugin = Mock()
        mock_plugin.execute_attack.return_value = {
            'success': True,
            'verified': True,
            'evidence': {'missing_headers': ['CSP', 'HSTS']},
            'proof_of_exploit': {}
        }
        mock_plugin_class.return_value = mock_plugin
        
        controller = ExploitationAutomationController()
        result = controller.exploit_security_misconfiguration('http://example.com', {})
        
        self.assertTrue(result.success)
        self.assertEqual(result.vulnerability_type, 'security_misconfiguration')
    
    def test_exploit_xxe_disabled(self):
        """Test XXE exploitation when disabled."""
        config = ExploitationConfig(enable_xxe_exploitation=False)
        controller = ExploitationAutomationController(config)
        
        result = controller.exploit_xxe('http://example.com', {})
        
        self.assertFalse(result.success)
        self.assertIn('disabled', result.error.lower())
    
    @patch('scanner.plugins.exploits.xxe_plugin.XXEPlugin')
    def test_exploit_xxe_success(self, mock_plugin_class):
        """Test successful XXE exploitation."""
        # Setup mock
        mock_plugin = Mock()
        mock_plugin.execute_attack.return_value = {
            'success': True,
            'verified': True,
            'evidence': {'oob_callback': 'received'},
            'data': {'file': '/etc/passwd'}
        }
        mock_plugin_class.return_value = mock_plugin
        
        controller = ExploitationAutomationController()
        result = controller.exploit_xxe('http://example.com', {})
        
        self.assertTrue(result.success)
        self.assertTrue(result.verified)
        self.assertEqual(result.vulnerability_type, 'xxe')
    
    def test_detect_mixed_content_disabled(self):
        """Test mixed content detection when disabled."""
        config = ExploitationConfig(enable_mixed_content_detection=False)
        controller = ExploitationAutomationController(config)
        
        result = controller.detect_mixed_content('https://example.com')
        
        self.assertFalse(result.success)
        self.assertIn('disabled', result.error.lower())
    
    @patch('scanner.plugins.exploits.mixed_content_plugin.MixedContentPlugin')
    def test_detect_mixed_content_success(self, mock_plugin_class):
        """Test successful mixed content detection."""
        # Setup mock
        mock_plugin = Mock()
        mock_plugin.execute_attack.return_value = {
            'success': True,
            'verified': True,
            'evidence': {'total_resources': 5},
            'mixed_content_resources': {'scripts': ['http://example.com/script.js']}
        }
        mock_plugin_class.return_value = mock_plugin
        
        controller = ExploitationAutomationController()
        result = controller.detect_mixed_content('https://example.com')
        
        self.assertTrue(result.success)
        self.assertEqual(result.vulnerability_type, 'mixed_content')
    
    def test_exploit_vulnerability_routing(self):
        """Test vulnerability exploitation routing."""
        controller = ExploitationAutomationController()
        
        # Test XSS routing
        with patch.object(controller, 'exploit_xss') as mock_xss:
            mock_xss.return_value = ExploitationResult('xss', True)
            result = controller.exploit_vulnerability('xss', 'http://example.com', {})
            mock_xss.assert_called_once()
            self.assertEqual(result.vulnerability_type, 'xss')
        
        # Test XXE routing
        with patch.object(controller, 'exploit_xxe') as mock_xxe:
            mock_xxe.return_value = ExploitationResult('xxe', True)
            result = controller.exploit_vulnerability('xxe', 'http://example.com', {})
            mock_xxe.assert_called_once()
            self.assertEqual(result.vulnerability_type, 'xxe')
        
        # Test unknown type
        result = controller.exploit_vulnerability('unknown', 'http://example.com', {})
        self.assertFalse(result.success)
        self.assertIn('Unknown', result.error)
    
    def test_get_statistics(self):
        """Test getting exploitation statistics."""
        controller = ExploitationAutomationController()
        
        # Initial stats
        stats = controller.get_statistics()
        self.assertEqual(stats['total_attempts'], 0)
        self.assertEqual(stats['successful_exploits'], 0)
        
        # Simulate some attempts
        controller.exploitation_stats['total_attempts'] = 10
        controller.exploitation_stats['successful_exploits'] = 7
        controller.exploitation_stats['verified_exploits'] = 5
        controller.exploitation_stats['failed_attempts'] = 3
        
        stats = controller.get_statistics()
        self.assertEqual(stats['total_attempts'], 10)
        self.assertEqual(stats['successful_exploits'], 7)
        self.assertEqual(stats['verified_exploits'], 5)
        self.assertEqual(stats['failed_attempts'], 3)
    
    def test_generate_report(self):
        """Test report generation."""
        controller = ExploitationAutomationController()
        
        results = [
            ExploitationResult('xss', True, True),
            ExploitationResult('xss', True, False),
            ExploitationResult('xxe', True, True),
            ExploitationResult('info_disclosure', False),
        ]
        
        report = controller.generate_report(results)
        
        # Check summary
        self.assertEqual(report['summary']['total_exploits'], 4)
        self.assertEqual(report['summary']['successful'], 3)
        self.assertEqual(report['summary']['verified'], 2)
        self.assertEqual(report['summary']['failed'], 1)
        
        # Check by_type
        self.assertIn('xss', report['by_type'])
        self.assertEqual(report['by_type']['xss']['total'], 2)
        self.assertEqual(report['by_type']['xss']['successful'], 2)
        self.assertEqual(report['by_type']['xss']['verified'], 1)
        
        self.assertIn('xxe', report['by_type'])
        self.assertEqual(report['by_type']['xxe']['total'], 1)
        self.assertEqual(report['by_type']['xxe']['verified'], 1)
        
        self.assertIn('info_disclosure', report['by_type'])
        self.assertEqual(report['by_type']['info_disclosure']['failed'], 1)
        
        # Check results
        self.assertEqual(len(report['results']), 4)
        self.assertIn('generated_at', report)


class TestSecurityMisconfigurationPlugin(unittest.TestCase):
    """Test SecurityMisconfigurationPlugin."""
    
    def test_plugin_properties(self):
        """Test plugin basic properties."""
        from scanner.plugins.exploits.security_misconfiguration_plugin import SecurityMisconfigurationPlugin
        
        plugin = SecurityMisconfigurationPlugin()
        
        self.assertEqual(plugin.vulnerability_type, 'security_misconfiguration')
        self.assertEqual(plugin.name, 'Security Misconfiguration Exploit')
        self.assertIn('security', plugin.description.lower())
        self.assertEqual(plugin.get_severity_level(), 'high')


class TestMixedContentPlugin(unittest.TestCase):
    """Test MixedContentPlugin."""
    
    def test_plugin_properties(self):
        """Test plugin basic properties."""
        from scanner.plugins.exploits.mixed_content_plugin import MixedContentPlugin
        
        plugin = MixedContentPlugin()
        
        self.assertEqual(plugin.vulnerability_type, 'mixed_content')
        self.assertEqual(plugin.name, 'Mixed Content Detection')
        self.assertIn('mixed content', plugin.description.lower())
        self.assertEqual(plugin.get_severity_level(), 'high')


if __name__ == '__main__':
    unittest.main()
