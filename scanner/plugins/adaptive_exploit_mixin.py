"""
Adaptive Exploit Mixin

This module provides a base mixin for exploit plugins to add adaptive and resilient
exploitation capabilities including:
- Configurable retry logic with exponential backoff
- Multiple HTTP methods support (GET, POST, PUT, etc.)
- User-Agent rotation and custom headers
- Transient error detection and retry
- Evidence detection from error responses
- Parallel payload execution support
"""

import time
import logging
import re
from typing import Dict, List, Any, Optional, Callable, Tuple
from concurrent.futures import ThreadPoolExecutor, as_completed
from functools import wraps

try:
    import requests
    from requests.adapters import HTTPAdapter
    from urllib3.util.retry import Retry
    HAS_REQUESTS = True
except ImportError:
    HAS_REQUESTS = False

logger = logging.getLogger(__name__)


class AdaptiveExploitMixin:
    """
    Mixin class providing adaptive and resilient exploitation capabilities.
    
    This mixin can be added to any ExploitPlugin to enhance it with:
    - Intelligent retry logic
    - Multi-method HTTP support
    - Evidence detection from partial failures
    - Parallel payload execution
    """
    
    # User-Agent rotation pool
    USER_AGENTS = [
        'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
        'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
        'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
        'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:121.0) Gecko/20100101 Firefox/121.0',
        'Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:121.0) Gecko/20100101 Firefox/121.0',
    ]
    
    # HTTP methods to try
    HTTP_METHODS = ['GET', 'POST']
    
    # Transient error indicators
    TRANSIENT_ERRORS = [
        'timeout',
        'connection reset',
        'connection refused',
        'temporary failure',
        'service unavailable',
        'too many requests',
        'rate limit',
    ]
    
    # Evidence patterns in error responses
    ERROR_EVIDENCE_PATTERNS = [
        r'Fatal error.*in.*on line',  # PHP errors
        r'Warning:.*in.*on line',  # PHP warnings
        r'mysql_.*error',  # MySQL errors
        r'pg_query.*error',  # PostgreSQL errors
        r'ORA-\d+',  # Oracle errors
        r'SQL Server.*error',  # SQL Server errors
        r'Traceback \(most recent call last\)',  # Python tracebacks
        r'java\..*Exception',  # Java exceptions
        r'at.*\.java:\d+',  # Java stack traces
        r'System\..*Exception',  # .NET exceptions
        r'Stack Trace:',  # Generic stack traces
        r'ODBC.*error',  # ODBC errors
        r'sqlite.*error',  # SQLite errors
        r'Internal Server Error',  # Generic server errors with potential info
        r'Access denied for user',  # MySQL access denied
        r'permission denied',  # File/database permission errors
        r'could not open file',  # File access errors
        r'failed to open stream',  # PHP stream errors
        r'require\(.*\): failed',  # PHP require errors
        r'include\(.*\): failed',  # PHP include errors
    ]
    
    def _get_retry_session(self, max_retries: int = 3, backoff_factor: float = 0.3) -> 'requests.Session':
        """
        Create a requests session with retry strategy.
        
        Args:
            max_retries: Maximum number of retries
            backoff_factor: Backoff multiplier for retries
            
        Returns:
            Configured requests Session
        """
        if not HAS_REQUESTS:
            raise ImportError("requests library is required")
        
        session = requests.Session()
        retry_strategy = Retry(
            total=max_retries,
            status_forcelist=[429, 500, 502, 503, 504],
            allowed_methods=["HEAD", "GET", "POST", "PUT", "DELETE", "OPTIONS", "TRACE"],
            backoff_factor=backoff_factor
        )
        adapter = HTTPAdapter(max_retries=retry_strategy)
        session.mount("http://", adapter)
        session.mount("https://", adapter)
        return session
    
    def _is_transient_error(self, error: Exception) -> bool:
        """
        Check if an error is transient and should be retried.
        
        Args:
            error: Exception to check
            
        Returns:
            True if error is transient, False otherwise
        """
        error_str = str(error).lower()
        return any(indicator in error_str for indicator in self.TRANSIENT_ERRORS)
    
    def _detect_error_evidence(self, response_text: str, status_code: int) -> Tuple[bool, str]:
        """
        Detect evidence of vulnerability in error responses.
        
        Args:
            response_text: Response body text
            status_code: HTTP status code
            
        Returns:
            Tuple of (evidence_found, evidence_description)
        """
        # Check for error evidence patterns
        for pattern in self.ERROR_EVIDENCE_PATTERNS:
            match = re.search(pattern, response_text, re.IGNORECASE | re.MULTILINE)
            if match:
                evidence = match.group(0)[:200]  # First 200 chars
                return True, f"Error evidence detected (status {status_code}): {evidence}"
        
        # Check for interesting status codes
        if status_code in [401, 403]:
            # Look for informative error messages
            if any(keyword in response_text.lower() for keyword in 
                   ['denied', 'unauthorized', 'forbidden', 'access', 'permission']):
                return True, f"Access control error detected (status {status_code}), potential info leakage"
        
        if status_code >= 500:
            # Server errors might leak information
            if len(response_text) > 100:  # Non-trivial error response
                return True, f"Server error detected (status {status_code}), potential info leakage"
        
        return False, ""
    
    def _adaptive_request(self, url: str, method: str = 'GET', 
                          data: Optional[Dict[str, Any]] = None,
                          params: Optional[Dict[str, Any]] = None,
                          headers: Optional[Dict[str, str]] = None,
                          timeout: int = 10, verify_ssl: bool = False,
                          max_retries: int = 3, user_agent_index: int = 0) -> Optional['requests.Response']:
        """
        Make an adaptive HTTP request with retry logic.
        
        Args:
            url: Target URL
            method: HTTP method (GET, POST, etc.)
            data: POST data
            params: URL parameters
            headers: Custom headers
            timeout: Request timeout
            verify_ssl: Whether to verify SSL
            max_retries: Maximum number of retries
            user_agent_index: Index of user agent to use
            
        Returns:
            Response object or None if all retries failed
        """
        if not HAS_REQUESTS:
            logger.warning("requests library not available")
            return None
        
        # Prepare headers with User-Agent rotation
        request_headers = headers or {}
        if 'User-Agent' not in request_headers:
            request_headers['User-Agent'] = self.USER_AGENTS[user_agent_index % len(self.USER_AGENTS)]
        
        session = self._get_retry_session(max_retries=max_retries)
        
        for attempt in range(max_retries):
            try:
                if method.upper() == 'GET':
                    response = session.get(url, params=params, headers=request_headers,
                                          timeout=timeout, verify=verify_ssl,
                                          allow_redirects=True)
                elif method.upper() == 'POST':
                    response = session.post(url, data=data, params=params, 
                                           headers=request_headers,
                                           timeout=timeout, verify=verify_ssl,
                                           allow_redirects=True)
                elif method.upper() == 'PUT':
                    response = session.put(url, data=data, params=params,
                                          headers=request_headers,
                                          timeout=timeout, verify=verify_ssl,
                                          allow_redirects=True)
                else:
                    # Default to GET for unsupported methods
                    response = session.get(url, params=params, headers=request_headers,
                                          timeout=timeout, verify=verify_ssl,
                                          allow_redirects=True)
                
                return response
                
            except Exception as e:
                if self._is_transient_error(e):
                    if attempt < max_retries - 1:
                        # Exponential backoff
                        wait_time = (0.5 * (2 ** attempt))
                        logger.debug(f"Transient error, retrying in {wait_time}s: {e}")
                        time.sleep(wait_time)
                        continue
                logger.debug(f"Request failed after {attempt + 1} attempts: {e}")
        
        return None
    
    def _try_multiple_methods(self, url: str, payload: str, parameter: str,
                             config: Dict[str, Any], 
                             verify_func: Optional[Callable] = None) -> Dict[str, Any]:
        """
        Try payload with multiple HTTP methods.
        
        Args:
            url: Target URL
            payload: Payload to inject
            parameter: Parameter name
            config: Configuration dict
            verify_func: Optional function to verify success, takes response as arg
            
        Returns:
            Dict with success status and details
        """
        timeout = config.get('timeout', 10)
        verify_ssl = config.get('verify_ssl', False)
        max_retries = config.get('max_retries', 3)
        methods = config.get('http_methods', self.HTTP_METHODS)
        
        all_evidence = []
        
        for method_idx, method in enumerate(methods):
            for ua_idx in range(min(2, len(self.USER_AGENTS))):  # Try first 2 user agents
                try:
                    if method == 'GET':
                        response = self._adaptive_request(
                            url, method='GET',
                            params={parameter: payload},
                            timeout=timeout, verify_ssl=verify_ssl,
                            max_retries=max_retries, user_agent_index=ua_idx
                        )
                    else:  # POST
                        response = self._adaptive_request(
                            url, method='POST',
                            data={parameter: payload},
                            timeout=timeout, verify_ssl=verify_ssl,
                            max_retries=max_retries, user_agent_index=ua_idx
                        )
                    
                    if response is None:
                        continue
                    
                    # Check for evidence even in error responses
                    has_evidence, evidence_desc = self._detect_error_evidence(
                        response.text, response.status_code
                    )
                    if has_evidence:
                        all_evidence.append(evidence_desc)
                    
                    # If verification function provided, use it
                    if verify_func and verify_func(response):
                        return {
                            'success': True,
                            'response': response,
                            'method': method,
                            'payload': payload,
                            'evidence': f"Successful with {method} method"
                        }
                    
                    # Otherwise check for successful status codes
                    if 200 <= response.status_code < 300:
                        return {
                            'success': True,
                            'response': response,
                            'method': method,
                            'payload': payload,
                            'evidence': f"Successful with {method} method (status {response.status_code})"
                        }
                        
                except Exception as e:
                    logger.debug(f"Method {method} failed with UA {ua_idx}: {e}")
                    continue
        
        # Return partial evidence if found
        if all_evidence:
            return {
                'success': False,
                'partial_evidence': all_evidence,
                'message': 'No full exploitation, but evidence detected'
            }
        
        return {
            'success': False,
            'error': 'All methods and retries exhausted'
        }
    
    def _parallel_payload_execution(self, url: str, payloads: List[str], 
                                    parameter: str, config: Dict[str, Any],
                                    verify_func: Optional[Callable] = None,
                                    max_workers: int = 5) -> Dict[str, Any]:
        """
        Execute payloads in parallel for faster exploitation.
        
        Args:
            url: Target URL
            payloads: List of payloads to try
            parameter: Parameter name
            config: Configuration dict
            verify_func: Optional verification function
            max_workers: Maximum parallel workers
            
        Returns:
            Dict with success status and details
        """
        all_evidence = []
        
        def try_payload(payload: str) -> Dict[str, Any]:
            """Try a single payload."""
            return self._try_multiple_methods(url, payload, parameter, config, verify_func)
        
        # Execute payloads in parallel
        with ThreadPoolExecutor(max_workers=max_workers) as executor:
            future_to_payload = {executor.submit(try_payload, payload): payload 
                                for payload in payloads}
            
            for future in as_completed(future_to_payload):
                payload = future_to_payload[future]
                try:
                    result = future.result()
                    if result.get('success'):
                        # Cancel remaining futures
                        for f in future_to_payload:
                            f.cancel()
                        return result
                    
                    # Collect partial evidence
                    if result.get('partial_evidence'):
                        all_evidence.extend(result['partial_evidence'])
                        
                except Exception as e:
                    logger.debug(f"Payload {payload} failed: {e}")
        
        # Return partial evidence if found
        if all_evidence:
            return {
                'success': False,
                'partial_evidence': all_evidence,
                'message': 'No full exploitation, but evidence detected',
                'confidence': 'partial'
            }
        
        return {
            'success': False,
            'error': 'All payloads exhausted without success'
        }
    
    def get_adaptive_config_defaults(self) -> Dict[str, Any]:
        """
        Get default adaptive configuration.
        
        Returns:
            Dict of default configuration values
        """
        return {
            'max_retries': 3,
            'timeout': 10,
            'verify_ssl': False,
            'http_methods': ['GET', 'POST'],
            'parallel_execution': False,
            'max_workers': 5,
            'detect_partial_evidence': True,
        }
