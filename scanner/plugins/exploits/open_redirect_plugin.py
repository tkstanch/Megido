"""
Open Redirect Exploit Plugin

This plugin provides exploit capabilities for Open Redirect vulnerabilities.
"""

import sys
import os
from typing import Dict, List, Any, Optional
import logging

sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__)))))

from scanner.plugins.exploit_plugin import ExploitPlugin

try:
    import requests
    HAS_REQUESTS = True
except ImportError:
    HAS_REQUESTS = False

try:
    from scanner.visual_proof_capture import VisualProofCapture
    from scanner.media_manager import MediaManager
    HAS_VISUAL_PROOF = True
except ImportError:
    HAS_VISUAL_PROOF = False
    logging.warning("Visual proof modules not available")

logger = logging.getLogger(__name__)


class OpenRedirectPlugin(ExploitPlugin):
    """Open Redirect exploit plugin."""
    
    @property
    def vulnerability_type(self) -> str:
        return 'open_redirect'
    
    @property
    def name(self) -> str:
        return 'Open Redirect Exploit'
    
    @property
    def description(self) -> str:
        return 'Open Redirect exploit plugin for testing redirect vulnerabilities.'
    
    @property
    def version(self) -> str:
        return '2.0.0'
    
    def generate_payloads(self, context: Optional[Dict[str, Any]] = None) -> List[str]:
        """Generate Open Redirect payloads."""
        context = context or {}
        target_domain = context.get('target_domain', 'evil.com')
        
        return [
            f'http://{target_domain}',
            f'https://{target_domain}',
            f'//{target_domain}',
            f'http://{target_domain}/phishing',
        ]
    
    def execute_attack(self, target_url: str, vulnerability_data: Dict[str, Any],
                      config: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
        """Execute Open Redirect attack with visual proof capture."""
        if not HAS_REQUESTS:
            return {'success': False, 'error': 'Requests library not available', 'vulnerability_type': 'open_redirect'}
        
        parameter = vulnerability_data.get('parameter')
        if not parameter:
            return {'success': False, 'error': 'No parameter specified', 'vulnerability_type': 'open_redirect'}
        
        config = config or {}
        verify_ssl = config.get('verify_ssl', False)
        timeout = config.get('timeout', 10)
        
        # Test redirect with various payloads
        payloads = [
            ('http://evil.com', 'evil.com'),
            ('https://malicious-site.com', 'malicious-site.com'),
            ('//attacker.com', 'attacker.com'),
        ]
        
        successful_redirect = None
        redirect_location = None
        
        for payload, domain in payloads:
            try:
                params = {parameter: payload}
                response = requests.get(target_url, params=params, timeout=timeout, verify=verify_ssl, allow_redirects=False)
                
                if response.status_code in [301, 302, 303, 307, 308]:
                    location = response.headers.get('Location', '')
                    if domain in location:
                        successful_redirect = payload
                        redirect_location = location
                        logger.info(f"Open redirect confirmed with payload: {payload}")
                        break
            except Exception as e:
                logger.debug(f"Error testing payload {payload}: {e}")
        
        if successful_redirect:
            result = {
                'success': True,
                'evidence': f'Successful redirect to: {redirect_location}',
                'vulnerability_type': 'open_redirect',
                'message': 'Open redirect confirmed',
                'payload': successful_redirect,
                'redirect_location': redirect_location,
            }
            
            # Capture visual proof if available
            if HAS_VISUAL_PROOF and config.get('capture_visual_proof', True):
                visual_proofs = self._capture_visual_proof(
                    target_url, parameter, successful_redirect, redirect_location, config
                )
                if visual_proofs:
                    result['visual_proofs'] = visual_proofs
                    logger.info(f"Captured {len(visual_proofs)} visual proof(s)")
            
            return result
        
        return {'success': False, 'error': 'Could not exploit', 'vulnerability_type': 'open_redirect'}
    
    def _capture_visual_proof(self, url: str, parameter: str, payload: str,
                              redirect_location: str, config: Dict[str, Any]) -> List[Dict[str, Any]]:
        """
        Capture visual proof of Open Redirect exploitation.
        
        Args:
            url: Target URL
            parameter: Vulnerable parameter
            payload: Successful redirect payload
            redirect_location: Actual redirect location
            config: Configuration dictionary
            
        Returns:
            List of visual proof metadata dictionaries
        """
        visual_proofs = []
        
        try:
            proof_capture = VisualProofCapture()
            
            # Build proof URL
            proof_url = f"{url}?{parameter}={payload}"
            
            # Capture screenshot showing the redirect headers
            screenshot_data = proof_capture.capture_screenshot(
                proof_url,
                wait_time=1.0
            )
            
            if screenshot_data:
                visual_proofs.append({
                    'type': 'screenshot',
                    'data': screenshot_data,
                    'title': 'Open Redirect - External Domain Redirect',
                    'description': f'Browser redirected to external malicious domain: {redirect_location}',
                    'exploit_step': f'Redirect triggered via payload: {payload}',
                    'payload': payload,
                    'redirect_location': redirect_location
                })
            
            # Capture a second screenshot after following redirect (if it's a safe test)
            # We'll use a safer test domain for this
            test_domain = 'example.com'
            test_payload = f'http://{test_domain}'
            test_proof_url = f"{url}?{parameter}={test_payload}"
            
            screenshot_data2 = proof_capture.capture_screenshot(
                test_proof_url,
                wait_time=2.0
            )
            
            if screenshot_data2:
                visual_proofs.append({
                    'type': 'screenshot',
                    'data': screenshot_data2,
                    'title': 'Open Redirect - Redirect Confirmation',
                    'description': f'Successfully redirected to external domain via vulnerable parameter',
                    'exploit_step': f'Test redirect to {test_domain} confirms vulnerability',
                    'payload': test_payload
                })
            
        except Exception as e:
            logger.error(f"Failed to capture visual proof: {e}")
        
        return visual_proofs
    
    def verify(self, result: Dict[str, Any], 
               target_url: str,
               vulnerability_data: Dict[str, Any]) -> tuple:
        """Verify open redirect with proof of successful redirection."""
        if not result.get('success'):
            return False, None
        
        redirect_url = result.get('redirect_url', '')
        evidence = result.get('evidence', '')
        
        # Verified if we successfully triggered a redirect
        if redirect_url:
            proof = f"âœ“ VERIFIED - Open Redirect\n\nRedirected to: {redirect_url}\nEvidence: {evidence[:200]}\n\nImpact: Users can be redirected to malicious sites"
            return True, proof
        
        return False, None
    
    def get_severity_level(self) -> str:
        return 'medium'
    
    def get_remediation_advice(self) -> str:
        return (
            'Prevent Open Redirect attacks:\n'
            '1. Validate redirect URLs against whitelist\n'
            '2. Use relative URLs for redirects\n'
            '3. Implement redirect token validation\n'
            '4. Avoid user-controlled redirects\n'
            '5. Use indirect references\n'
            '6. Log and monitor redirects'
        )
