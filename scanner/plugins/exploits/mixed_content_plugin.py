"""
Mixed Content Detection and Exploitation Plugin

This plugin detects and tests mixed content vulnerabilities where HTTPS pages
load resources over insecure HTTP connections. This can lead to man-in-the-middle
attacks and content injection.

Features:
- Detection of HTTP resources on HTTPS pages (scripts, stylesheets, images, iframes, etc.)
- Browser automation to verify exploitability
- Classification by risk level (high: scripts/stylesheets, medium: other active content, low: passive content)
- Screenshot evidence capture
- Detailed resource inventory
"""

import sys
import os
import logging
import re
import tempfile
from typing import Dict, List, Any, Optional, Set, Tuple
from urllib.parse import urlparse, urljoin
from collections import defaultdict

sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__)))))

from scanner.plugins.exploit_plugin import ExploitPlugin

try:
    import requests
    HAS_REQUESTS = True
except ImportError:
    HAS_REQUESTS = False
    logging.warning("Requests library not available")

try:
    from bs4 import BeautifulSoup
    HAS_BS4 = True
except ImportError:
    HAS_BS4 = False
    logging.warning("BeautifulSoup not available")

try:
    from playwright.sync_api import sync_playwright, TimeoutError as PlaywrightTimeout
    HAS_PLAYWRIGHT = True
except ImportError:
    HAS_PLAYWRIGHT = False

try:
    from selenium import webdriver
    from selenium.webdriver.chrome.options import Options as ChromeOptions
    from selenium.common.exceptions import TimeoutException
    HAS_SELENIUM = True
except ImportError:
    HAS_SELENIUM = False

logger = logging.getLogger(__name__)


class MixedContentPlugin(ExploitPlugin):
    """
    Mixed content detection and exploitation plugin.
    
    Detects HTTP resources loaded on HTTPS pages and tests their exploitability.
    """
    
    # Resource types to check for mixed content
    RESOURCE_PATTERNS = {
        'script': {
            'tags': ['script'],
            'attributes': ['src'],
            'risk': 'critical',
            'description': 'JavaScript file loaded over HTTP can execute malicious code'
        },
        'stylesheet': {
            'tags': ['link'],
            'attributes': ['href'],
            'type_filter': 'stylesheet',
            'risk': 'high',
            'description': 'CSS file loaded over HTTP can inject malicious content'
        },
        'iframe': {
            'tags': ['iframe'],
            'attributes': ['src'],
            'risk': 'high',
            'description': 'IFrame loaded over HTTP can display malicious content'
        },
        'image': {
            'tags': ['img'],
            'attributes': ['src'],
            'risk': 'medium',
            'description': 'Image loaded over HTTP can be manipulated'
        },
        'video': {
            'tags': ['video', 'source'],
            'attributes': ['src'],
            'risk': 'medium',
            'description': 'Video loaded over HTTP can be replaced'
        },
        'audio': {
            'tags': ['audio', 'source'],
            'attributes': ['src'],
            'risk': 'medium',
            'description': 'Audio loaded over HTTP can be replaced'
        },
        'object': {
            'tags': ['object', 'embed'],
            'attributes': ['data', 'src'],
            'risk': 'high',
            'description': 'Plugin content loaded over HTTP can be malicious'
        },
        'form': {
            'tags': ['form'],
            'attributes': ['action'],
            'risk': 'critical',
            'description': 'Form submission over HTTP exposes sensitive data'
        },
    }
    
    @property
    def vulnerability_type(self) -> str:
        """Return the vulnerability type identifier."""
        return 'mixed_content'
    
    @property
    def name(self) -> str:
        """Return the plugin name."""
        return 'Mixed Content Detection'
    
    @property
    def description(self) -> str:
        """Return the plugin description."""
        return (
            'Mixed content detection plugin for identifying and testing HTTP resources '
            'loaded on HTTPS pages, which can lead to man-in-the-middle attacks.'
        )
    
    @property
    def version(self) -> str:
        """Return the plugin version."""
        return '1.0.0'
    
    def generate_payloads(self, context: Optional[Dict[str, Any]] = None) -> List[str]:
        """
        Generate payloads for testing mixed content.
        
        Args:
            context: Optional context
        
        Returns:
            List of test payloads (HTTP resource URLs)
        """
        # Mixed content is about detection, not payload injection
        return []
    
    def execute_attack(self, target_url: str, vulnerability_data: Dict[str, Any],
                      config: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
        """
        Detect and test mixed content vulnerabilities.
        
        Args:
            target_url: Target HTTPS URL to check
            vulnerability_data: Not used for mixed content detection
            config: Optional configuration
        
        Returns:
            Attack results with detected mixed content
        """
        config = config or {}
        logger.info(f"Starting mixed content detection for {target_url}")
        
        results = {
            'success': False,
            'verified': False,
            'evidence': {},
            'mixed_content_resources': {},
            'error': None
        }
        
        # Check if URL is HTTPS
        parsed_url = urlparse(target_url)
        if parsed_url.scheme != 'https':
            results['error'] = 'Target URL must use HTTPS for mixed content detection'
            return results
        
        try:
            # Detect mixed content in HTML
            html_mixed_content = self._detect_mixed_content_html(target_url, config)
            results['mixed_content_resources']['html_analysis'] = html_mixed_content
            
            # If browser automation enabled, verify with browser
            if config.get('test_exploitability', False):
                browser_results = self._test_with_browser(target_url, config)
                results['mixed_content_resources']['browser_verification'] = browser_results
                
                # Consider verified if browser detected mixed content
                if browser_results.get('mixed_content_detected'):
                    results['verified'] = True
            
            # Count total mixed content resources
            total_mixed_content = sum(
                len(resources) 
                for resources in html_mixed_content.values()
            )
            
            if total_mixed_content > 0:
                results['success'] = True
                results['evidence']['total_resources'] = total_mixed_content
                results['evidence']['by_type'] = {
                    resource_type: len(resources)
                    for resource_type, resources in html_mixed_content.items()
                }
            
        except Exception as e:
            logger.error(f"Mixed content detection failed: {e}", exc_info=True)
            results['error'] = str(e)
        
        return results
    
    def _detect_mixed_content_html(self, url: str, config: Dict[str, Any]) -> Dict[str, List[Dict[str, Any]]]:
        """
        Detect mixed content by parsing HTML.
        
        Args:
            url: Target HTTPS URL
            config: Configuration
        
        Returns:
            Dictionary mapping resource types to lists of mixed content resources
        """
        if not HAS_REQUESTS or not HAS_BS4:
            logger.warning("Requests or BeautifulSoup not available for HTML analysis")
            return {}
        
        mixed_content = defaultdict(list)
        
        try:
            timeout = config.get('timeout', 10)
            response = requests.get(url, timeout=timeout, verify=False, allow_redirects=True)
            soup = BeautifulSoup(response.text, 'html.parser')
            
            # Check each resource type
            for resource_type, resource_config in self.RESOURCE_PATTERNS.items():
                tags = resource_config['tags']
                attributes = resource_config['attributes']
                
                for tag_name in tags:
                    elements = soup.find_all(tag_name)
                    
                    for element in elements:
                        # Check if element has type filter
                        if 'type_filter' in resource_config:
                            type_attr = element.get('rel', [])
                            if isinstance(type_attr, str):
                                type_attr = [type_attr]
                            if resource_config['type_filter'] not in type_attr:
                                continue
                        
                        # Check each attribute
                        for attr in attributes:
                            resource_url = element.get(attr)
                            
                            if resource_url:
                                # Make absolute URL
                                absolute_url = urljoin(url, resource_url)
                                parsed_resource = urlparse(absolute_url)
                                
                                # Check if HTTP (mixed content)
                                if parsed_resource.scheme == 'http':
                                    mixed_content[resource_type].append({
                                        'url': absolute_url,
                                        'tag': tag_name,
                                        'attribute': attr,
                                        'risk': resource_config['risk'],
                                        'description': resource_config['description']
                                    })
                                    
                                    logger.warning(f"Mixed content detected: {absolute_url} "
                                                 f"(type: {resource_type}, risk: {resource_config['risk']})")
        
        except Exception as e:
            logger.error(f"Failed to analyze HTML for mixed content: {e}")
        
        return dict(mixed_content)
    
    def _test_with_browser(self, url: str, config: Dict[str, Any]) -> Dict[str, Any]:
        """
        Test mixed content using browser automation.
        
        Args:
            url: Target URL
            config: Configuration
        
        Returns:
            Browser test results
        """
        browser_engine = config.get('browser_engine', 'playwright')
        
        if browser_engine == 'playwright' and HAS_PLAYWRIGHT:
            return self._test_with_playwright(url, config)
        elif browser_engine == 'selenium' and HAS_SELENIUM:
            return self._test_with_selenium(url, config)
        else:
            return {
                'mixed_content_detected': False,
                'error': f'Browser automation not available (engine: {browser_engine})'
            }
    
    def _test_with_playwright(self, url: str, config: Dict[str, Any]) -> Dict[str, Any]:
        """Test mixed content using Playwright."""
        if not HAS_PLAYWRIGHT:
            return {'mixed_content_detected': False, 'error': 'Playwright not available'}
        
        results = {
            'mixed_content_detected': False,
            'console_messages': [],
            'security_warnings': [],
            'screenshot': None
        }
        
        try:
            with sync_playwright() as p:
                browser = p.chromium.launch(headless=config.get('browser_headless', True))
                context = browser.new_context()
                page = context.new_page()
                
                # Track console messages for security warnings
                def handle_console(msg):
                    text = msg.text
                    results['console_messages'].append(text)
                    
                    # Check for mixed content warnings
                    if 'mixed content' in text.lower() or 'insecure' in text.lower():
                        results['security_warnings'].append(text)
                        results['mixed_content_detected'] = True
                
                page.on('console', handle_console)
                
                # Navigate to page
                page.goto(url, timeout=config.get('timeout', 30) * 1000, wait_until='networkidle')
                
                # Capture screenshot if requested and mixed content detected
                if config.get('capture_screenshots', False) and results['mixed_content_detected']:
                    with tempfile.NamedTemporaryFile(mode='wb', suffix='.png', delete=False) as f:
                        screenshot_path = f.name
                    page.screenshot(path=screenshot_path)
                    results['screenshot'] = screenshot_path
                
                browser.close()
                
        except Exception as e:
            logger.error(f"Playwright mixed content test failed: {e}")
            results['error'] = str(e)
        
        return results
    
    def _test_with_selenium(self, url: str, config: Dict[str, Any]) -> Dict[str, Any]:
        """Test mixed content using Selenium."""
        if not HAS_SELENIUM:
            return {'mixed_content_detected': False, 'error': 'Selenium not available'}
        
        results = {
            'mixed_content_detected': False,
            'console_logs': [],
            'screenshot': None
        }
        
        try:
            options = ChromeOptions()
            if config.get('browser_headless', True):
                options.add_argument('--headless')
            options.add_argument('--no-sandbox')
            options.add_argument('--disable-dev-shm-usage')
            
            # Enable browser logging
            options.set_capability('goog:loggingPrefs', {'browser': 'ALL'})
            
            driver = webdriver.Chrome(options=options)
            driver.set_page_load_timeout(config.get('timeout', 30))
            
            # Navigate to page
            driver.get(url)
            
            # Get browser logs
            logs = driver.get_log('browser')
            for log in logs:
                message = log.get('message', '')
                results['console_logs'].append(message)
                
                # Check for mixed content warnings
                if 'mixed content' in message.lower() or 'insecure' in message.lower():
                    results['mixed_content_detected'] = True
            
            # Capture screenshot if requested and mixed content detected
            if config.get('capture_screenshots', False) and results['mixed_content_detected']:
                with tempfile.NamedTemporaryFile(mode='wb', suffix='.png', delete=False) as f:
                    screenshot_path = f.name
                driver.save_screenshot(screenshot_path)
                results['screenshot'] = screenshot_path
            
            driver.quit()
            
        except Exception as e:
            logger.error(f"Selenium mixed content test failed: {e}")
            results['error'] = str(e)
        
        return results
    
    def get_remediation_advice(self) -> str:
        """Return remediation advice."""
        return """
Mixed Content Remediation:

1. Upgrade all HTTP resources to HTTPS:
   - Scripts: Update <script src="http://..."> to https://
   - Stylesheets: Update <link href="http://..."> to https://
   - Images: Update <img src="http://..."> to https://
   - IFrames: Update <iframe src="http://..."> to https://
   - Other resources: Ensure all resources use HTTPS

2. Use Content-Security-Policy to block mixed content:
   - Add header: Content-Security-Policy: upgrade-insecure-requests
   - This will automatically upgrade HTTP requests to HTTPS

3. Use protocol-relative URLs as a temporary workaround:
   - Use // instead of http:// or https://
   - Example: <script src="//example.com/script.js">
   - Note: This is not recommended for long-term use

4. Check third-party resources:
   - Ensure CDN and external resources support HTTPS
   - Consider hosting resources locally if HTTPS not available

5. Test thoroughly:
   - Use browser developer tools to check for mixed content warnings
   - Verify all functionality works after migration
"""
    
    def get_severity_level(self) -> str:
        """Return severity level."""
        return 'high'


# Export the plugin
__all__ = ['MixedContentPlugin']
