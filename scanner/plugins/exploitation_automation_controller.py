"""
Exploitation Automation Controller

This module provides a centralized controller for automated exploitation
and verification across multiple vulnerability types. It orchestrates
exploitation attempts, manages OOB callbacks, and generates detailed
proof-of-exploitation reports.

Supported Vulnerability Types:
- XSS (with form injection, browser automation, OOB callbacks)
- Information Disclosure (file/path testing, content verification)
- Security Misconfiguration (header checks, CSP exploitation)
- XXE (entity injection, OOB verification)
- Mixed Content (HTTPS/HTTP resource detection and testing)

Features:
- Modular exploitation logic per vulnerability class
- Configurable OOB endpoint for callback verification
- Detailed logging and reporting per attempt
- Proof-of-exploit collection (screenshots, callbacks, DOM changes)
- Optional enable/disable per vulnerability type
"""

import logging
import time
from typing import Dict, List, Any, Optional, Set, Tuple
from dataclasses import dataclass, field
from datetime import datetime
from urllib.parse import urlparse

logger = logging.getLogger(__name__)


@dataclass
class ExploitationConfig:
    """
    Configuration for exploitation automation.
    
    Attributes:
        enable_xss_exploitation: Enable automated XSS exploitation
        enable_info_disclosure_exploitation: Enable info disclosure testing
        enable_security_misconfiguration_exploitation: Enable header/CSP testing
        enable_xxe_exploitation: Enable XXE exploitation
        enable_mixed_content_detection: Enable mixed content detection
        
        oob_endpoint_base_url: Base URL for OOB callback server (e.g., https://callback.example.com)
        oob_use_ngrok: Use ngrok for automatic OOB tunnel setup
        oob_timeout: Timeout in seconds for OOB callback verification
        
        browser_automation_enabled: Enable headless browser automation
        browser_automation_engine: Browser engine to use ('playwright' or 'selenium')
        browser_headless: Run browser in headless mode
        
        max_exploitation_attempts: Maximum exploitation attempts per finding
        exploitation_timeout: Timeout in seconds per exploitation attempt
        
        capture_screenshots: Capture screenshots of successful exploits
        capture_dom_snapshots: Capture DOM snapshots for verification
        capture_network_logs: Capture network logs during exploitation
        
        verbose_logging: Enable verbose logging for debugging
    """
    
    # Feature toggles
    enable_xss_exploitation: bool = True
    enable_info_disclosure_exploitation: bool = True
    enable_security_misconfiguration_exploitation: bool = True
    enable_xxe_exploitation: bool = True
    enable_mixed_content_detection: bool = True
    
    # OOB configuration
    oob_endpoint_base_url: Optional[str] = None
    oob_use_ngrok: bool = False
    oob_timeout: int = 30
    
    # Browser automation
    browser_automation_enabled: bool = True
    browser_automation_engine: str = 'playwright'  # 'playwright' or 'selenium'
    browser_headless: bool = True
    
    # Exploitation parameters
    max_exploitation_attempts: int = 3
    exploitation_timeout: int = 30
    
    # Evidence collection
    capture_screenshots: bool = True
    capture_dom_snapshots: bool = True
    capture_network_logs: bool = False
    
    # Logging
    verbose_logging: bool = False
    
    def validate(self) -> Tuple[bool, Optional[str]]:
        """
        Validate the configuration.
        
        Returns:
            Tuple of (is_valid, error_message)
        """
        if self.browser_automation_engine not in ['playwright', 'selenium']:
            return False, f"Invalid browser_automation_engine: {self.browser_automation_engine}"
        
        if self.oob_endpoint_base_url:
            parsed = urlparse(self.oob_endpoint_base_url)
            if not parsed.scheme or not parsed.netloc:
                return False, f"Invalid OOB endpoint URL: {self.oob_endpoint_base_url}"
        
        if self.oob_timeout < 5:
            return False, "OOB timeout must be at least 5 seconds"
        
        if self.exploitation_timeout < 5:
            return False, "Exploitation timeout must be at least 5 seconds"
        
        return True, None


@dataclass
class ExploitationResult:
    """
    Result of an exploitation attempt.
    
    Attributes:
        vulnerability_type: Type of vulnerability exploited
        success: Whether exploitation was successful
        verified: Whether exploitation was verified (e.g., via OOB callback)
        evidence: Evidence of successful exploitation
        proof_of_exploit: Detailed proof (screenshots, logs, etc.)
        error: Error message if exploitation failed
        timestamp: When the exploitation was attempted
    """
    vulnerability_type: str
    success: bool
    verified: bool = False
    evidence: Dict[str, Any] = field(default_factory=dict)
    proof_of_exploit: Dict[str, Any] = field(default_factory=dict)
    error: Optional[str] = None
    timestamp: datetime = field(default_factory=datetime.now)
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert result to dictionary format."""
        return {
            'vulnerability_type': self.vulnerability_type,
            'success': self.success,
            'verified': self.verified,
            'evidence': self.evidence,
            'proof_of_exploit': self.proof_of_exploit,
            'error': self.error,
            'timestamp': self.timestamp.isoformat(),
        }


class ExploitationAutomationController:
    """
    Central controller for automated vulnerability exploitation.
    
    This controller orchestrates exploitation attempts across multiple
    vulnerability types, managing configuration, OOB callbacks, and
    evidence collection.
    """
    
    def __init__(self, config: Optional[ExploitationConfig] = None):
        """
        Initialize the exploitation automation controller.
        
        Args:
            config: Optional configuration. If None, uses default config.
        """
        self.config = config or ExploitationConfig()
        
        # Validate configuration
        is_valid, error = self.config.validate()
        if not is_valid:
            raise ValueError(f"Invalid configuration: {error}")
        
        # Setup logging
        log_level = logging.DEBUG if self.config.verbose_logging else logging.INFO
        logger.setLevel(log_level)
        
        # Initialize components
        self._oob_framework = None
        self._callback_manager = None
        self._browser_exploit = None
        
        # Statistics
        self.exploitation_stats = {
            'total_attempts': 0,
            'successful_exploits': 0,
            'verified_exploits': 0,
            'failed_attempts': 0,
            'by_type': {}
        }
        
        logger.info("ExploitationAutomationController initialized")
        logger.info(f"Configuration: {self._get_config_summary()}")
    
    def _get_config_summary(self) -> Dict[str, Any]:
        """Get a summary of the current configuration."""
        return {
            'xss_enabled': self.config.enable_xss_exploitation,
            'info_disclosure_enabled': self.config.enable_info_disclosure_exploitation,
            'security_misconfig_enabled': self.config.enable_security_misconfiguration_exploitation,
            'xxe_enabled': self.config.enable_xxe_exploitation,
            'mixed_content_enabled': self.config.enable_mixed_content_detection,
            'oob_configured': bool(self.config.oob_endpoint_base_url or self.config.oob_use_ngrok),
            'browser_automation': self.config.browser_automation_enabled,
        }
    
    def _init_oob_framework(self):
        """Lazy initialization of OOB exploitation framework."""
        if self._oob_framework is None:
            try:
                from scanner.plugins.oob_exploitation_framework import OOBExploitationFramework
                from scanner.callback_manager import CallbackManager
                
                self._oob_framework = OOBExploitationFramework()
                self._callback_manager = CallbackManager(
                    use_ngrok=self.config.oob_use_ngrok,
                    callback_url=self.config.oob_endpoint_base_url
                )
                
                logger.info("OOB exploitation framework initialized")
            except Exception as e:
                logger.error(f"Failed to initialize OOB framework: {e}")
                raise
    
    def _init_browser_exploit(self):
        """Lazy initialization of browser exploitation framework."""
        if self._browser_exploit is None and self.config.browser_automation_enabled:
            try:
                from scanner.plugins.advanced_browser_exploit import get_advanced_browser_exploit
                self._browser_exploit = get_advanced_browser_exploit()
                logger.info(f"Browser exploitation initialized with {self.config.browser_automation_engine}")
            except Exception as e:
                logger.error(f"Failed to initialize browser exploit: {e}")
                # Don't raise - continue without browser automation
    
    def exploit_xss(self, target_url: str, vulnerability_data: Dict[str, Any]) -> ExploitationResult:
        """
        Automated XSS exploitation with form injection, browser automation, and OOB callbacks.
        
        Args:
            target_url: Target URL with XSS vulnerability
            vulnerability_data: Vulnerability details (parameter, context, etc.)
        
        Returns:
            ExploitationResult with success status and evidence
        """
        if not self.config.enable_xss_exploitation:
            logger.debug("XSS exploitation disabled in configuration")
            return ExploitationResult(
                vulnerability_type='xss',
                success=False,
                error="XSS exploitation disabled"
            )
        
        logger.info(f"Starting XSS exploitation for {target_url}")
        self.exploitation_stats['total_attempts'] += 1
        
        try:
            # Use existing XSS plugin
            from scanner.plugins.exploits.xss_plugin import XSSPlugin
            
            plugin = XSSPlugin()
            
            # Prepare configuration
            config = {
                'enable_callback_verification': bool(self.config.oob_endpoint_base_url or self.config.oob_use_ngrok),
                'callback_use_ngrok': self.config.oob_use_ngrok,
                'callback_base_url': self.config.oob_endpoint_base_url,
                'callback_timeout': self.config.oob_timeout,
                'enable_browser_automation': self.config.browser_automation_enabled,
                'browser_engine': self.config.browser_automation_engine,
                'browser_headless': self.config.browser_headless,
                'capture_screenshots': self.config.capture_screenshots,
                'capture_dom': self.config.capture_dom_snapshots,
                'timeout': self.exploitation_timeout,
            }
            
            # Execute attack
            result = plugin.execute_attack(target_url, vulnerability_data, config)
            
            # Create exploitation result
            exploitation_result = ExploitationResult(
                vulnerability_type='xss',
                success=result.get('success', False),
                verified=result.get('verified', False),
                evidence=result.get('evidence', {}),
                proof_of_exploit=result.get('proof_of_exploit', {}),
                error=result.get('error')
            )
            
            # Update statistics
            if exploitation_result.success:
                self.exploitation_stats['successful_exploits'] += 1
                if exploitation_result.verified:
                    self.exploitation_stats['verified_exploits'] += 1
            else:
                self.exploitation_stats['failed_attempts'] += 1
            
            self.exploitation_stats['by_type']['xss'] = \
                self.exploitation_stats['by_type'].get('xss', 0) + 1
            
            return exploitation_result
            
        except Exception as e:
            logger.error(f"XSS exploitation failed: {e}", exc_info=True)
            self.exploitation_stats['failed_attempts'] += 1
            return ExploitationResult(
                vulnerability_type='xss',
                success=False,
                error=str(e)
            )
    
    def exploit_info_disclosure(self, target_url: str, vulnerability_data: Dict[str, Any]) -> ExploitationResult:
        """
        Automated information disclosure exploitation with file/path testing.
        
        Args:
            target_url: Base target URL
            vulnerability_data: Vulnerability details
        
        Returns:
            ExploitationResult with discovered information
        """
        if not self.config.enable_info_disclosure_exploitation:
            logger.debug("Info disclosure exploitation disabled in configuration")
            return ExploitationResult(
                vulnerability_type='info_disclosure',
                success=False,
                error="Info disclosure exploitation disabled"
            )
        
        logger.info(f"Starting info disclosure exploitation for {target_url}")
        self.exploitation_stats['total_attempts'] += 1
        
        try:
            from scanner.plugins.exploits.info_disclosure_plugin import InfoDisclosurePlugin
            
            plugin = InfoDisclosurePlugin()
            
            config = {
                'timeout': self.config.exploitation_timeout,
                'verify_content': True,
                'max_attempts': self.config.max_exploitation_attempts,
            }
            
            result = plugin.execute_attack(target_url, vulnerability_data, config)
            
            exploitation_result = ExploitationResult(
                vulnerability_type='info_disclosure',
                success=result.get('success', False),
                verified=result.get('verified', False),
                evidence=result.get('evidence', {}),
                proof_of_exploit=result.get('data', {}),
                error=result.get('error')
            )
            
            if exploitation_result.success:
                self.exploitation_stats['successful_exploits'] += 1
            else:
                self.exploitation_stats['failed_attempts'] += 1
            
            self.exploitation_stats['by_type']['info_disclosure'] = \
                self.exploitation_stats['by_type'].get('info_disclosure', 0) + 1
            
            return exploitation_result
            
        except Exception as e:
            logger.error(f"Info disclosure exploitation failed: {e}", exc_info=True)
            self.exploitation_stats['failed_attempts'] += 1
            return ExploitationResult(
                vulnerability_type='info_disclosure',
                success=False,
                error=str(e)
            )
    
    def exploit_security_misconfiguration(self, target_url: str, vulnerability_data: Dict[str, Any]) -> ExploitationResult:
        """
        Automated security misconfiguration exploitation (headers, CSP, etc.).
        
        Args:
            target_url: Target URL
            vulnerability_data: Misconfiguration details
        
        Returns:
            ExploitationResult with exploitation evidence
        """
        if not self.config.enable_security_misconfiguration_exploitation:
            logger.debug("Security misconfiguration exploitation disabled")
            return ExploitationResult(
                vulnerability_type='security_misconfiguration',
                success=False,
                error="Security misconfiguration exploitation disabled"
            )
        
        logger.info(f"Starting security misconfiguration exploitation for {target_url}")
        self.exploitation_stats['total_attempts'] += 1
        
        try:
            # Import security misconfiguration exploit module
            from scanner.plugins.exploits.security_misconfiguration_plugin import SecurityMisconfigurationPlugin
            
            plugin = SecurityMisconfigurationPlugin()
            
            config = {
                'timeout': self.config.exploitation_timeout,
                'test_browser_exploits': self.config.browser_automation_enabled,
                'browser_engine': self.config.browser_automation_engine,
                'capture_screenshots': self.config.capture_screenshots,
            }
            
            result = plugin.execute_attack(target_url, vulnerability_data, config)
            
            exploitation_result = ExploitationResult(
                vulnerability_type='security_misconfiguration',
                success=result.get('success', False),
                verified=result.get('verified', False),
                evidence=result.get('evidence', {}),
                proof_of_exploit=result.get('proof_of_exploit', {}),
                error=result.get('error')
            )
            
            if exploitation_result.success:
                self.exploitation_stats['successful_exploits'] += 1
            else:
                self.exploitation_stats['failed_attempts'] += 1
            
            self.exploitation_stats['by_type']['security_misconfiguration'] = \
                self.exploitation_stats['by_type'].get('security_misconfiguration', 0) + 1
            
            return exploitation_result
            
        except Exception as e:
            logger.error(f"Security misconfiguration exploitation failed: {e}", exc_info=True)
            self.exploitation_stats['failed_attempts'] += 1
            return ExploitationResult(
                vulnerability_type='security_misconfiguration',
                success=False,
                error=str(e)
            )
    
    def exploit_xxe(self, target_url: str, vulnerability_data: Dict[str, Any]) -> ExploitationResult:
        """
        Automated XXE exploitation with OOB verification.
        
        Args:
            target_url: Target URL with XXE vulnerability
            vulnerability_data: Vulnerability details
        
        Returns:
            ExploitationResult with file extraction or OOB confirmation
        """
        if not self.config.enable_xxe_exploitation:
            logger.debug("XXE exploitation disabled")
            return ExploitationResult(
                vulnerability_type='xxe',
                success=False,
                error="XXE exploitation disabled"
            )
        
        logger.info(f"Starting XXE exploitation for {target_url}")
        self.exploitation_stats['total_attempts'] += 1
        
        try:
            from scanner.plugins.exploits.xxe_plugin import XXEPlugin
            
            plugin = XXEPlugin()
            
            config = {
                'timeout': self.config.exploitation_timeout,
                'enable_oob': bool(self.config.oob_endpoint_base_url or self.config.oob_use_ngrok),
                'oob_callback_url': self.config.oob_endpoint_base_url,
                'oob_use_ngrok': self.config.oob_use_ngrok,
                'oob_timeout': self.config.oob_timeout,
                'max_attempts': self.config.max_exploitation_attempts,
            }
            
            result = plugin.execute_attack(target_url, vulnerability_data, config)
            
            exploitation_result = ExploitationResult(
                vulnerability_type='xxe',
                success=result.get('success', False),
                verified=result.get('verified', False),
                evidence=result.get('evidence', {}),
                proof_of_exploit=result.get('data', {}),
                error=result.get('error')
            )
            
            if exploitation_result.success:
                self.exploitation_stats['successful_exploits'] += 1
                if exploitation_result.verified:
                    self.exploitation_stats['verified_exploits'] += 1
            else:
                self.exploitation_stats['failed_attempts'] += 1
            
            self.exploitation_stats['by_type']['xxe'] = \
                self.exploitation_stats['by_type'].get('xxe', 0) + 1
            
            return exploitation_result
            
        except Exception as e:
            logger.error(f"XXE exploitation failed: {e}", exc_info=True)
            self.exploitation_stats['failed_attempts'] += 1
            return ExploitationResult(
                vulnerability_type='xxe',
                success=False,
                error=str(e)
            )
    
    def detect_mixed_content(self, target_url: str) -> ExploitationResult:
        """
        Detect and test mixed content vulnerabilities.
        
        Args:
            target_url: HTTPS URL to check for mixed content
        
        Returns:
            ExploitationResult with detected mixed content resources
        """
        if not self.config.enable_mixed_content_detection:
            logger.debug("Mixed content detection disabled")
            return ExploitationResult(
                vulnerability_type='mixed_content',
                success=False,
                error="Mixed content detection disabled"
            )
        
        logger.info(f"Starting mixed content detection for {target_url}")
        self.exploitation_stats['total_attempts'] += 1
        
        try:
            from scanner.plugins.exploits.mixed_content_plugin import MixedContentPlugin
            
            plugin = MixedContentPlugin()
            
            config = {
                'timeout': self.config.exploitation_timeout,
                'test_exploitability': self.config.browser_automation_enabled,
                'browser_engine': self.config.browser_automation_engine,
                'capture_screenshots': self.config.capture_screenshots,
            }
            
            result = plugin.execute_attack(target_url, {}, config)
            
            exploitation_result = ExploitationResult(
                vulnerability_type='mixed_content',
                success=result.get('success', False),
                verified=result.get('verified', False),
                evidence=result.get('evidence', {}),
                proof_of_exploit=result.get('mixed_content_resources', {}),
                error=result.get('error')
            )
            
            if exploitation_result.success:
                self.exploitation_stats['successful_exploits'] += 1
            else:
                self.exploitation_stats['failed_attempts'] += 1
            
            self.exploitation_stats['by_type']['mixed_content'] = \
                self.exploitation_stats['by_type'].get('mixed_content', 0) + 1
            
            return exploitation_result
            
        except Exception as e:
            logger.error(f"Mixed content detection failed: {e}", exc_info=True)
            self.exploitation_stats['failed_attempts'] += 1
            return ExploitationResult(
                vulnerability_type='mixed_content',
                success=False,
                error=str(e)
            )
    
    def exploit_vulnerability(self, vulnerability_type: str, target_url: str, 
                            vulnerability_data: Dict[str, Any]) -> ExploitationResult:
        """
        Exploit a vulnerability based on its type.
        
        Args:
            vulnerability_type: Type of vulnerability (xss, xxe, info_disclosure, etc.)
            target_url: Target URL
            vulnerability_data: Vulnerability-specific data
        
        Returns:
            ExploitationResult
        """
        logger.info(f"Exploiting {vulnerability_type} vulnerability at {target_url}")
        
        # Route to appropriate exploitation method
        if vulnerability_type == 'xss':
            return self.exploit_xss(target_url, vulnerability_data)
        elif vulnerability_type == 'info_disclosure':
            return self.exploit_info_disclosure(target_url, vulnerability_data)
        elif vulnerability_type == 'security_misconfiguration':
            return self.exploit_security_misconfiguration(target_url, vulnerability_data)
        elif vulnerability_type == 'xxe':
            return self.exploit_xxe(target_url, vulnerability_data)
        elif vulnerability_type == 'mixed_content':
            return self.detect_mixed_content(target_url)
        else:
            logger.warning(f"Unknown vulnerability type: {vulnerability_type}")
            return ExploitationResult(
                vulnerability_type=vulnerability_type,
                success=False,
                error=f"Unknown vulnerability type: {vulnerability_type}"
            )
    
    def get_statistics(self) -> Dict[str, Any]:
        """
        Get exploitation statistics.
        
        Returns:
            Dictionary with statistics
        """
        return self.exploitation_stats.copy()
    
    def generate_report(self, results: List[ExploitationResult]) -> Dict[str, Any]:
        """
        Generate a comprehensive exploitation report.
        
        Args:
            results: List of exploitation results
        
        Returns:
            Dictionary containing detailed report
        """
        report = {
            'summary': {
                'total_exploits': len(results),
                'successful': sum(1 for r in results if r.success),
                'verified': sum(1 for r in results if r.verified),
                'failed': sum(1 for r in results if not r.success),
            },
            'by_type': {},
            'results': [],
            'statistics': self.get_statistics(),
            'generated_at': datetime.now().isoformat(),
        }
        
        # Group by vulnerability type
        for result in results:
            vuln_type = result.vulnerability_type
            if vuln_type not in report['by_type']:
                report['by_type'][vuln_type] = {
                    'total': 0,
                    'successful': 0,
                    'verified': 0,
                    'failed': 0,
                }
            
            report['by_type'][vuln_type]['total'] += 1
            if result.success:
                report['by_type'][vuln_type]['successful'] += 1
                if result.verified:
                    report['by_type'][vuln_type]['verified'] += 1
            else:
                report['by_type'][vuln_type]['failed'] += 1
            
            report['results'].append(result.to_dict())
        
        return report


def get_exploitation_controller(config: Optional[ExploitationConfig] = None) -> ExploitationAutomationController:
    """
    Get an instance of the exploitation automation controller.
    
    Args:
        config: Optional configuration
    
    Returns:
        ExploitationAutomationController instance
    """
    return ExploitationAutomationController(config)
